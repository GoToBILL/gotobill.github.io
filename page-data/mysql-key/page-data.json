{"componentChunkName":"component---src-templates-blog-post-js","path":"/mysql-key/","result":{"data":{"site":{"siteMetadata":{"title":"GoToBill"}},"markdownRemark":{"id":"aa1b5e74-6ee7-5bdd-99ab-4caca4c908d5","excerpt":"이 글은 Real MySQL 8.0 책의 내용을 참고하여 작성되었습니다. possible_keys…","html":"<blockquote>\n<p>이 글은 Real MySQL 8.0 책의 내용을 참고하여 작성되었습니다.</p>\n</blockquote>\n<h2>possible_keys 컬럼</h2>\n<p><strong>의미</strong>: 옵티마이저가 후보로 선정했던 인덱스 목록</p>\n<p><strong>특징</strong></p>\n<ul>\n<li>실제로 사용된 인덱스가 아니라 \"사용될 법했던\" 인덱스 목록입니다</li>\n<li>테이블의 모든 인덱스가 나열되는 경우가 많아 튜닝에 큰 도움이 되지 않습니다</li>\n<li><strong>실행 계획 확인 시 무시해도 됩니다</strong></li>\n</ul>\n<p><strong>주의사항</strong></p>\n<p>possible_keys에 인덱스가 나열됐다고 해서 그 인덱스를 사용한다고 판단하지 마세요. 실제 사용 인덱스는 <strong>key 컬럼</strong>을 확인해야 합니다.</p>\n<hr>\n<h2>key 컬럼</h2>\n<p><strong>의미</strong>: 최종 선택된 실행 계획에서 <strong>실제로 사용하는 인덱스</strong></p>\n<p><strong>중요성</strong></p>\n<p>쿼리 튜닝 시 의도한 인덱스가 표시되는지 확인하는 것이 매우 중요합니다.</p>\n<p><strong>표시 값</strong></p>\n<ul>\n<li><code class=\"language-text\">PRIMARY</code>: 프라이머리 키 사용</li>\n<li><code class=\"language-text\">NULL</code>: 인덱스를 전혀 사용하지 않음 (type이 ALL일 때)</li>\n<li>그 외: 테이블/인덱스 생성 시 부여한 인덱스 이름</li>\n</ul>\n<p><strong>index_merge의 경우</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> employees\n<span class=\"token keyword\">WHERE</span> emp_no <span class=\"token operator\">BETWEEN</span> <span class=\"token number\">10001</span> <span class=\"token operator\">AND</span> <span class=\"token number\">11000</span>\n      <span class=\"token operator\">OR</span> first_name<span class=\"token operator\">=</span><span class=\"token string\">'Smith'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>type</th>\n<th>key</th>\n<th>key_len</th>\n<th>Extra</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>index_merge</td>\n<td>PRIMARY,ix_firstname</td>\n<td>4,58</td>\n<td>Using union(PRIMARY,ix_firstname); Using where</td>\n</tr>\n</tbody>\n</table>\n<p>type이 index_merge일 때는 2개 이상의 인덱스가 <code class=\"language-text\">,</code>로 구분되어 표시됩니다.</p>\n<hr>\n<h2>key_len 컬럼</h2>\n<p><strong>의미</strong>: 다중 컬럼 인덱스에서 <strong>몇 바이트까지 사용했는지</strong> 표시</p>\n<p>많은 사용자가 무시하지만 <strong>매우 중요한 정보</strong>입니다.</p>\n<h3>기본 예시</h3>\n<p><strong>프라이머리 키 일부만 사용</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- dept_emp 테이블: PRIMARY KEY (dept_no, emp_no)</span>\n<span class=\"token comment\">-- dept_no: CHAR(4), utf8mb4 문자셋 (4 * 4바이트 = 16바이트)</span>\n\n<span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> dept_emp <span class=\"token keyword\">WHERE</span> dept_no<span class=\"token operator\">=</span><span class=\"token string\">'d005'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>key</th>\n<th>key_len</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>dept_emp</td>\n<td>ref</td>\n<td>PRIMARY</td>\n<td>16</td>\n</tr>\n</tbody>\n</table>\n<p>dept_no만 사용했으므로 key_len이 16바이트입니다.</p>\n<p><strong>프라이머리 키 전체 사용</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- emp_no: INTEGER (4바이트)</span>\n\n<span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> dept_emp <span class=\"token keyword\">WHERE</span> dept_no<span class=\"token operator\">=</span><span class=\"token string\">'d005'</span> <span class=\"token operator\">AND</span> emp_no<span class=\"token operator\">=</span><span class=\"token number\">10001</span><span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>key</th>\n<th>key_len</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>dept_emp</td>\n<td>const</td>\n<td>PRIMARY</td>\n<td>20</td>\n</tr>\n</tbody>\n</table>\n<p>dept_no(16) + emp_no(4) = 20바이트입니다.</p>\n<h3>NULL 허용 컬럼</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> titles <span class=\"token punctuation\">(</span>\n    emp_no <span class=\"token keyword\">int</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n    title <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n    from_date <span class=\"token keyword\">date</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n    to_date <span class=\"token keyword\">date</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\">-- NULL 허용</span>\n    <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span>emp_no<span class=\"token punctuation\">,</span>from_date<span class=\"token punctuation\">,</span>title<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">KEY</span> ix_todate <span class=\"token punctuation\">(</span>to_date<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> titles <span class=\"token keyword\">WHERE</span> to_date<span class=\"token operator\">&lt;=</span><span class=\"token string\">'1985-10-10'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>key</th>\n<th>key_len</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>titles</td>\n<td>range</td>\n<td>ix_todate</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>\n<p><strong>DATE 타입은 3바이트인데 왜 4바이트?</strong></p>\n<p>NULL 허용 컬럼은 NULL 여부를 저장하기 위해 <strong>1바이트를 추가</strong>로 사용합니다.</p>\n<ul>\n<li>to_date: DATE 타입 3바이트</li>\n<li>NULL 플래그: 1바이트</li>\n<li><strong>합계: 4바이트</strong></li>\n</ul>\n<hr>\n<h2>ref 컬럼</h2>\n<p><strong>의미</strong>: 접근 방법이 ref일 때 <strong>참조 조건으로 어떤 값이 제공됐는지</strong> 표시</p>\n<p><strong>표시 값</strong></p>\n<ul>\n<li><code class=\"language-text\">const</code>: 상수값 사용</li>\n<li><code class=\"language-text\">테이블명.컬럼명</code>: 다른 테이블의 컬럼값 사용</li>\n<li><code class=\"language-text\">func</code>: 값의 변환이나 연산이 수행됨</li>\n</ul>\n<h3>일반적인 조인</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> employees e<span class=\"token punctuation\">,</span> dept_emp de\n<span class=\"token keyword\">WHERE</span> e<span class=\"token punctuation\">.</span>emp_no<span class=\"token operator\">=</span>de<span class=\"token punctuation\">.</span>emp_no<span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>key</th>\n<th>ref</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>de</td>\n<td>ALL</td>\n<td>NULL</td>\n<td>NULL</td>\n</tr>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>e</td>\n<td>eq_ref</td>\n<td>PRIMARY</td>\n<td>employees.de.emp_no</td>\n</tr>\n</tbody>\n</table>\n<p>조인 대상 컬럼 이름이 그대로 표시됩니다.</p>\n<h3>func가 표시되는 경우</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> employees e<span class=\"token punctuation\">,</span> dept_emp de\n<span class=\"token keyword\">WHERE</span> e<span class=\"token punctuation\">.</span>emp_no<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>de<span class=\"token punctuation\">.</span>emp_no<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>key</th>\n<th>ref</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>de</td>\n<td>ALL</td>\n<td>NULL</td>\n<td>NULL</td>\n</tr>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>e</td>\n<td>eq_ref</td>\n<td>PRIMARY</td>\n<td>func</td>\n</tr>\n</tbody>\n</table>\n<p><strong>func가 표시되는 상황</strong></p>\n<ul>\n<li>명시적인 값 변환 (예: <code class=\"language-text\">de.emp_no-1</code>)</li>\n<li>콜레이션 변환</li>\n<li>문자셋이 일치하지 않는 문자열 조인</li>\n<li>숫자 타입과 문자열 타입 조인</li>\n</ul>\n<p><strong>권장 사항</strong></p>\n<p>MySQL 서버가 내부 변환을 하지 않도록 조인 컬럼의 타입과 문자셋을 일치시키는 것이 좋습니다.</p>\n<hr>\n<h2>rows 컬럼</h2>\n<p><strong>의미</strong>: 실행 계획의 효율성 판단을 위해 <strong>예측한 레코드 건수</strong></p>\n<p><strong>특징</strong></p>\n<ul>\n<li>스토리지 엔진의 통계 정보를 기반으로 한 예상값입니다 (정확하지 않음)</li>\n<li><strong>반환할 레코드 수가 아니라</strong>, 읽고 체크해야 할 레코드 수입니다</li>\n<li>실제 쿼리 결과 건수와 일치하지 않는 경우가 많습니다</li>\n</ul>\n<h3>예시 1: 풀 테이블 스캔</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> dept_emp <span class=\"token keyword\">WHERE</span> from_date<span class=\"token operator\">>=</span><span class=\"token string\">'1985-01-01'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>key</th>\n<th>rows</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>dept_emp</td>\n<td>ALL</td>\n<td>NULL</td>\n<td>331143</td>\n</tr>\n</tbody>\n</table>\n<p>전체 레코드가 331,143건이므로 모든 레코드를 비교해야 한다고 판단했습니다.</p>\n<h3>예시 2: 인덱스 레인지 스캔</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> dept_emp <span class=\"token keyword\">WHERE</span> from_date<span class=\"token operator\">>=</span><span class=\"token string\">'2002-07-01'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>key</th>\n<th>rows</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>dept_emp</td>\n<td>range</td>\n<td>ix_fromdate</td>\n<td>292</td>\n</tr>\n</tbody>\n</table>\n<p>292건(8.8%)만 읽으면 되므로 인덱스 레인지 스캔을 선택했습니다.</p>\n<p><strong>참고</strong></p>\n<p>rows 값이 부정확하면 옵티마이저가 잘못된 실행 계획을 수립할 수 있습니다. MySQL 8.0부터는 <strong>히스토그램</strong> 기능으로 예측 정확도를 개선했습니다.</p>\n<hr>\n<h2>filtered 컬럼</h2>\n<p><strong>의미</strong>: 인덱스를 사용하지 못하는 조건으로 필터링한 후 남은 레코드 비율 (%)</p>\n<p><strong>핵심 개념</strong></p>\n<p>filtered 컬럼은 인덱스로 처리되지 않는 조건을 적용한 후 남은 레코드의 비율을 나타냅니다. 조인 시 다음 테이블로 전달될 실제 레코드 건수를 예측하는 데 중요합니다.</p>\n<h3>예시</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> employees e<span class=\"token punctuation\">,</span>\n     salaries s\n<span class=\"token keyword\">WHERE</span> e<span class=\"token punctuation\">.</span>first_name<span class=\"token operator\">=</span><span class=\"token string\">'Matt'</span>\n  <span class=\"token operator\">AND</span> e<span class=\"token punctuation\">.</span>hire_date <span class=\"token operator\">BETWEEN</span> <span class=\"token string\">'1990-01-01'</span> <span class=\"token operator\">AND</span> <span class=\"token string\">'1991-01-01'</span>\n  <span class=\"token operator\">AND</span> s<span class=\"token punctuation\">.</span>emp_no<span class=\"token operator\">=</span>e<span class=\"token punctuation\">.</span>emp_no\n  <span class=\"token operator\">AND</span> s<span class=\"token punctuation\">.</span>from_date <span class=\"token operator\">BETWEEN</span> <span class=\"token string\">'1990-01-01'</span> <span class=\"token operator\">AND</span> <span class=\"token string\">'1991-01-01'</span>\n  <span class=\"token operator\">AND</span> s<span class=\"token punctuation\">.</span>salary <span class=\"token operator\">BETWEEN</span> <span class=\"token number\">50000</span> <span class=\"token operator\">AND</span> <span class=\"token number\">60000</span><span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>key</th>\n<th>rows</th>\n<th>filtered</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>e</td>\n<td>ref</td>\n<td>ix_firstname</td>\n<td>233</td>\n<td>16.03</td>\n</tr>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>s</td>\n<td>ref</td>\n<td>PRIMARY</td>\n<td>10</td>\n<td>0.48</td>\n</tr>\n</tbody>\n</table>\n<p><strong>분석</strong></p>\n<p>employees 테이블에서:</p>\n<ol>\n<li><code class=\"language-text\">first_name='Matt'</code> (인덱스 사용): 233건 조회</li>\n<li><code class=\"language-text\">hire_date BETWEEN '1990-01-01' AND '1991-01-01'</code> (인덱스 미사용): 추가 필터링</li>\n<li>filtered 16.03% = 233건 중 16.03%만 hire_date 조건도 만족</li>\n<li><strong>실제 salaries 테이블로 조인되는 건수</strong>: 233 × 0.1603 = <strong>약 37건</strong></li>\n</ol>\n<p><strong>왜 중요한가?</strong></p>\n<p>옵티마이저는 조인 순서를 결정할 때 filtered 값을 참고합니다. 조인 후 남는 레코드가 적을수록 다음 테이블 조인 비용이 줄어들기 때문에 filtered 값이 낮은 테이블을 선행 테이블로 선택하는 경향이 있습니다.</p>\n<p><strong>개선 방안</strong></p>\n<p>MySQL 8.0부터는 <strong>히스토그램</strong> 기능으로 filtered 값의 예측 정확도를 높였습니다.</p>\n<hr>\n<p><strong>튜닝 체크리스트</strong></p>\n<ol>\n<li><strong>key</strong>: 의도한 인덱스가 사용되는가?</li>\n<li><strong>key_len</strong>: 다중 컬럼 인덱스를 충분히 활용하는가?</li>\n<li><strong>ref</strong>: func가 표시되면 타입/문자셋 불일치 확인</li>\n<li><strong>rows</strong>: 예상 읽기 건수가 합리적인가?</li>\n<li><strong>filtered</strong>: 조인 시 필터링 비율이 적절한가?</li>\n</ol>","wordCount":{"words":601},"frontmatter":{"title":"MySQL 실행 계획 - possible_keys, key, key_len, ref, rows, filtered 컬럼","date":"October 26, 2025","description":"MySQL 실행 계획에서 인덱스 사용과 비용 예측에 관련된 핵심 컬럼들을 알아봅니다."}},"previous":{"fields":{"slug":"/mysql-type/"},"frontmatter":{"title":"MySQL 실행 계획 - type 컬럼"}},"next":{"fields":{"slug":"/mysql-extra-part2/"},"frontmatter":{"title":"MySQL 실행 계획 - Extra 컬럼 (2편)"}}},"pageContext":{"id":"aa1b5e74-6ee7-5bdd-99ab-4caca4c908d5","previousPostId":"0be373a1-12aa-5f76-bf71-ee3d62c48bc3","nextPostId":"3f933b63-ddc6-5345-af67-76703c1284e7"}},"staticQueryHashes":["3257411868","3517523002"],"slicesMap":{}}