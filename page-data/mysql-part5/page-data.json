{"componentChunkName":"component---src-templates-blog-post-js","path":"/mysql-part5/","result":{"data":{"site":{"siteMetadata":{"title":"GoToBill"}},"markdownRemark":{"id":"fc8dd2a7-221d-5fd5-8e50-688bc7c7a494","excerpt":"InnoDB 잠금 종류 InnoDB 스토리지 엔진은 레코드 기반 잠금 기능을 제공합니다. 락 에스컬레이션이란?  일부 DBMS에서는 잠금 개수가 많아지면 메모리 부족을 방지하기 위해 여러 개의 레코드 락을 페이지 락이나 테이블 락으로 자동 업그레이드합니다.  예: 100…","html":"<h2>InnoDB 잠금 종류</h2>\n<p>InnoDB 스토리지 엔진은 <strong>레코드 기반 잠금 기능</strong>을 제공합니다.</p>\n<blockquote>\n<p><strong>락 에스컬레이션이란?</strong></p>\n<p><br>\n일부 DBMS에서는 잠금 개수가 많아지면 메모리 부족을 방지하기 위해 여러 개의 레코드 락을 페이지 락이나 테이블 락으로 자동 업그레이드합니다.</p>\n<p><br>\n예: 1000개 레코드 락 → 1개 테이블 락으로 변환</p>\n<p><br>\n<strong>InnoDB는 잠금 정보를 매우 작은 공간으로 관리하므로 락 에스컬레이션이 발생하지 않습니다.</strong></p>\n</blockquote>\n<p>일반 상용 DBMS와는 다르게 InnoDB에서는 다음과 같은 잠금 종류를 제공합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/59c75b04f97d222ea3bfe54bdf7a6878/715a3/5.1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 98.10126582278481%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB5klEQVR42pWUZ67CMBCEuf+BcgMEiPCDInrvvfe2T99KiwI4PFjJimPMeGZnnIg46n6/y/l8luPxqM/r9arP0+mkg3fbZ8Mq4gLc7XYymUxks9nIfD6XUqkkw+FQttutTKdTabVab4AGGnllRhnQfr+X1Wolg8FAgXifzWaSy+UeB8MY9k6GQcBmsynr9VoqlYpkMhlluVwupVgsiud5slgsJJVK6TqMAQ8F5Ec2lctlHYVCQYEAz2azkk6ndR/s6DPMmYcCwgyJ1OFwkNFopIwoWgBwcH+oKUHJAOImbOkbcnmnt7CmbrdbuCnBRUxAMk7Djnmv19NDarWa9u2V2cfYIKnRaKhMwDGlWq0qc+bJZPKNxBMgG9vttjKAUT6fl263q6AMHLc5wNFoVE0wyU+Al8tFOp2Oyur3+xpgWIzH44fjgNM7OxxACNBL+huaw6BkAO264bQFGJfj8bgC0xJUEZ2PLtM3ZHI6TMggbPgzkhOJhISVE5A7i5sMQozEWCwm9Xpd2VmwiZHTFFcOkczTBocw6PFrsP8F5KaYKfQMZgBRBNyC/TWgMSFChJte8uQQHKcVPwEikSjhLk4CgFG4bF+fnxlaiLlmvu/rV4Y1bsnXgFbcAJMGCNEhRvSSNfsSuQD/AGhX/2tW6boyAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"락 종류\"\n        title=\"\"\n        src=\"/static/59c75b04f97d222ea3bfe54bdf7a6878/f058b/5.1.png\"\n        srcset=\"/static/59c75b04f97d222ea3bfe54bdf7a6878/c26ae/5.1.png 158w,\n/static/59c75b04f97d222ea3bfe54bdf7a6878/6bdcf/5.1.png 315w,\n/static/59c75b04f97d222ea3bfe54bdf7a6878/f058b/5.1.png 630w,\n/static/59c75b04f97d222ea3bfe54bdf7a6878/715a3/5.1.png 830w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>레코드 락</h3>\n<p>레코드 자체만을 잠그는 것을 <strong>레코드 락</strong>(Record Lock, Record Only Lock)이라고 합니다. 다른 상용 DBMS의 레코드 락과 동일한 역할을 하지만, 중요한 차이점이 있습니다.</p>\n<p><strong>InnoDB는 레코드 자체가 아니라 인덱스의 레코드를 잠급니다.</strong></p>\n<ul>\n<li>인덱스가 하나도 없는 테이블이라도 내부적으로 자동 생성된 <strong>클러스터 인덱스</strong>를 이용해 잠금을 설정합니다.</li>\n<li>레코드 자체를 잠그느냐, 인덱스를 잠그느냐는 상당히 크고 중요한 차이를 만들어냅니다.</li>\n</ul>\n<p><strong>인덱스 종류에 따른 잠금 범위</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 1. 유니크 인덱스로 조회 (특정 레코드 1건만 존재)</span>\n<span class=\"token keyword\">UPDATE</span> users <span class=\"token keyword\">SET</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'홍길동'</span> <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 잠금: id=100 레코드만 잠금 (갭 락 없음)</span>\n<span class=\"token comment\">-- 이유: 유니크이므로 id=100은 딱 1건만 존재, 중간에 끼어들 수 없음</span>\n\n<span class=\"token comment\">-- 2. 일반 인덱스로 조회 (같은 값의 레코드가 여러 개 가능)</span>\n<span class=\"token keyword\">UPDATE</span> users <span class=\"token keyword\">SET</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'홍길동'</span> <span class=\"token keyword\">WHERE</span> age <span class=\"token operator\">=</span> <span class=\"token number\">30</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 잠금: age=30인 레코드들 + 그 사이사이 갭까지 잠금 (넥스트 키 락)</span>\n<span class=\"token comment\">-- 이유: age=30인 레코드 사이에 새로운 age=30 레코드가 INSERT될 수 있음</span></code></pre></div>\n<p><strong>왜 차이가 나는가?</strong></p>\n<ul>\n<li><strong>유니크 인덱스</strong>: 해당 값이 딱 1건만 존재 → 중간에 끼어들 여지가 없음 → 갭 락 불필요</li>\n<li><strong>일반 인덱스</strong>: 같은 값이 여러 개 → 그 사이에 새로운 레코드 INSERT 가능 → 갭 락 필요</li>\n</ul>\n<h3>갭 락</h3>\n<p><strong>갭 락</strong>(Gap Lock)은 레코드 자체가 아니라 <strong>레코드와 바로 인접한 레코드 사이의 간격만을 잠급니다.</strong></p>\n<p>갭 락의 역할은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT)되는 것을 제어하는 것입니다.</p>\n<p>갭 락 그 자체보다는 다음에 설명할 <strong>넥스트 키 락의 일부로 자주 사용</strong>됩니다.</p>\n<h3>넥스트 키 락</h3>\n<p><strong>레코드 락 + 갭 락 = 넥스트 키 락</strong>(Next Key Lock)</p>\n<p><strong>왜 필요한가?</strong></p>\n<p>MySQL의 복제(Replication) 환경에서 Master와 Replica 서버의 데이터 일관성을 보장하기 위해 필요합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- Master 서버</span>\n<span class=\"token keyword\">START</span> <span class=\"token keyword\">TRANSACTION</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">FROM</span> orders <span class=\"token keyword\">WHERE</span> price <span class=\"token operator\">>=</span> <span class=\"token number\">10000</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">-- 현재 10건 삭제</span>\n\n<span class=\"token comment\">-- 만약 갭 락이 없다면?</span>\n<span class=\"token comment\">-- 다른 트랜잭션에서 INSERT INTO orders VALUES (11, 15000); 실행 가능</span>\n\n<span class=\"token keyword\">COMMIT</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- 바이너리 로그에 기록됨: \"DELETE FROM orders WHERE price >= 10000\"</span></code></pre></div>\n<p><strong>문제 상황</strong></p>\n<ul>\n<li><strong>갭 락이 없으면</strong>: DELETE 실행 중에 price=15000인 새 주문이 INSERT될 수 있음</li>\n<li><strong>Replica 서버에서 재생 시</strong>: 이 INSERT가 없는 상태에서 DELETE 실행</li>\n<li><strong>결과</strong>: Master는 11건 삭제, Replica는 10건 삭제 → <strong>데이터 불일치</strong></li>\n</ul>\n<p><strong>넥스트 키 락으로 해결</strong></p>\n<ul>\n<li>DELETE 실행 시 price >= 10000 범위의 레코드 + 갭까지 모두 잠금</li>\n<li>그 사이에 INSERT 불가능</li>\n<li>Master와 Replica의 결과가 동일하게 보장됨</li>\n</ul>\n<blockquote>\n<p><strong>바이너리 로그 포맷 차이</strong></p>\n<p><br>\n<strong>STATEMENT 포맷</strong>: SQL 문장 자체를 기록</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- Master에서 실행</span>\n<span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">FROM</span> orders <span class=\"token keyword\">WHERE</span> price <span class=\"token operator\">>=</span> <span class=\"token number\">10000</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- 바이너리 로그에 기록</span>\n<span class=\"token string\">\"DELETE FROM orders WHERE price >= 10000\"</span>\n\n<span class=\"token comment\">-- Replica에서 이 SQL을 그대로 재실행</span>\n<span class=\"token comment\">-- 문제: Replica 실행 시점에 Master와 데이터가 다를 수 있음</span>\n<span class=\"token comment\">-- 해결: 넥스트 키 락으로 INSERT 차단 필요</span></code></pre></div>\n<p><strong>ROW 포맷</strong>: 변경된 행의 실제 데이터를 기록</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- Master에서 실행</span>\n<span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">FROM</span> orders <span class=\"token keyword\">WHERE</span> price <span class=\"token operator\">>=</span> <span class=\"token number\">10000</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- 바이너리 로그에 기록</span>\n<span class=\"token string\">\"id=5, price=10000 삭제\"</span>\n<span class=\"token string\">\"id=7, price=12000 삭제\"</span>\n<span class=\"token string\">\"id=9, price=15000 삭제\"</span>\n\n<span class=\"token comment\">-- Replica에서 정확히 이 행들만 삭제</span>\n<span class=\"token comment\">-- 중간에 INSERT가 있어도 상관없음 (삭제할 행이 명확히 지정됨)</span>\n<span class=\"token comment\">-- 해결: 넥스트 키 락 불필요</span></code></pre></div>\n<p>ROW 포맷은 삭제할 행을 명확히 지정하므로 갭 락이 불필요하여 성능이 향상됩니다.</p>\n</blockquote>\n<h3>자동 증가 락</h3>\n<p><strong>AUTO_INCREMENT 락이란?</strong></p>\n<p><strong>AUTO_INCREMENT 컬럼</strong></p>\n<p>JPA의 <code class=\"language-text\">@GeneratedValue(strategy = GenerationType.IDENTITY)</code>을 사용할 때, 여러 커넥션에서 동시에 INSERT해도 ID 값이 중복되지 않도록 보장하는 테이블 수준의 잠금입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 테이블 정의</span>\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> users <span class=\"token punctuation\">(</span>\n    id <span class=\"token keyword\">BIGINT</span> <span class=\"token keyword\">AUTO_INCREMENT</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\">-- JPA @GeneratedValue(IDENTITY)</span>\n    name <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- 동시에 두 INSERT 실행</span>\n<span class=\"token comment\">-- Connection 1</span>\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> users <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'홍길동'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">-- id=1 할당</span>\n\n<span class=\"token comment\">-- Connection 2</span>\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> users <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'김철수'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">-- id=2 할당 (중복 없이)</span></code></pre></div>\n<p><strong>특징</strong></p>\n<ul>\n<li>INSERT/REPLACE에서만 사용 (UPDATE/DELETE는 무관)</li>\n<li>ID 값을 가져오는 순간만 잠금 후 즉시 해제</li>\n<li>트랜잭션과 무관하게 작동</li>\n</ul>\n<p><strong>락 방식의 차이</strong></p>\n<blockquote>\n<p><strong>AUTO_INCREMENT 락 vs 경량 래치(Mutex)</strong></p>\n<p><br>\n<strong>AUTO_INCREMENT 락</strong>: INSERT 문장이 완료될 때까지 락 유지 (느림)</p>\n<p><br>\n<strong>경량 래치(Mutex)</strong>: ID 값만 가져가면 즉시 해제 (빠름, 뮤텍스라고도 함)</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- AUTO_INCREMENT 락 사용 시</span>\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> users <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token keyword\">SELECT</span> name <span class=\"token keyword\">FROM</span> temp_users<span class=\"token punctuation\">;</span>  <span class=\"token comment\">-- 1000건</span>\n<span class=\"token comment\">-- 1. 락 획득</span>\n<span class=\"token comment\">-- 2. ID 1~1000 할당</span>\n<span class=\"token comment\">-- 3. 1000건 모두 INSERT 완료</span>\n<span class=\"token comment\">-- 4. 락 해제 ← INSERT가 끝나야 해제 (느림)</span>\n\n<span class=\"token comment\">-- 경량 래치 사용 시</span>\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> users <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'홍길동'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 1. 래치 획득</span>\n<span class=\"token comment\">-- 2. ID=5 할당받음</span>\n<span class=\"token comment\">-- 3. 래치 즉시 해제 ← INSERT 완료 전에 해제 (빠름)</span>\n<span class=\"token comment\">-- 4. INSERT 계속 진행</span>\n<span class=\"token comment\">-- → 다른 커넥션이 바로 ID=6 받아갈 수 있음</span></code></pre></div>\n<p><strong>innodb_autoinc_lock_mode 설정 (MySQL 8.0 기준)</strong></p>\n<table>\n<thead>\n<tr>\n<th>모드</th>\n<th>잠금 방식</th>\n<th>성능</th>\n<th>연속성</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>0</strong></td>\n<td>모든 INSERT에 락 사용</td>\n<td>느림</td>\n<td>완벽 보장</td>\n</tr>\n<tr>\n<td><strong>1</strong></td>\n<td>단순 INSERT는 래치, 대량은 락</td>\n<td>중간</td>\n<td>한 문장만</td>\n</tr>\n<tr>\n<td><strong>2</strong> (기본값)</td>\n<td>모든 INSERT에 래치만</td>\n<td>빠름</td>\n<td>보장 안 됨</td>\n</tr>\n</tbody>\n</table>\n<p><strong>각 모드별 동작 예시</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 모드 1: 단순 INSERT (건수 예측 가능)</span>\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> users <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'홍길동'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">-- 경량 래치 사용 (빠름)</span>\n\n<span class=\"token comment\">-- 모드 1: 대량 INSERT (건수 예측 불가)</span>\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> users <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token keyword\">SELECT</span> name <span class=\"token keyword\">FROM</span> temp_users<span class=\"token punctuation\">;</span>  <span class=\"token comment\">-- AUTO_INCREMENT 락 사용 (느림)</span>\n\n<span class=\"token comment\">-- 모드 2: 모든 경우</span>\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> users <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>  <span class=\"token comment\">-- 항상 경량 래치 (가장 빠름, 하지만 연속성 보장 안 됨)</span></code></pre></div>\n<blockquote>\n<p><strong>ID 연속성이 보장되지 않는다는 의미</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- Connection 1이 대량 INSERT 시작</span>\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> users <span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> temp_users<span class=\"token punctuation\">;</span>  <span class=\"token comment\">-- 1000건</span>\n\n<span class=\"token comment\">-- 모드 1 (연속성 보장):</span>\n<span class=\"token comment\">-- 1. Connection 1이 AUTO_INCREMENT 락 획득</span>\n<span class=\"token comment\">-- 2. id=1~1000 모두 할당받음</span>\n<span class=\"token comment\">-- 3. 1000건 INSERT 완료</span>\n<span class=\"token comment\">-- 4. 락 해제</span>\n<span class=\"token comment\">-- → Connection 1이 끝날 때까지 다른 커넥션은 대기</span>\n<span class=\"token comment\">-- → 결과: Connection 1은 id=1~1000을 연속으로 받음</span>\n\n<span class=\"token comment\">-- 모드 2 (연속성 보장 안 됨):</span>\n<span class=\"token comment\">-- 1. Connection 1: id=1 받음 → 래치 즉시 해제</span>\n<span class=\"token comment\">-- 2. Connection 1: id=2 받음 → 래치 즉시 해제</span>\n<span class=\"token comment\">-- 3. Connection 2: id=3 받음 → 래치 즉시 해제 (끼어듦!)</span>\n<span class=\"token comment\">-- 4. Connection 1: id=4 받음 → 래치 즉시 해제</span>\n<span class=\"token comment\">-- 5. Connection 2: id=5 받음 → 래치 즉시 해제 (또 끼어듦!)</span>\n<span class=\"token comment\">-- 6. Connection 1: id=6 받음...</span>\n<span class=\"token comment\">-- → Connection 1은 id=1,2,4,6,7... (중간이 빠짐)</span>\n<span class=\"token comment\">-- → Connection 2는 id=3,5,8,10... (끼어든 것들)</span></code></pre></div>\n<p><br>\n<strong>핵심</strong>: 모드 2에서는 대량 INSERT 중간에 다른 커넥션이 끼어들어 ID를 가져갈 수 있어서, 한 INSERT 문장이 연속된 ID를 받지 못합니다.</p>\n<p><br>\n<strong>MySQL 8.0 기본값이 2인 이유</strong></p>\n<p><br>\nROW 포맷은 실제 데이터를 기록하므로 (\"id=1 삭제\", \"id=3 삭제\") ID 순서가 뒤섞여도 복제에 문제가 없습니다.</p>\n<p><br>\n<strong>STATEMENT 포맷 사용 시 주의</strong>: 모드 2에서는 Master와 Replica의 AUTO_INCREMENT 값이 달라질 수 있으므로 모드 1로 변경 권장</p>\n</blockquote>\n<p><strong>왜 INSERT 실패 시 ID가 건너뛰는가?</strong></p>\n<p>AUTO_INCREMENT는 <strong>테이블 전체에서 공유하는 하나의 카운터</strong>입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- AUTO_INCREMENT 카운터 = 5 (테이블 전체 공유)</span>\n\n<span class=\"token comment\">-- Connection 1</span>\n<span class=\"token comment\">-- 1. 래치 획득 → 카운터에서 5 받음 → 카운터 6으로 증가 → 래치 해제</span>\n<span class=\"token comment\">-- 2. INSERT 실행 중...</span>\n\n<span class=\"token comment\">-- Connection 2 (동시에 실행)</span>\n<span class=\"token comment\">-- 1. 래치 획득 → 카운터에서 6 받음 → 카운터 7으로 증가 → 래치 해제</span>\n<span class=\"token comment\">-- 2. INSERT 완료</span>\n\n<span class=\"token comment\">-- Connection 3</span>\n<span class=\"token comment\">-- 1. 래치 획득 → 카운터에서 7 받음 → 카운터 8으로 증가 → 래치 해제</span>\n<span class=\"token comment\">-- 2. INSERT 완료</span>\n\n<span class=\"token comment\">-- Connection 1</span>\n<span class=\"token comment\">-- 3. INSERT 실패! (중복 이메일)</span>\n<span class=\"token comment\">-- 4. 카운터를 5로 되돌리려면?</span>\n<span class=\"token comment\">--    → 이미 카운터는 8</span>\n<span class=\"token comment\">--    → 다른 커넥션이 6, 7 사용 중</span>\n<span class=\"token comment\">--    → 되돌리면 6, 7과 충돌! (매우 복잡)</span></code></pre></div>\n<p>그래서 <strong>실패해도 카운터는 되돌리지 않고</strong>, id=5는 영구 건너뛴 채로 단순하게 처리합니다.</p>\n<h2>인덱스와 잠금</h2>\n<p>InnoDB의 잠금과 인덱스는 상당히 중요한 연관 관계가 있습니다. <strong>InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리됩니다.</strong></p>\n<p>즉, <strong>변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 합니다.</strong></p>\n<h3>예제: 인덱스와 잠금 범위</h3>\n<p>employees 테이블에 다음과 같은 인덱스가 있다고 가정하겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- ix_firstname 인덱스 구성</span>\n<span class=\"token keyword\">KEY</span> ix_firstname <span class=\"token punctuation\">(</span>first_name<span class=\"token punctuation\">)</span></code></pre></div>\n<p><strong>데이터 분포</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- first_name='Georgi'인 사원: 253명</span>\nmysql<span class=\"token operator\">></span> <span class=\"token keyword\">SELECT</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> employees <span class=\"token keyword\">WHERE</span> first_name<span class=\"token operator\">=</span><span class=\"token string\">'Georgi'</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">+</span><span class=\"token comment\">----------+</span>\n<span class=\"token operator\">|</span>      <span class=\"token number\">253</span> <span class=\"token operator\">|</span>\n<span class=\"token operator\">+</span><span class=\"token comment\">----------+</span>\n\n<span class=\"token comment\">-- first_name='Georgi'이고 last_name='Klassen'인 사원: 1명</span>\nmysql<span class=\"token operator\">></span> <span class=\"token keyword\">SELECT</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> employees <span class=\"token keyword\">WHERE</span> first_name<span class=\"token operator\">=</span><span class=\"token string\">'Georgi'</span> <span class=\"token operator\">AND</span> last_name<span class=\"token operator\">=</span><span class=\"token string\">'Klassen'</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">+</span><span class=\"token comment\">----------+</span>\n<span class=\"token operator\">|</span>        <span class=\"token number\">1</span> <span class=\"token operator\">|</span>\n<span class=\"token operator\">+</span><span class=\"token comment\">----------+</span></code></pre></div>\n<p><strong>UPDATE 쿼리 실행</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">mysql<span class=\"token operator\">></span> <span class=\"token keyword\">UPDATE</span> employees\n<span class=\"token keyword\">SET</span> hire_date<span class=\"token operator\">=</span><span class=\"token function\">NOW</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">WHERE</span> first_name<span class=\"token operator\">=</span><span class=\"token string\">'Georgi'</span> <span class=\"token operator\">AND</span> last_name<span class=\"token operator\">=</span><span class=\"token string\">'Klassen'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>결과 분석</strong></p>\n<ul>\n<li>실제로 업데이트되는 레코드: 1건</li>\n<li>실제로 잠금이 걸리는 레코드: 253건</li>\n</ul>\n<p><strong>왜 253건이 잠기는가?</strong></p>\n<ol>\n<li>인덱스를 이용할 수 있는 조건은 <code class=\"language-text\">first_name='Georgi'</code></li>\n<li><code class=\"language-text\">last_name</code> 컬럼은 인덱스에 없음</li>\n<li>따라서 <code class=\"language-text\">first_name='Georgi'</code>인 레코드 253건을 모두 검색하면서 잠금</li>\n<li>각 레코드에서 <code class=\"language-text\">last_name='Klassen'</code> 조건을 추가로 필터링</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d491435c5d210719aa646475b105866a/37523/5.2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.55696202531645%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACEklEQVR42nVTyWoqURDNl2cVFDdR4rwTF6KJiorzPCYYBREXEkWMC6cYTdTgrOe9U9DmCb6G6tt1695TdU5V3+DvczwecTqdzkZfeQ6HA/b7/XmPK/do154bHvj4+EC73cbb25usg8FAgsvlEu/v7+J3Oh28vLyg2+2i3++j1+thtVrJOaUQAeSrUChAr9fDYrFAq9UiHo9LcDqdwuFwwGw24+HhASqVCjqdDlarFU6nEz8/P2fAc4V8xWIx3N/f4/b2Fnd3d/B4PBIcj8cwGAzQaDSS0GQyCSCT2mw2qfT7+xufn59iBBbAWq2GRCIhF9xuN/L5PDabjVAleCgUkjgtk8mIXywW0Wg08Pr6img0ilKpJFoLYKVSQTAYlCpcLpdcYnA0GsnlZDKJbDaLXC4nyejTqCm1rdfraDabv4DValWyGI1GeL1e0ZRdJGUFMJ1OCyhN8ZUGrtdr7Ha7X8oEjEQiQvnx8VEq3G63GA6HeHp6gs/nQzgclqRMQJ+6U8P5fC5nL5pCQFJWq9Ww2+1CjeWzQlbs9/sFjBYIBASQwAS82mUCplIp0Y+VUGBS5nzyIqsnTZ5hZYqGyrxeANJptVoCyq6x4xSZ+7PZTLSips/Pz5KoXC4LA64c/KuAHGDOETOSBqkuFgt8fX1Jp+krMepKY/zfX/QCkMNJ42VeJFV+c2UiJqRPm0wmsve/f/kPOhiUruxhVnoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"업데이트시의 잠금\"\n        title=\"\"\n        src=\"/static/d491435c5d210719aa646475b105866a/f058b/5.2.png\"\n        srcset=\"/static/d491435c5d210719aa646475b105866a/c26ae/5.2.png 158w,\n/static/d491435c5d210719aa646475b105866a/6bdcf/5.2.png 315w,\n/static/d491435c5d210719aa646475b105866a/f058b/5.2.png 630w,\n/static/d491435c5d210719aa646475b105866a/37523/5.2.png 720w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>인덱스가 하나도 없다면?</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 사용자가 생성한 인덱스가 없어도 InnoDB는 자동으로 클러스터 인덱스를 생성</span>\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> test <span class=\"token punctuation\">(</span>\n    id <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span>           <span class=\"token comment\">-- PRIMARY KEY 없음</span>\n    name <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">UPDATE</span> test <span class=\"token keyword\">SET</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'홍길동'</span> <span class=\"token keyword\">WHERE</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'김철수'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- 동작:</span>\n<span class=\"token comment\">-- 1. 클러스터 인덱스(내부적으로 자동 생성)로 풀 스캔</span>\n<span class=\"token comment\">-- 2. 모든 레코드를 검색하면서 잠금</span>\n<span class=\"token comment\">-- 3. name='김철수' 조건에 맞는 레코드만 UPDATE</span>\n<span class=\"token comment\">-- 4. 결과: 30만 건 모두 잠금 (1건만 UPDATE해도!)</span></code></pre></div>\n<blockquote>\n<p><strong>클러스터 인덱스 자동 생성 규칙</strong></p>\n<ol>\n<li>\n<p>PRIMARY KEY가 있으면 그것을 클러스터 인덱스로 사용</p>\n</li>\n<li>\n<p>PRIMARY KEY가 없으면 첫 번째 UNIQUE NOT NULL 인덱스를 사용</p>\n</li>\n<li>\n<p>둘 다 없으면 InnoDB가 숨겨진 6바이트 Row ID를 자동 생성하여 클러스터 인덱스로 사용</p>\n</li>\n</ol>\n<p><strong>문제</strong>: 자동 생성된 Row ID 클러스터 인덱스는 WHERE 조건에 사용할 수 없어서, 결국 풀 스캔하며 모든 레코드에 잠금을 걸게 됩니다.</p>\n</blockquote>\n<blockquote>\n<p><strong>인덱스 설계의 중요성</strong></p>\n<p><br>\nUPDATE 문장을 위해 적절한 인덱스가 준비되어 있지 않다면 클라이언트 간의 동시성이 상당히 떨어집니다.</p>\n<p><br>\n한 세션에서 UPDATE 작업을 하는 중에는 다른 클라이언트는 그 테이블을 업데이트하지 못하고 기다려야 하는 상황이 발생합니다.</p>\n</blockquote>\n<h2>레코드 수준의 잠금 확인 및 해제</h2>\n<p>InnoDB 스토리지 엔진을 사용하는 테이블의 레코드 수준 잠금은 테이블 수준 잠금보다 조금 더 복잡합니다.</p>\n<ul>\n<li><strong>테이블 잠금</strong>: 잠금의 대상이 테이블 자체라 쉽게 문제의 원인을 발견하고 해결 가능</li>\n<li><strong>레코드 잠금</strong>: 각각의 레코드에 잠금이 걸리므로 자주 사용되지 않으면 오랜 시간 잠겨 있어도 잘 발견되지 않음</li>\n</ul>\n<p><strong>MySQL 버전별 잠금 조회 방법</strong></p>\n<ul>\n<li><strong>MySQL 5.1 이전</strong>: 레코드 잠금에 대한 메타 정보(딕셔너리 테이블)를 제공하지 않아 어려움</li>\n<li><strong>MySQL 5.1 ~ 7.x</strong>: <code class=\"language-text\">information_schema</code>의 <code class=\"language-text\">INNODB_TRX</code>, <code class=\"language-text\">INNODB_LOCKS</code>, <code class=\"language-text\">INNODB_LOCK_WAITS</code> 테이블로 확인</li>\n<li><strong>MySQL 8.0 이상</strong>: <code class=\"language-text\">performance_schema</code>의 <code class=\"language-text\">data_locks</code>와 <code class=\"language-text\">data_lock_waits</code> 테이블로 대체</li>\n</ul>\n<p>강제 해제는 <code class=\"language-text\">KILL</code> 명령어로 프로세스를 종료하면 됩니다.</p>\n<h3>잠금 시나리오 예제</h3>\n<table>\n<thead>\n<tr>\n<th align=\"left\">커넥션 1</th>\n<th align=\"left\">커넥션 2</th>\n<th align=\"left\">커넥션 3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code class=\"language-text\">BEGIN;</code></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code class=\"language-text\">UPDATE employees SET birth_date=NOW() WHERE emp_no=100001;</code></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\"><code class=\"language-text\">UPDATE employees SET hire_date=NOW() WHERE emp_no=100001;</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"><code class=\"language-text\">UPDATE employees SET hire_date=NOW(), birth_date=NOW() WHERE emp_no=100001;</code></td>\n</tr>\n</tbody>\n</table>\n<h3>프로세스 목록 확인</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">mysql<span class=\"token operator\">></span> <span class=\"token keyword\">SHOW</span> PROCESSLIST<span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">+----+------+-----------+-------+---------+------+----------+------------------------------------------------------------------+\n| Id | User | Host      | db    | Command | Time | State    | Info                                                             |\n+----+------+-----------+-------+---------+------+----------+------------------------------------------------------------------+\n| 17 | root | localhost | testdb| Sleep   | 607  |          | NULL                                                             |\n| 18 | root | localhost | testdb| Query   | 22   | updating | UPDATE employees SET hire_date=NOW() WHERE emp_no=100001         |\n| 19 | root | localhost | testdb| Query   | 21   | updating | UPDATE employees SET hire_date=NOW(), birth_date=NOW() WHERE ... |\n+----+------+-----------+-------+---------+------+----------+------------------------------------------------------------------+</code></pre></div>\n<p><strong>결과 해석</strong></p>\n<ul>\n<li>\n<p><strong>17번 스레드</strong>: <code class=\"language-text\">Sleep</code> 상태, 607초 동안 유휴 상태</p>\n<ul>\n<li>트랜잭션을 시작(<code class=\"language-text\">BEGIN</code>)하고 UPDATE 후 커밋하지 않은 상태</li>\n<li>현재 실행 중인 쿼리가 없어서 <code class=\"language-text\">NULL</code>로 표시</li>\n<li><strong>이 스레드가 잠금을 보유하고 있어서 다른 스레드들이 대기 중</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>18번 스레드</strong>: <code class=\"language-text\">updating</code> 상태, 22초 동안 대기</p>\n<ul>\n<li>17번 스레드가 잠근 레코드를 UPDATE하려고 시도</li>\n<li>잠금을 획득하지 못해 대기 중</li>\n</ul>\n</li>\n<li>\n<p><strong>19번 스레드</strong>: <code class=\"language-text\">updating</code> 상태, 21초 동안 대기</p>\n<ul>\n<li>17번과 18번 스레드가 잠근 레코드를 UPDATE하려고 시도</li>\n<li>두 스레드 모두 완료될 때까지 대기 중</li>\n</ul>\n</li>\n</ul>\n<h3>잠금 대기 순서 확인</h3>\n<p><code class=\"language-text\">performance_schema</code>의 <code class=\"language-text\">data_locks</code> 테이블과 <code class=\"language-text\">data_lock_waits</code> 테이블을 조인하여 잠금 대기 순서를 확인합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">mysql<span class=\"token operator\">></span> <span class=\"token keyword\">SELECT</span>\n    r<span class=\"token punctuation\">.</span>trx_id waiting_trx_id<span class=\"token punctuation\">,</span>\n    r<span class=\"token punctuation\">.</span>trx_mysql_thread_id waiting_thread<span class=\"token punctuation\">,</span>\n    r<span class=\"token punctuation\">.</span>trx_query waiting_query<span class=\"token punctuation\">,</span>\n    b<span class=\"token punctuation\">.</span>trx_id blocking_trx_id<span class=\"token punctuation\">,</span>\n    b<span class=\"token punctuation\">.</span>trx_mysql_thread_id blocking_thread<span class=\"token punctuation\">,</span>\n    b<span class=\"token punctuation\">.</span>trx_query blocking_query\n<span class=\"token keyword\">FROM</span> performance_schema<span class=\"token punctuation\">.</span>data_lock_waits w\n<span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span> information_schema<span class=\"token punctuation\">.</span>innodb_trx b\n    <span class=\"token keyword\">ON</span> b<span class=\"token punctuation\">.</span>trx_id <span class=\"token operator\">=</span> w<span class=\"token punctuation\">.</span>blocking_engine_transaction_id\n<span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span> information_schema<span class=\"token punctuation\">.</span>innodb_trx r\n    <span class=\"token keyword\">ON</span> r<span class=\"token punctuation\">.</span>trx_id <span class=\"token operator\">=</span> w<span class=\"token punctuation\">.</span>requesting_engine_transaction_id<span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">+-------------+----------------+------------------+----------------+------------------+----------------+\n| waiting_trx | waiting_thread | waiting_query    | blocking_trx   | blocking_thread  | blocking_query |\n| _id         |                |                  | _id            |                  |                |\n+-------------+----------------+------------------+----------------+------------------+----------------+\n| 11990       | 19             | UPDATE employees | 11984          | 17               | NULL           |\n| 11990       | 19             | UPDATE employees | 11984          | 17               | NULL           |\n| 11989       | 18             | UPDATE employees | 11984          | 17               | NULL           |\n+-------------+----------------+------------------+----------------+------------------+----------------+</code></pre></div>\n<p><strong>결과 분석</strong></p>\n<ul>\n<li>18번 스레드는 17번 스레드를 기다리고 있음</li>\n<li>19번 스레드는 17번 스레드와 18번 스레드를 기다리고 있음</li>\n</ul>\n<p><strong>잠금 대기 큐</strong></p>\n<ol>\n<li>17번 스레드가 잠금을 해제</li>\n<li>18번 스레드가 잠금을 획득하고 UPDATE 완료 후 잠금 해제</li>\n<li>19번 스레드가 UPDATE 실행 가능</li>\n</ol>\n<h3>상세 잠금 정보 확인</h3>\n<p>17번 스레드가 어떤 잠금을 가지고 있는지 더 상세히 확인하려면 <code class=\"language-text\">performance_schema</code>의 <code class=\"language-text\">data_locks</code> 테이블을 조회합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">mysql<span class=\"token operator\">></span> <span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> performance_schema<span class=\"token punctuation\">.</span>data_locks\\G</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">*************************** 1. row ***************************\n                  ENGINE: INNODB\n                        ...\n               LOCK_TYPE: TABLE\n               LOCK_MODE: IX\n             LOCK_STATUS: GRANTED\n               LOCK_DATA: NULL\n*************************** 2. row ***************************\n                  ENGINE: INNODB\n                        ...\n               LOCK_TYPE: RECORD\n               LOCK_MODE: X,REC_NOT_GAP\n             LOCK_STATUS: GRANTED\n               LOCK_DATA: 100001</code></pre></div>\n<p><strong>결과 해석</strong></p>\n<p>17번 스레드가 <strong>2개의 락을 동시에 보유</strong>하고 있습니다:</p>\n<p><strong>1행</strong>: 테이블에 IX 잠금 (의도 표시)</p>\n<ul>\n<li><code class=\"language-text\">LOCK_TYPE: TABLE</code></li>\n<li><code class=\"language-text\">LOCK_MODE: IX</code> (Intention Exclusive)</li>\n<li>역할: \"이 테이블에 레코드 락을 걸 예정\"이라고 선언</li>\n</ul>\n<p><strong>2행</strong>: 실제 레코드에 쓰기 잠금</p>\n<ul>\n<li><code class=\"language-text\">LOCK_TYPE: RECORD</code></li>\n<li><code class=\"language-text\">LOCK_MODE: X,REC_NOT_GAP</code></li>\n<li>역할: <code class=\"language-text\">emp_no=100001</code> 레코드를 실제로 잠금</li>\n</ul>\n<blockquote>\n<p><strong>IX 잠금의 역할</strong></p>\n<p>InnoDB는 레코드 락을 걸 때 <strong>항상 2단계</strong>로 진행합니다:</p>\n<ol>\n<li>\n<p><strong>먼저</strong> 테이블에 IX 락을 걸어서 의도를 표시</p>\n</li>\n<li>\n<p><strong>그 다음</strong> 실제 레코드에 레코드 락을 걸음</p>\n</li>\n</ol>\n<p>IX 락은 실제 데이터 접근을 막지 않고, <code class=\"language-text\">LOCK TABLES</code> 같은 테이블 전체 락과의 충돌만 방지합니다.</p>\n</blockquote>\n<p><strong>다른 레코드는 동시에 접근 가능한가?</strong></p>\n<p><strong>인덱스가 있는 경우</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- Connection 1</span>\n<span class=\"token keyword\">BEGIN</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">UPDATE</span> employees <span class=\"token keyword\">SET</span> salary <span class=\"token operator\">=</span> <span class=\"token number\">5000</span> <span class=\"token keyword\">WHERE</span> emp_no <span class=\"token operator\">=</span> <span class=\"token number\">100001</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- IX 락 + emp_no=100001 레코드 락만</span>\n\n<span class=\"token comment\">-- Connection 2 (다른 레코드)</span>\n<span class=\"token keyword\">UPDATE</span> employees <span class=\"token keyword\">SET</span> salary <span class=\"token operator\">=</span> <span class=\"token number\">6000</span> <span class=\"token keyword\">WHERE</span> emp_no <span class=\"token operator\">=</span> <span class=\"token number\">100002</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 성공! 동시 실행 가능</span>\n\n<span class=\"token comment\">-- Connection 3 (같은 레코드)</span>\n<span class=\"token keyword\">UPDATE</span> employees <span class=\"token keyword\">SET</span> salary <span class=\"token operator\">=</span> <span class=\"token number\">7000</span> <span class=\"token keyword\">WHERE</span> emp_no <span class=\"token operator\">=</span> <span class=\"token number\">100001</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 대기! emp_no=100001은 Connection 1이 보유 중</span></code></pre></div>\n<p><strong>인덱스가 없는 경우</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> test <span class=\"token punctuation\">(</span>\n    id <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span>           <span class=\"token comment\">-- PRIMARY KEY 없음</span>\n    name <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- Connection 1</span>\n<span class=\"token keyword\">BEGIN</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">UPDATE</span> test <span class=\"token keyword\">SET</span> salary <span class=\"token operator\">=</span> <span class=\"token number\">5000</span> <span class=\"token keyword\">WHERE</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'홍길동'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- IX 락 + 전체 레코드 락 (30만 건)</span>\n\n<span class=\"token comment\">-- Connection 2 (다른 조건)</span>\n<span class=\"token keyword\">UPDATE</span> test <span class=\"token keyword\">SET</span> salary <span class=\"token operator\">=</span> <span class=\"token number\">6000</span> <span class=\"token keyword\">WHERE</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'김철수'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 대기! '김철수' 레코드도 이미 Connection 1이 잠금</span>\n\n<span class=\"token comment\">-- Connection 3 (전혀 다른 조건)</span>\n<span class=\"token keyword\">UPDATE</span> test <span class=\"token keyword\">SET</span> age <span class=\"token operator\">=</span> <span class=\"token number\">30</span> <span class=\"token keyword\">WHERE</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'박영희'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 대기! '박영희' 레코드도 이미 Connection 1이 잠금</span></code></pre></div>\n<p><strong>핵심</strong>: IX 락끼리는 충돌하지 않습니다. 실제 충돌은 <strong>레코드 락 레벨</strong>에서 발생합니다. 하지만 인덱스가 없으면 전체 레코드를 잠그므로 WHERE 조건이 달라도 모두 대기하게 됩니다.</p>\n<h3>잠금 강제 해제</h3>\n<p>17번 스레드가 잠금을 가진 상태에서 상당히 오래 시간 멈춰 있다면 다음과 같이 강제 종료하여 나머지 UPDATE 명령들이 실행되도록 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">mysql<span class=\"token operator\">></span> <span class=\"token keyword\">KILL</span> <span class=\"token number\">17</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>MySQL의 격리 수준</h2>\n<h3>격리 수준이란?</h3>\n<p><strong>트랜잭션의 격리 수준</strong>(Isolation Level)이란 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것입니다.</p>\n<h3>4가지 격리 수준</h3>\n<ol>\n<li><strong>READ UNCOMMITTED</strong></li>\n<li><strong>READ COMMITTED</strong></li>\n<li><strong>REPEATABLE READ</strong></li>\n<li><strong>SERIALIZABLE</strong></li>\n</ol>\n<p><strong>특징</strong></p>\n<ul>\n<li>격리 수준이 높아질수록 트랜잭션 간의 데이터 격리(고립) 정도가 높아집니다.</li>\n<li><strong>격리 수준이 높아질수록 동시 처리 성능은 떨어지는 것이 일반적입니다.</strong></li>\n<li><strong>SERIALIZABLE</strong> 격리 수준이 아니라면 크게 성능의 개선이나 저하는 발생하지 않습니다.</li>\n</ul>\n<h3>격리 수준별 부정합 문제</h3>\n<p>데이터베이스의 격리 수준을 이야기하면 항상 함께 언급되는 <strong>세 가지 부정합 문제</strong>가 있습니다.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>DIRTY READ</th>\n<th>NON-REPEATABLE READ</th>\n<th>PHANTOM READ</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>READ UNCOMMITTED</td>\n<td>발생</td>\n<td>발생</td>\n<td>발생</td>\n</tr>\n<tr>\n<td>READ COMMITTED</td>\n<td>없음</td>\n<td>발생</td>\n<td>발생</td>\n</tr>\n<tr>\n<td>REPEATABLE READ</td>\n<td>없음</td>\n<td>없음</td>\n<td>발생(InnoDB는 없음)</td>\n</tr>\n<tr>\n<td>SERIALIZABLE</td>\n<td>없음</td>\n<td>없음</td>\n<td>없음</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p><strong>InnoDB의 특별한 점</strong></p>\n<p><br>\nSQL-92 또는 SQL-99 표준에 따르면 REPEATABLE READ 격리 수준에서는 PHANTOM READ가 발생할 수 있지만, <strong>InnoDB에서는 독특한 특성 때문에 REPEATABLE READ 격리 수준에서도 PHANTOM READ가 발생하지 않습니다.</strong></p>\n</blockquote>\n<p><strong>부정합 문제 상세 설명</strong></p>\n<ul>\n<li><strong>DIRTY READ</strong>: 커밋되지 않은 데이터를 읽는 문제</li>\n<li><strong>NON-REPEATABLE READ</strong>: 하나의 트랜잭션에서 같은 쿼리를 두 번 실행했을 때 결과가 다른 문제</li>\n<li><strong>PHANTOM READ</strong>: 같은 쿼리를 두 번 실행했을 때 없던 레코드가 나타나는 문제</li>\n</ul>\n<p>각 부정합 문제에 대한 상세한 내용은 각 격리 수준별 설명에서 다루겠습니다.</p>\n<blockquote>\n<p><strong>테스트 환경 설정</strong></p>\n<p>여기서 설명하는 SQL 예제는 모두 <strong>AUTOCOMMIT이 OFF인 상태</strong>에서만 테스트할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SET</span> autocommit<span class=\"token operator\">=</span><span class=\"token keyword\">OFF</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>왜 자동 커밋이 false여야 할까?</strong></p>\n<p><br>\nAUTO-COMMIT을 자동으로 해놓으면 각 SQL 문이 바로 커밋됩니다.</p>\n<p><br>\nSELECT, UPDATE, INSERT, DELETE 등 모든 명령이 자체적으로 트랜잭션을 시작하고 끝내기 때문에 트랜잭션은 Rollback이 불가능합니다.</p>\n</blockquote>\n<h3>READ UNCOMMITTED</h3>\n<p>READ UNCOMMITTED 격리 수준에서는 각 트랜잭션에서의 변경 내용이 <strong>COMMIT이나 ROLLBACK 여부와 상관없이 다른 트랜잭션에서 보입니다.</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/75ced9fd5cd6720205a7bad1697e467d/084e2/read_uncomm.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 92.40506329113923%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB+ElEQVR42pVUyaoCMRCcLxc8qKg/4MmDFxdEBAURvAgeBEU9KO4r7vu+az2qIaLyfM5rCJmZdCpV1Z3R7vc7lsslFosF1uu1PO92O3yLw+GA+XyO1Wolg/uu1ys0AubzeVSrVcxmM1nsdDpfAZmbzWYxGAyEzHg8lm8CmEqlkEgk0Gq10O12ZWZw7bfBmEwmiMViKBQKQqBerwsZTSWRcqPRQK1Ww36/x+12w+l0egC8B+Ux+v2+MLxcLpKrqQ2bzUZo851A5/NZfOr1ejIojaxUvpqn0+mL5y+A9IBBdgxKsdlsMBgMMJvNMBqNKJVKLww/Am63W6FPD8mI73x2Op3weDzw+/1wuVxot9svh/7JkLK4SHOPx6Mc4Ha7EQwGEYlEZB4Oh/oB3yWzUKxkOBxGNBpFPB6XvH8DKn/K5TIsFov4Z7fbYbVapQsYrCovAu1hV+hiSA8dDge8Xq946PP5kEwm0Ww2pVfT6TQymYx0hS5AMuAtKhaLqFQqyOVyUnkWjMx49aiC7fUVUH0nKItEWWrQW/YsZx6kWzL9on/sQ5PJJB5Sru6isCVGo5GczrahPPYe2yUUCiEQCDzaRhWOt+fPxqYvTKJUAvOPwmZmgXiAkvf16hGAQM/J6sdBeWq832UeSjIPQPVAiWrheeOneCbCvQrwB42rTn1gVNTUAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"read_uncommited\"\n        title=\"\"\n        src=\"/static/75ced9fd5cd6720205a7bad1697e467d/f058b/read_uncomm.png\"\n        srcset=\"/static/75ced9fd5cd6720205a7bad1697e467d/c26ae/read_uncomm.png 158w,\n/static/75ced9fd5cd6720205a7bad1697e467d/6bdcf/read_uncomm.png 315w,\n/static/75ced9fd5cd6720205a7bad1697e467d/f058b/read_uncomm.png 630w,\n/static/75ced9fd5cd6720205a7bad1697e467d/084e2/read_uncomm.png 632w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>시나리오</strong></p>\n<ol>\n<li>사용자 A가 <code class=\"language-text\">emp_no=500000</code>, <code class=\"language-text\">first_name=\"Lara\"</code>인 새로운 사원을 INSERT</li>\n<li>사용자 A가 커밋하기 전에 사용자 B가 <code class=\"language-text\">emp_no=500000</code>인 사원을 SELECT</li>\n<li><strong>사용자 B는 커밋되지 않은 상태에서도 사원 정보를 조회할 수 있음</strong></li>\n<li>사용자 A가 알 수 없는 문제로 INSERT를 ROLLBACK</li>\n<li>사용자 B는 여전히 \"Lara\"가 정상적인 사원이라고 생각하고 계속 처리</li>\n</ol>\n<p><strong>DIRTY READ란?</strong></p>\n<p>어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상을 <strong>더티 리드</strong>(Dirty Read)라고 합니다.</p>\n<p><strong>문제점</strong></p>\n<ul>\n<li>데이터가 나타났다가 사라졌다 하는 현상 발생</li>\n<li>애플리케이션 개발자와 사용자를 상당히 혼란스럽게 만듦</li>\n<li>RDBMS 표준에서는 트랜잭션의 격리 수준으로 인정하지 않을 정도로 정합성에 문제가 많음</li>\n</ul>\n<blockquote>\n<p><strong>권장사항</strong></p>\n<p><br>\nMySQL을 사용한다면 최소한 <strong>READ COMMITTED 이상의 격리 수준</strong>을 사용할 것을 권장합니다.</p>\n</blockquote>\n<h3>READ COMMITTED</h3>\n<p><strong>READ COMMITTED</strong>는 Oracle DBMS에서 기본으로 사용되는 격리 수준이며, 온라인 서비스에서 가장 많이 선택되는 격리 수준입니다.</p>\n<p><strong>특징</strong></p>\n<ul>\n<li>더티 리드(Dirty Read) 같은 현상은 발생하지 않음</li>\n<li><strong>COMMIT이 완료된 데이터만</strong> 다른 트랜잭션에서 조회 가능</li>\n</ul>\n<h4>COMMIT된 데이터만 읽기</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/19b6b22e4756c29a07ff646dc3012a73/8ae78/read_commit1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 87.34177215189874%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAACJklEQVR42o1UN6uqQRD1z9pZWylc7AQrC0OhqJUINlZiIQYQTGBEDJhzzlnPe2cfK3rDuw4My7e7c/bMnJlPgb+22Wwwn8+xXq+xWq2w3W4h7X6/v/jtdhP7x+NRxPA+45bLJa7XKxS81Ol0kEqlMB6PBVi73cb5fH4B/GwEYkyj0cBiscBoNBKrgoetVgvxeBzValWAd7vdR2AgEIDJZILdbofNZkO5XBb7ZJVMJlEoFNBsNgXwfr//x5DGD75CI3W5er1eGI1GWK1WWCwWpNNpcSZTn06ngq3MRiGZsCb9fh+Xy+WRIoPq9TpqtZp4bDgcilrJYBrrKGv+AsiaMZ1er4fT6SScjxCAYFzp8kHJ8FdA1mIwGAg2dLfbDZ1OB71eD4PBgGw2+5Lyj4CHw+FRQ7Kg86LH44HZbIbL5RKiRCIR0Q30XC4nnLHfAk4mk0dLMF0KRfX9fj/C4TCi0agAoBC8S3ZUeLfbfQVkMC/QE4kESqWS6KtYLAan0ynahmwJ+HbKfJmtQoacntlsho+PDyiVSqjVaqhUKvh8PiEYBSIQ+/ZHQJmybAmCs1ZsJ55RsGKxiEqlIoaBE0Uhmd1/AZnOd+MmBSMAWfJBdsTbDGlkRWEymQzy+fzLVPxaQ6b3XHCaw+EQ9dNoNNBqtQgGg++JwhT4c2BdOC1Mi87ZDYVCgh3/Ljx7ZkjhKOAXQNaGyvFlTg3rw5V7VJ9BdPbnM+DnvT/3+/kbdkf8FwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"read_commited\"\n        title=\"\"\n        src=\"/static/19b6b22e4756c29a07ff646dc3012a73/f058b/read_commit1.png\"\n        srcset=\"/static/19b6b22e4756c29a07ff646dc3012a73/c26ae/read_commit1.png 158w,\n/static/19b6b22e4756c29a07ff646dc3012a73/6bdcf/read_commit1.png 315w,\n/static/19b6b22e4756c29a07ff646dc3012a73/f058b/read_commit1.png 630w,\n/static/19b6b22e4756c29a07ff646dc3012a73/40601/read_commit1.png 945w,\n/static/19b6b22e4756c29a07ff646dc3012a73/8ae78/read_commit1.png 1096w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>시나리오</strong></p>\n<ol>\n<li>사용자 A가 <code class=\"language-text\">emp_no=500000</code>인 사원의 <code class=\"language-text\">first_name</code>을 \"Lara\"에서 \"Toto\"로 변경\n<ul>\n<li>새로운 값 \"Toto\"는 employees 테이블에 즉시 기록</li>\n<li>이전 값 \"Lara\"는 <strong>언두 영역</strong>으로 백업</li>\n</ul>\n</li>\n<li>사용자 A가 커밋을 수행하기 전에 사용자 B가 <code class=\"language-text\">emp_no=500000</code>인 사원을 SELECT\n<ul>\n<li>조회된 결과의 <code class=\"language-text\">first_name</code>은 \"Toto\"가 아니라 <strong>\"Lara\"</strong></li>\n<li>SELECT 쿼리 결과는 employees 테이블이 아니라 <strong>언두 영역에 백업된 레코드</strong>에서 가져옴</li>\n</ul>\n</li>\n<li>사용자 A가 변경된 내용을 커밋\n<ul>\n<li>그때부터 다른 트랜잭션에서도 새롭게 변경된 \"Toto\" 값을 참조 가능</li>\n</ul>\n</li>\n</ol>\n<h4>NON-REPEATABLE READ 문제</h4>\n<p>READ COMMITTED 격리 수준에서도 <strong>NON-REPEATABLE READ</strong>라는 부정합 문제가 있습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f76f1150b12d916ce574fe02669d13c5/1843f/read_commit2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 79.74683544303798%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB0ElEQVR42pVUuaoCQRD08w0EDcREUUED0chIDTQVETFQRPAW7/u+td6rhpZ1vd5rmO1he6e6u7p2LPi1w+GAzWaD/X4v/ng84pudTies12vsdjtst1vBoFn4mEwmyGazmM1mmM/nGA6HErzdbrher+J1r7ZcLpHP5zEajeRMr9d7BMxkMqhWq2g2mxiPx/eDCmi21WqFdDqNYrGIdrv9CMgDbKHf74u/XC4SZGaHwwGr1QqbzYZwOCxxXd1uF+VyWZLqGYtmPJ/PmE6n91ZppMDtdiMUCglYIpGQStguY6yMoMYzd0BmYOtm4kkDOV0sFhgMBmi1WgJGn8vlUCgUXgOyQjOg2ZiUSqAKOF0mqtfrrwHJA1vgQHSaTOD1euHxeGSlUqmHw/xOB/gEyBe1Wk1a5ASpLe7tdjtcLhecTiei0ehdQlzsirJ5WyF5oWxIPHniPhKJIB6PIxaLibTMFLytkICdTkd4oVw4EPKkMnqlx48tG4eiQcojGAwKj36/H8lk8uHP0cl/lY0GWSmH4fP5EAgERIsUMikh35RMpVL5u2zYbqlUkioYoye3XI1GQ8A+6tD4D+tHfE9gao9e29WujBfJ01B4df3HCMIrzGg/luG/bWAJkfsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"read_commited\"\n        title=\"\"\n        src=\"/static/f76f1150b12d916ce574fe02669d13c5/f058b/read_commit2.png\"\n        srcset=\"/static/f76f1150b12d916ce574fe02669d13c5/c26ae/read_commit2.png 158w,\n/static/f76f1150b12d916ce574fe02669d13c5/6bdcf/read_commit2.png 315w,\n/static/f76f1150b12d916ce574fe02669d13c5/f058b/read_commit2.png 630w,\n/static/f76f1150b12d916ce574fe02669d13c5/40601/read_commit2.png 945w,\n/static/f76f1150b12d916ce574fe02669d13c5/1843f/read_commit2.png 1186w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>시나리오</strong></p>\n<ol>\n<li>사용자 B가 <code class=\"language-text\">BEGIN</code> 명령으로 트랜잭션을 시작</li>\n<li>사용자 B가 <code class=\"language-text\">first_name=\"Toto\"</code>인 사용자를 검색 → 결과 없음</li>\n<li>사용자 A가 사원 번호 500000인 사원의 이름을 \"Toto\"로 변경하고 커밋</li>\n<li>사용자 B가 똑같은 SELECT 쿼리로 다시 조회 → 결과 1건 조회됨</li>\n</ol>\n<blockquote>\n<p><strong>READ COMMITTED의 동작 원리</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 초기 상태: name='Lara'</span>\n\n<span class=\"token comment\">-- 사용자 A</span>\n<span class=\"token keyword\">UPDATE</span> users <span class=\"token keyword\">SET</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Toto'</span> <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 실제 테이블: name='Toto' (즉시 변경)</span>\n<span class=\"token comment\">-- 언두 로그: name='Lara' (백업)</span>\n<span class=\"token comment\">-- 아직 커밋 안 함</span>\n\n<span class=\"token comment\">-- 사용자 B (READ COMMITTED)</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> users <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 결과: name='Lara'</span>\n<span class=\"token comment\">-- 왜? 커밋되지 않은 데이터는 언두 로그에서 변경 전 데이터를 읽음</span>\n\n<span class=\"token comment\">-- 사용자 A</span>\n<span class=\"token keyword\">COMMIT</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">-- 커밋 완료</span>\n\n<span class=\"token comment\">-- 사용자 B (같은 트랜잭션 내에서)</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> users <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 결과: name='Toto'</span>\n<span class=\"token comment\">-- 왜? 커밋된 데이터는 실제 테이블에서 읽음</span></code></pre></div>\n<p><br>\n<strong>READ COMMITTED의 핵심</strong>:</p>\n<ul>\n<li><strong>커밋 안 된 데이터</strong>: 언두 로그에서 변경 전 데이터를 읽음</li>\n<li><strong>커밋된 데이터</strong>: 실제 테이블에서 변경 후 데이터를 읽음</li>\n<li>같은 트랜잭션 내에서도 <strong>매번 커밋 상태를 확인</strong>하므로 결과가 달라집니다.</li>\n</ul>\n</blockquote>\n<p><strong>문제점</strong></p>\n<p>사용자 B가 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 한다는 <strong>REPEATABLE READ 정합성에 어긋납니다.</strong></p>\n<h3>REPEATABLE READ</h3>\n<p><strong>REPEATABLE READ</strong>는 MySQL의 InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준입니다.</p>\n<p><strong>특징</strong></p>\n<ul>\n<li>바이너리 로그를 가진 MySQL 서버에서는 최소 REPEATABLE READ 격리 수준 이상을 사용해야 함</li>\n<li>READ COMMITTED 격리 수준에서 발생하는 <strong>NON-REPEATABLE READ</strong> 부정합이 발생하지 않음</li>\n<li><strong>MVCC</strong>(Multi Version Concurrency Control)를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보장</li>\n</ul>\n<h4>MVCC를 통한 스냅샷 격리</h4>\n<blockquote>\n<p><strong>MVCC란?</strong></p>\n<p><br>\n레코드가 변경되기 전의 데이터를 언두(Undo) 공간에 백업하여, 동일한 레코드에 여러 버전의 데이터가 존재하도록 하는 방식입니다.</p>\n<p><br>\nREPEATABLE READ는 MVCC를 활용하여 트랜잭션 시작 시점의 스냅샷을 기준으로 항상 동일한 결과를 보장합니다.</p>\n</blockquote>\n<p><strong>트랜잭션 번호와 스냅샷 메커니즘</strong></p>\n<ul>\n<li>모든 트랜잭션은 <strong>고유한 트랜잭션 번호</strong>(순차적으로 증가)를 가짐</li>\n<li>언두 영역의 백업 레코드에는 <strong>변경한 트랜잭션의 번호</strong>가 포함됨</li>\n<li>트랜잭션은 <strong>자신의 번호보다 작은 트랜잭션 번호에서 변경한 데이터만 조회</strong></li>\n<li>실행 중인 가장 오래된 트랜잭션 번호보다 앞선 언두 데이터는 삭제 불가능</li>\n</ul>\n<h4>동작 예시</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3287abb19d0801b762664fa9b873ea1e/636d3/repeatable1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 98.73417721518987%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAABYlAAAWJQFJUiTwAAACdklEQVR42pVUW0tyURD1tyo+CIa+i/4JLxCZig+CvvQgPghqBoKCpFSmFpWXMvKS5l3RXLHmY8tJi/wGhn3O2bPXXrNm5ug+Pz8xmUzEx+MxptMpDrXZbIbRaCRneJ5Yus1mg+vra9Trddl8e3vDcrmUA+v1WoIYQ+czncb15eUFlUoFHx8fcm4wGPwDvLq6ws3NDZ6fn9FsNgVIa4zRGvcXiwUeHh6Qy+XkTKPREEI6Fdzv9/H+/i7B6tvFxQVcLpe42+2Gz+dDqVSSDMiO8U9PT2i329tsdOpWolMHLYtMJoNwOAy/3y9rKBSSbIbDocQzxXK5LO8qk2+AdGWr1UrEJvPHx0dZ6a1WC91uF9VqVfS7vLxEr9f7GZBV3tVMFURbWV5EdmTG1L8BqmAG1Go12WQgdcpmszg9PUUgEEAwGEQkEpEYVWUaSbDKe4AUmBVTN7INotEovF4vnE4nTk5O4PF4UCwWtxqrzH4EJEO2jbrx9fUV+XweiUQCsVhMKs5ntohWlj2Gu1VWE8OUO52ONPzt7S3u7u6E/a7OvwJygyxZPU4OdWSqer0eBoMBJpMJRqMRyWTyMA358f7+XrSjhmwRsiMz9hpbh8/8rmW4p6FiSEYEm8/n0hpq8AnEEePKiVBzfpCGu/pwMmw2G+x2u7jD4UA6nZY9ArMfmcWvk6IAaQzmRLCqnAYOP1nyndPCArET+FNhy/0JyL8Jb2aa1I5ALBpl0U7On22jNjjLx8fHMJvNODo6gtVqhcViwdnZmcSQPZ29qy3UFpC3aH8O1KhQKCCVSiEej0tjn5+fC1uyZ48SkAXjugfIIFXB/zGe4VllX6ex1NiEcKEfAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"repeatable_read\"\n        title=\"\"\n        src=\"/static/3287abb19d0801b762664fa9b873ea1e/f058b/repeatable1.png\"\n        srcset=\"/static/3287abb19d0801b762664fa9b873ea1e/c26ae/repeatable1.png 158w,\n/static/3287abb19d0801b762664fa9b873ea1e/6bdcf/repeatable1.png 315w,\n/static/3287abb19d0801b762664fa9b873ea1e/f058b/repeatable1.png 630w,\n/static/3287abb19d0801b762664fa9b873ea1e/40601/repeatable1.png 945w,\n/static/3287abb19d0801b762664fa9b873ea1e/636d3/repeatable1.png 1222w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>시나리오</strong></p>\n<ol>\n<li>사용자 B: 트랜잭션 시작 (트랜잭션 번호: 10)</li>\n<li>사용자 A: 트랜잭션 시작 (트랜잭션 번호: 12) → <code class=\"language-text\">emp_no=500000</code>의 이름을 \"Lara\"에서 \"Toto\"로 변경 후 커밋</li>\n<li>사용자 B: <code class=\"language-text\">emp_no=500000</code> 조회 → 결과는 항상 <strong>\"Lara\"</strong> (언두 로그에서 조회)</li>\n</ol>\n<blockquote>\n<p><strong>주의사항</strong></p>\n<p><br>\n장시간 트랜잭션을 종료하지 않으면 언두 영역이 무한정 커져 <strong>MySQL 서버의 처리 성능이 떨어질 수 있습니다.</strong></p>\n</blockquote>\n<h4>PHANTOM READ 문제</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/fd12afb359aa633402ca7bf4c6527e4d/8affb/repeatable2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 89.24050632911393%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAACC0lEQVR42o1U16piQRD0x9VfuIig6A+Igr4YUFQUffBBFDEj5pxzDrVUw7jn6r27NgwzJ1RNdU336B6PB/b7PXa7HQ6Hg8x890kcj0f5X8232w06gmu1GqrVKjabDZbLJebzuQD47XWo4LrdbqNUKmG1WglmNptBx4/NZhP5fB6tVguDwUAUK9BPcb/fcT6f5f9MJiN44ihIp0Db7Raj0ehNCVNZLBZYr9eSGon4jgRURJXD4fCJ0ykg/SOQQS8YgUAAer0eBoNBhtFoRDwelwyoZjqdolAoPHG/EiqFjUYD6XQa0WgUqVRK1sViUbKhum63K89az38l5KBSqiGY8/V6lTXV0bd6vY5KpYLJZPKXUKkhoFwuizdMhT4lk0l8fX3BZDLBbDbDbrfL4Wlt4X/fFCpCGp5IJISUu6p0g8EgPB4PfD4f/H6/pKi15TWzbynzlJkWyTkIjkQicDgcCIfDCIVCstHHhPSEhc3B8uh0Oshms5ImB9fj8fhzwl6v92w/enq5XP7bfv8kfC0b7Ym/xkcK1Qe2FoOH43Q64XK54Ha74fV63zxkTdKijwhjsRhsNhusVqvMFotFSoltyFKhRezljwubz/1+H7lcTnqWB8LuICFvGN5S7KAfCVVHaNMhiIQEciYZC5+HxuLnJtyM5fZGqG4RLSFnpq+9D/nMWlWdcjqdxEdF+AcuVVAkqwUrLgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"phantom_read\"\n        title=\"\"\n        src=\"/static/fd12afb359aa633402ca7bf4c6527e4d/f058b/repeatable2.png\"\n        srcset=\"/static/fd12afb359aa633402ca7bf4c6527e4d/c26ae/repeatable2.png 158w,\n/static/fd12afb359aa633402ca7bf4c6527e4d/6bdcf/repeatable2.png 315w,\n/static/fd12afb359aa633402ca7bf4c6527e4d/f058b/repeatable2.png 630w,\n/static/fd12afb359aa633402ca7bf4c6527e4d/40601/repeatable2.png 945w,\n/static/fd12afb359aa633402ca7bf4c6527e4d/8affb/repeatable2.png 1254w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>REPEATABLE READ에서도 PHANTOM READ가 발생하는 경우</h4>\n<blockquote>\n<p><strong>일반 SELECT만 사용하면 PHANTOM READ가 발생하지 않습니다.</strong></p>\n<p><br>\n일반 SELECT는 트랜잭션 시작 시점의 스냅샷(언두 로그)을 읽기 때문에 중간에 INSERT가 발생해도 영향을 받지 않습니다.</p>\n<p><br>\n<strong>하지만 SELECT -> INSERT -> SELECT FOR UPDATE 순서면 PHANTOM READ가 발생할 수 있습니다.</strong></p>\n</blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/bb8c3414aa67ebf9d7a43a645e9b4bb7/85053/phan1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 82.27848101265823%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB6ElEQVR42pVUiZKbMAzl/7+us9vt7nQbNkAODgfCDb5eZYNNkmlnss4otmQhS3rPDriQ0BoYpwl5wWDGTDahNHJW4VLVdi2kwrXpECUnDBMHVwr9OCHcH/C5i7D7SjDOHAH5ImEtPo8X/DmV+E1zO3KA7JI+Ula0FaMLKb2upLY6J3H2wGSUVy3ivEZc1Iiykk6SS6bKZLqsnxmm0kCbfxopBX2PMyi3Sb8fRYKf7Ai1+vTDiCxnmKbZB7nOA17Ir+OT1W2GdTfiyBrKrkZWNuBCmYrRixmT5HCHmtmUdZ+VtlWYBGAzJGOYVvhIGHbnEq9fGeph9iVYP1ps8qhvhxkJ3ImsGRBmV8g1ypLNAsjjx4+2Wz1YfXBpR8SsWwP+r+mEtFRPglK2+LXPKODmIIsCIk03AOoGYXRA0/beVhMor8VhA8Vn2IzYEyi3PdfELS3EdoDhHBeWc24YBkxKeCZQD5eNvOossYVyQNhpkVV/LO/W7taBi5xfe0K5ItYvO/of4m+IfgKUspsJlPauh54337spi3ImUN6i/B4UxiCyzK7N42HAMFJcKn9b9DyDh6HvtSV2Q49BWvU4lT3xccTsqEEN1isAGy+VfST0TfM058vsrl5IvXsjynzEOV7C8/LafKvYreS/c9rmp6NkHB4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"팬텀리드\"\n        title=\"\"\n        src=\"/static/bb8c3414aa67ebf9d7a43a645e9b4bb7/f058b/phan1.png\"\n        srcset=\"/static/bb8c3414aa67ebf9d7a43a645e9b4bb7/c26ae/phan1.png 158w,\n/static/bb8c3414aa67ebf9d7a43a645e9b4bb7/6bdcf/phan1.png 315w,\n/static/bb8c3414aa67ebf9d7a43a645e9b4bb7/f058b/phan1.png 630w,\n/static/bb8c3414aa67ebf9d7a43a645e9b4bb7/40601/phan1.png 945w,\n/static/bb8c3414aa67ebf9d7a43a645e9b4bb7/85053/phan1.png 1225w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>PHANTOM READ가 발생하는 원리</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- Transaction A</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> member <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">>=</span> <span class=\"token number\">50</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 갭 락 없음, 언두 로그 읽음 → id=50 한 건</span>\n\n<span class=\"token comment\">-- Transaction B</span>\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> member <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token number\">51</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'홍길순'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">COMMIT</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">-- 갭 락이 없어서 성공</span>\n\n<span class=\"token comment\">-- Transaction A (같은 트랜잭션)</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> member <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">>=</span> <span class=\"token number\">50</span> <span class=\"token keyword\">FOR</span> <span class=\"token keyword\">UPDATE</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 쓰기 잠금 필요 → 실제 테이블 읽음 → id=50, 51 두 건 (PHANTOM READ!)</span></code></pre></div>\n<blockquote>\n<p><strong>왜 SELECT FOR UPDATE는 실제 테이블을 읽어야 하는가?</strong></p>\n<p><br>\n<strong>언두 로그에는 잠금을 걸 수 없기 때문입니다.</strong></p>\n<p><br>\n언두 로그는 여러 트랜잭션이 공유하는 읽기 전용 히스토리 공간으로, 과거 버전에 잠금을 걸면 다른 트랜잭션의 스냅샷 읽기를 방해합니다.</p>\n<p><br>\n따라서 <code class=\"language-text\">SELECT FOR UPDATE</code>는 쓰기 잠금을 걸어야 하므로 실제 테이블의 현재 레코드를 읽을 수밖에 없습니다.</p>\n</blockquote>\n<blockquote>\n<p><strong>SELECT FOR UPDATE의 잠금 방식</strong></p>\n<p><br>\n<code class=\"language-text\">SELECT FOR UPDATE</code>는 <strong>쓰기 잠금(X Lock) + 갭 락</strong>을 모두 획득합니다:</p>\n<ul>\n<li>\n<p><strong>레코드 락 (X Lock)</strong>: 조회된 레코드에 쓰기 잠금</p>\n</li>\n<li>\n<p><strong>갭 락 (Gap Lock)</strong>: 레코드 사이 간격을 잠궈 <strong>INSERT 차단</strong></p>\n</li>\n</ul>\n<p>반면 일반 SELECT는 아무 잠금도 걸지 않아 언두 로그에서 스냅샷을 읽고, INSERT도 허용합니다.</p>\n</blockquote>\n<blockquote>\n<p><strong>일반 DBMS는 어떻게 동작하는가?</strong></p>\n<p><br>\n일반 DBMS에서는 갭 락 자체가 없어 <code class=\"language-text\">SELECT FOR UPDATE</code>를 처음부터 사용해도 범위 내 INSERT를 막지 못해 PHANTOM READ가 발생합니다.</p>\n</blockquote>\n<h3>SERIALIZABLE</h3>\n<p><strong>SERIALIZABLE</strong>은 가장 엄격한 트랜잭션 격리 수준입니다.</p>\n<p><strong>특징</strong></p>\n<ul>\n<li>가장 높은 데이터 일관성 보장</li>\n<li>트랜잭션들이 마치 <strong>순차적으로</strong>(serial) 실행되는 것처럼 처리</li>\n<li>여러 트랜잭션이 <strong>동일한 레코드에 동시에 접근하는 일이 차단</strong>됨</li>\n<li>데이터의 부정합이나 예기치 않은 읽기 문제는 발생하지 않음</li>\n<li><strong>병렬 실행이 제한</strong>되므로, <strong>동시 처리 성능은 크게 떨어질 수 있음</strong></li>\n</ul>\n<h4>SERIALIZABLE의 동작 방식</h4>\n<p><strong>일반 SELECT조차도 공유 잠금(Shared Lock)을 획득</strong></p>\n<ul>\n<li>Next-Key Lock을 통해 해당 범위의 삽입, 수정, 삭제를 차단</li>\n<li>한 트랜잭션에서 읽는 레코드를 다른 트랜잭션에서는 변경 불가능</li>\n<li>PHANTOM READ 완전 방지</li>\n</ul>\n<blockquote>\n<p><strong>InnoDB에서는 SERIALIZABLE이 불필요한 이유</strong></p>\n<p><br>\nInnoDB 스토리지 엔진에서는 <strong>갭 락</strong>과 <strong>넥스트 키 락</strong> 덕분에 REPEATABLE READ 격리 수준에서도 이미 PHANTOM READ가 발생하지 않기 때문에 굳이 SERIALIZABLE을 사용할 필요성은 없어 보입니다.</p>\n</blockquote>\n<p><strong>권장사항</strong></p>\n<ul>\n<li><strong>안정성이 최우선인 특수한 상황</strong>이 아닌 이상, <strong>일반적인 애플리케이션에서는 이 수준을 사용하지 않는 것이 바람직</strong>합니다.</li>\n<li>동시성이 중요한 데이터베이스에서는 거의 사용하지 않음</li>\n<li>성능 저하를 감수하고 최고 수준의 데이터 일관성이 필요한 경우에만 사용</li>\n<li>트랜잭션 간 충돌과 잠금 경합이 빈번해져 <strong>성능 저하가 크기 때문에</strong>, 일반적인 트랜잭션 처리에서는 신중하게 사용</li>\n</ul>","wordCount":{"words":2092},"frontmatter":{"title":"InnoDB 잠금 메커니즘","date":"October 06, 2025","description":"InnoDB의 레코드 락, 갭 락, 넥스트 키 락의 동작 원리와 인덱스와 잠금의 관계를 심층 분석합니다. 잠금 확인 및 해제 방법을 실제 예제와 함께 설명합니다."}},"previous":{"fields":{"slug":"/mysql-part4/"},"frontmatter":{"title":"MySQL 엔진 아키텍처"}},"next":{"fields":{"slug":"/webclient/"},"frontmatter":{"title":"Spring WebClient와 논블로킹 I/O"}}},"pageContext":{"id":"fc8dd2a7-221d-5fd5-8e50-688bc7c7a494","previousPostId":"0f5161ec-2733-56c1-b9de-d2120698a099","nextPostId":"5e194fa8-ede1-5b2d-8ed6-b59568133763"}},"staticQueryHashes":["3257411868","3517523002"],"slicesMap":{}}