{"componentChunkName":"component---src-templates-blog-post-js","path":"/TCP/","result":{"data":{"site":{"siteMetadata":{"title":"GoToBill"}},"markdownRemark":{"id":"2d2d4eb1-9394-5be7-b05a-2d63b09febde","excerpt":"네트워크 서버에는 2개의 공인 IP가 있었습니다: 인바운드 IP: 외부에서 서버로 들어올 때 쓰는 IP 아웃바운드 IP: 서버에서 외부로 나갈 때 쓰는 IP…","html":"<h2>네트워크</h2>\n<p>서버에는 2개의 공인 IP가 있었습니다:</p>\n<ul>\n<li><strong>인바운드 IP</strong>: 외부에서 서버로 들어올 때 쓰는 IP</li>\n<li><strong>아웃바운드 IP</strong>: 서버에서 외부로 나갈 때 쓰는 IP</li>\n</ul>\n<h2>노드, 네트워크, 라우터</h2>\n<p>데이터를 송수신하는 모든 장치를 <strong>노드</strong>라고 부릅니다. 우리가 쓰는 휴대폰, 노트북, 서버 장비 등이 모두 노드에 해당합니다. 이런 각 노드가 서로 데이터를 주고받기 위해 연결된 시스템을 <strong>네트워크</strong>라고 합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 326px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/bb40e9042d33fa7156d113367c4fd2fb/ce9b1/1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75.9493670886076%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAABlUlEQVR42qVUy4rCQBD0w/wxr4JnTwHFg1cRPAuKV0HworCKRqJGD74RTXyb2q2WljGr4rINTaZnaqqfk0gQBDgcDrhcLjifz9jv99jtdvI11dzTNfHU4/EoNrki+JFutwvLspDP52XzEz2dThiNRnAcB7PZTGyqEDabTTmoVqvwPA9hIYHK9XqVr+u6KBQKSCaTKBaLsvdAOJ1OUa/XsVqt8E6UnFlls1mkUinkcjkhY/pC2G63EY/Hkclk4Hu+KAEUOqCzxWIhNuvn+77YjUZDgiA5M2MfIkyBoMFggOVyKZd4QACbxTrxkm3bQqTFVxwbQuFXIuQmQeFaKYjeO52OEOplxSpeJ+UXoSmMnEBGNZ/P75GFnar9NMJnQqAZ2Tvcy5QZXb/fF2UNWeN/EY7HY1QqFZnNWCyGcrn8tMYfE67Xa6TTaZRKJUSjUSQSiXtX/0RokvZ6PdRqNenyZDJ5OQWbzebhbQuh1sh8qzrE2hDzTJ8f57b11cLQHWK73d4GmwDzT8J5Cq/1PHymE8A1lY6+AbtUfhM60tHPAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"네트워크 구조\"\n        title=\"\"\n        src=\"/static/bb40e9042d33fa7156d113367c4fd2fb/ce9b1/1.png\"\n        srcset=\"/static/bb40e9042d33fa7156d113367c4fd2fb/c26ae/1.png 158w,\n/static/bb40e9042d33fa7156d113367c4fd2fb/6bdcf/1.png 315w,\n/static/bb40e9042d33fa7156d113367c4fd2fb/ce9b1/1.png 326w\"\n        sizes=\"(max-width: 326px) 100vw, 326px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>패킷(Packet)</h3>\n<p>노드가 네트워크를 통해 전송하는 데이터의 단위를 패킷이라고 합니다. 패킷은 헤더와 페이로드로 구성됩니다:</p>\n<ul>\n<li><strong>헤더</strong>: 패킷의 발신자와 수신자 정보가 들어있습니다</li>\n<li><strong>페이로드</strong>: 실제 전송되는 데이터가 들어있습니다</li>\n</ul>\n<p>데이터는 일정 크기를 가진 여러 패킷으로 나뉘어 전송됩니다.</p>\n<p>네트워크의 예로 집에서 쓰는 공유기에 연결된 장치들을 들 수 있습니다. 공유기에 연결된 휴대폰이나 컴퓨터가 하나의 네트워크를 구성하죠. 마찬가지로 사무실에서 사용하는 컴퓨터들도 하나의 네트워크를 구성합니다.</p>\n<p>서로 다른 네트워크에 속한 노드는 직접 연결해서 패킷을 송수신할 수 없습니다.</p>\n<p>이때 사용되는 것이 <strong>라우터</strong>입니다. 라우터는 네트워크 간에 패킷을 전송하는 역할을 합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 452px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ff661b761b1304066995c38c7f19de5a/fcb94/2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 20.253164556962027%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA1klEQVR42mWQ206DQBCGeSLqBfb9Q7g2mmJRRIlE3Q0Q7C5YTmU/OxiunMkm/2y+OXrGGJIkoe975nlmmibGccRdfXEL7vrERC/LnxZOeOFEW2uROpLrpWlKGIbUdU3TNGRZxjiMtD+W58+Yonxb4/fqlaePA925oz6VPBb31G2JVprdzQ7f91FK4UmBKIqoqmr9kAZd12Hab47FA7nO6M89uXpZY9saykZzyO8oTwr1pdjvbwmCAK01nowaxzHDMKwjbytv5pz7py/zZWWElZXlFNu5fgF70Sc47UttLAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"라우터를 통한 네트워크 연결\"\n        title=\"\"\n        src=\"/static/ff661b761b1304066995c38c7f19de5a/fcb94/2.png\"\n        srcset=\"/static/ff661b761b1304066995c38c7f19de5a/c26ae/2.png 158w,\n/static/ff661b761b1304066995c38c7f19de5a/6bdcf/2.png 315w,\n/static/ff661b761b1304066995c38c7f19de5a/fcb94/2.png 452w\"\n        sizes=\"(max-width: 452px) 100vw, 452px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>도메인과 IP 주소</h2>\n<p>각 노드의 IP 주소를 외우기는 쉽지 않습니다. 그래서 IP 주소에 기억하기 쉬운 이름을 붙이는데, 그게 바로 <strong>도메인 이름</strong>입니다. 도메인 이름을 IP 주소로 변환하는 체계가 <strong>DNS</strong>입니다.</p>\n<p>DNS를 인터넷 전화번호부라고 생각하시면 됩니다.</p>\n<p><strong>도메인 이름은 계층 구조를 갖습니다. 각 계층은 점(.)으로 구분되며, 오른쪽이 상위 계층이고 왼쪽이 하위 계층입니다.</strong></p>\n<h3>도메인 계층 구조</h3>\n<p>가장 오른쪽이 <strong>최상위 계층</strong>입니다. 최상위 계층에는 두 가지 종류가 있습니다:</p>\n<ul>\n<li><strong>일반 최상위 도메인</strong>: com, org, net, gov, app, biz, tech 등</li>\n<li><strong>국가 최상위 도메인</strong>: kr, jp, au, cn 등</li>\n</ul>\n<h4>일반 최상위 도메인 (예: .com)</h4>\n<ul>\n<li><strong>2차 도메인이 주요 이름이 됩니다</strong> (회사나 브랜드 이름)</li>\n<li>예: naver.com → naver가 2차 도메인</li>\n<li>3차부터는 용도별로 사용: cafe.naver.com, <a href=\"http://www.google.com\">www.google.com</a></li>\n</ul>\n<h4>국가 최상위 도메인 (예: .kr)</h4>\n<ul>\n<li><strong>2차 계층</strong>까지 미리 정의되어 있습니다\n<ul>\n<li>ac.kr: 대학 등 교육 기관용</li>\n<li>co.kr: 기업용</li>\n<li>go.kr: 정부 기관용</li>\n</ul>\n</li>\n<li><strong>3차 계층이 주요 이름이 됩니다</strong></li>\n<li>예: gasapp.co.kr → gasapp이 주요 이름</li>\n</ul>\n<h3>DNS 작동 방식</h3>\n<p>도메인 이름에 해당하는 IP 주소는 DNS 서버를 통해 알아냅니다.</p>\n<h4>간단한 설명</h4>\n<p><a href=\"http://www.naver.com%EC%9D%84\">www.naver.com을</a> 브라우저에 입력하면, 브라우저가 DNS 서버한테 \"<a href=\"http://www.naver.com%EC%9D%98\">www.naver.com의</a> IP 주소가 뭐예요?\"라고 물어봅니다. DNS 서버는 해당 IP 주소를 알려주고, 브라우저는 그 IP 주소로 데이터를 보냅니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. www.naver.com의 IP 주소 요청\n2. 223.130.192.248 응답\n3. 데이터 전송</code></pre></div>\n<h4>실제 DNS 조회 과정 (상세)</h4>\n<p>실제로는 여러 DNS 서버를 거쳐가며 IP 주소를 찾습니다. <strong>구글</strong>에 접속하는 과정을 예로 들어보겠습니다:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 482px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/a582629e39a7beedfb929d27de7ec9c4/37e0d/3.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 201.8987341772152%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEXElEQVR42p1XaXfiRhAk6wNzSUInutGJACFO23iTteO3m+Qlb///36l0j4FgO7aRP/Sb0SCVqrv6EA0vGuGlBVmFYLSEl83h5wv4tB7vA1qDfI7/e7bx7GCYI0hLaMEMPdWF5Y+gWENoTgLTz6HaCXQnhWKGUL0SfjKh5/K3Ad1hhpDe3NUDXDUvkSQZ1L4Gz/EQRTEsawCX9rLUQ1t14KdTQeJthvQ2Px7DSdcwwhn0sBSrMZzBiiroQSnOeLWzDby4+MDlnfl0Y0DuBOlEvCAuKhSztQDgs6fz4oQYHsVyby5ZlJcYTVdiL2L2ws2PAY+YMqvLqx7OL1oESGfJGO898y4gM+prNmzHx8D2aD+AE2ZvuvuuyyHFqW84aLe7WCyvsdrcQlFU9BSDfpvu3K/JkN3t6zYkqY8eGTP0oqKey+wOGzNIRjMkxRytbl/EMabrbDIXv+3v+xCQYzTwU4TZlMBm4uF9Crn0e0yKs+oDPxH2DmABh1ScVmvMlxtUFDf3DaGWFM/F6hrr6+0rlv8BDlO6OUUxmWG5XNFaijNh+3qlJA8obSazJba/3mNz8/UpyY9SqbFn5482VE4rUWZJ9ZvY2yl1nNFGAPF9lhtDM6mWNQcOhUXVXXFt2uGBaYNTxKcO0xk9Qhk/YLD4E/byL7HydSu9p5et4BNLFqYnKUhSEi+IEA4TqJqJxi+XokSfATbTB8jFPZz13zCqH/A3/6A/fcRF9A1BQSypE111ZBiGjSgmocJYmE7XX86bRwx3+eaOtzDTaxjUaUzqJGa6EatTbOGRyj7dp5k+FNWCZrjQTTLLE5WkqIMjhgdRMgQRW75bqcTY6HwvCgsS7kTg7jOk1OKz4LUoH5u/qxDLi2HYQ2TjCjbloelGz8rwJEB+gBNdJtdkRadmEcBxQ2oYvriWFPNFDE8AHGYlupKOTkdCnk8wLeeYTCtopPJVWzm4fTpDip1KOXfZ7JIojhDFoOt2VxHMX4tyonGT5RpmRk6QUe3nzzpQLUBmybFkNuXyFhF1H1acz2oDMiOFcq5Fyd2TdQycUOSk3Dcptpp4GadXDcAJBV+GJKskxhyjYirMptFwdn61Y5nXY9imRntx2aJaLmANPIRhgm5PxpczBizrAYouTgJYlMj6IBSCmE4kzKbO4yefUJlBudw4XiwKjwTeixzcVUstQE4RlRqDTMPKDVJou+Zg075WpexjqFk+ms0O0qwQvZB7YqvVFYm9H62nx5AAOXZfzi6R5WPko4kAbjTOxfxm12sB7iei1LcgESN2ndeebIiu88nSK5DTXC7KBWY0FafVij6iFgewmv2QGPoxylmF7e0Nvt7dkW2xXtN4CJNPAHIeFjfQaUwo4QLR4lHs1XhN4+Pu0CBOb1/5DN3sHp38HuHNT1g0FYPbn5Anv6OVfyfRnj6Pa/TDEsroAd38G8zqD2jld7FKxQOk8Y/DB3y9SqG/FE62gJ1UB3NS/ruxPMTwXzqpUAzdL4adAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"머메이드\"\n        title=\"\"\n        src=\"/static/a582629e39a7beedfb929d27de7ec9c4/37e0d/3.png\"\n        srcset=\"/static/a582629e39a7beedfb929d27de7ec9c4/c26ae/3.png 158w,\n/static/a582629e39a7beedfb929d27de7ec9c4/6bdcf/3.png 315w,\n/static/a582629e39a7beedfb929d27de7ec9c4/37e0d/3.png 482w\"\n        sizes=\"(max-width: 482px) 100vw, 482px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>이 과정이 복잡해 보이지만 실제로는 1초도 안 걸립니다. 한 번 조회한 결과는 캐시에 저장되어 다음에 더 빠르게 접속할 수 있습니다.</p>\n<p>로컬에서 개발할 때 쓰는 localhost는 특별한 주소입니다. localhost의 IP 주소는 127.0.0.1입니다.</p>\n<p>이건 <strong>루프백 주소</strong>라고 해서 자기 자신을 가리킬 때 쓰는 IP 주소입니다.</p>\n<h3>hosts 파일</h3>\n<p>모든 컴퓨터는 hosts 파일을 가지고 있습니다:</p>\n<ul>\n<li><strong>리눅스</strong>: <code class=\"language-text\">/etc</code> 디렉토리에 있습니다</li>\n<li><strong>윈도우</strong>: <code class=\"language-text\">C:\\Windows\\System32\\drivers\\etc</code> 디렉토리에 있습니다</li>\n</ul>\n<h3>도메인 이름과 IP 주소 개수</h3>\n<p>하나의 도메인에 여러 IP 주소가 매핑될 수 있습니다. nslookup 명령어로 확인해볼 수 있습니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">nslookup</span> www.naver.com\n<span class=\"token punctuation\">..</span>.\nAddress: <span class=\"token number\">223.130</span>.192.248\nAddress: <span class=\"token number\">223.130</span>.192.247\nAddress: <span class=\"token number\">223.130</span>.200.219\nAddress: <span class=\"token number\">223.130</span>.200.236</code></pre></div>\n<p>한 도메인에 IP 주소를 여러 개 매핑하는 이유 중 하나는 <strong>부하 분산</strong> 때문입니다.</p>\n<h2>고정 IP와 동적 IP</h2>\n<p>같은 네트워크에서 각 노드는 서로 다른 IP 주소를 가져야 합니다. IP 주소로 패킷을 보낼 노드를 구분하기 때문에, 같은 IP 주소를 가진 노드가 있으면 IP 충돌이 일어납니다.</p>\n<p>노드의 IP 주소는 2가지 방식으로 지정합니다:</p>\n<ul>\n<li><strong>고정 IP</strong>: 노드가 고정된 IP를 갖습니다. 서버 IP가 대표적이죠.</li>\n<li><strong>동적 IP</strong>: 노드가 네트워크에 연결할 때마다 IP를 할당받습니다. DHCP(Dynamic Host Configuration Protocol) 서버가 이걸 담당합니다.</li>\n</ul>\n<h2>DHCP 서버</h2>\n<h4>DHCP 동작 과정 (DORA)</h4>\n<p>DHCP는 <strong>브로드캐스팅</strong>을 통해 IP를 할당받습니다. 이 과정을 <strong>DORA</strong>라고 부르는데, 각 단계의 앞글자를 딴 것입니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">D - Discover (발견)\nO - Offer (제안)\nR - Request (요청)\nA - Acknowledgment (확인)</code></pre></div>\n<h4>상세한 DHCP 과정</h4>\n<p>노트북을 WiFi에 연결하는 상황을 예로 들어보겠습니다:</p>\n<p><strong>① DHCP Discover - \"DHCP 서버 어디있어요?\"</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">노트북: \"저 IP가 없는데 누가 좀 줘요!\" (브로드캐스트)\n발신: 0.0.0.0 (아직 IP가 없음)\n수신: 255.255.255.255 (네트워크 전체에 외침)</code></pre></div>\n<p><strong>② DHCP Offer - \"내가 줄 수 있어\"</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">공유기(DHCP 서버): \"192.168.0.105 쓸래?\"\n제안 내용:\n- IP 주소: 192.168.0.105\n- 서브넷 마스크: 255.255.255.0\n- 게이트웨이: 192.168.0.1\n- DNS: 8.8.8.8\n- 임대 시간: 24시간</code></pre></div>\n<p><strong>③ DHCP Request - \"그거 주세요!\"</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">노트북: \"네, 192.168.0.105 주세요!\" (브로드캐스트)\n→ 여러 DHCP 서버가 있을 수 있어서 가장 먼저 응답을 주는 DHCP 서버를 선택\n→ 브로드 캐스팅으로 알림\n\n메시지 내용:\n- Transaction ID: 이전 DHCP 메시지와 동일한 ID\n- DHCP Message Type: REQUEST\n- Requested IP Address (Option 50): 192.168.0.105\n- DHCP Server Identifier (Option 54): 선택한 서버의 IP</code></pre></div>\n<p><strong>④ DHCP ACK - \"자, 여기 있어\"</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">공유기: \"확인! 192.168.0.105는 24시간 동안 네 거야\"\n→ 이제 노트북은 정식으로 IP를 받음</code></pre></div>\n<h4>브로드캐스팅이란?</h4>\n<p>브로드캐스팅은 네트워크의 모든 기기에게 동시에 메시지를 보내는 방식입니다:</p>\n<ul>\n<li><strong>유니캐스트</strong>: 1:1 통신 (특정 IP로 전송)</li>\n<li><strong>브로드캐스트</strong>: 1:전체 통신 (255.255.255.255로 전송)</li>\n<li><strong>멀티캐스트</strong>: 1:그룹 통신 (특정 그룹에만 전송)</li>\n<li><strong>애니캐스트</strong>: 1:가장 가까운 1개 (같은 IP를 가진 여러 서버 중 가장 가까운 곳으로)</li>\n</ul>\n<p><strong>애니캐스트 예시:</strong>\nCDN이나 DNS 루트 서버가 애니캐스트를 사용합니다. 예를 들어 구글 DNS(8.8.8.8)는 전 세계에 수백 개 서버가 있는데, 모두 같은 IP를 갖습니다. 한국에서 8.8.8.8에 접속하면 한국에서 가장 가까운 서버로 자동 연결됩니다.</p>\n<p>DHCP가 브로드캐스트를 쓰는 이유는 간단합니다. <strong>아직 IP가 없는 기기는 DHCP 서버가 어디 있는지 모르기 때문입니다</strong>. 그래서 \"야! 다들 들어봐! 나 IP 필요해!\"라고 네트워크 전체에 외치는 거죠.</p>\n<h4>IP 임대 시간과 갱신</h4>\n<p>DHCP로 받은 IP는 영구적이지 않습니다:</p>\n<ol>\n<li><strong>임대 시간</strong>: 보통 24시간 (설정 가능)</li>\n<li><strong>50% 시점</strong>: 12시간 지나면 갱신 시도</li>\n<li><strong>87.5% 시점</strong>: 갱신 실패 시 다시 시도</li>\n<li><strong>만료</strong>: 새로 DHCP Discover부터 다시 시작</li>\n</ol>\n<p>이렇게 임대 방식을 쓰는 이유는 한정된 IP 주소를 효율적으로 관리하기 위해서입니다.</p>\n<h2>공인 IP와 사설 IP</h2>\n<p>웹 브라우저에 <a href=\"http://www.google.com%EC%9D%B4%EB%82%98\">www.google.com이나</a> <a href=\"http://www.daum.net\">www.daum.net</a> 같은 도메인을 입력하면 DNS 서버에서 IP 주소를 받아와서 접속합니다. 이때 사용하는 IP 주소는 인터넷 어디서든 접근 가능한 <strong>공인(public) IP</strong> 주소입니다.</p>\n<p>모든 네트워크에서 쓸 수 있는 공인 IP와 달리, 네트워크 내부에서만 쓰는 <strong>사설(private) IP</strong> 주소도 있습니다. 사설 IP는 특정 네트워크 안에서만 유효하고 외부에서는 접근할 수 없습니다.</p>\n<p>사설 IP로 쓸 수 있는 주소 범위입니다:</p>\n<ul>\n<li><strong>192.168.x.x</strong></li>\n<li><strong>10.x.x.x</strong></li>\n<li><strong>172.16.x.x ~ 172.31.x.x</strong></li>\n</ul>\n<h3>공인 IP 알아내기</h3>\n<p>간단한 방법은 <a href=\"https://ifconfig.me\">https://ifconfig.me</a> 같은 사이트에 접속해서 확인하는 겁니다.</p>\n<p>리눅스에서도 아래 명령어로 공인 IP 주소를 확인할 수 있습니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> ifconfig.me</code></pre></div>\n<h2>NAT</h2>\n<p><strong>NAT</strong>(Network Address Translation, 네트워크 주소 변환)는 네트워크 주소를 변환하는 기술입니다. 인터넷에 연결하려면 내부의 사설 IP와 인터넷의 공인 IP 간 변환이 필요한데, NAT가 이걸 처리합니다.</p>\n<ul>\n<li><strong>SNAT(Source NAT)</strong>: 나가는 패킷의 출발지 변경 (AWS NAT Gateway)</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 546px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/188f0abb2526b60722a87f39da470064/76aed/4.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 20.253164556962027%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAArklEQVR42n1PSwqFMAzs/W/iPYQiupVurYiKFrX+6n8kActbvcDQpDNJJkJKiSAIcF0XfuM8TyzLwu+/IH7fd9z3zbVQSiGKIgzDgHVdMc8zoyxLxHEMYww30HDnnMc4jpimibVt26LvezYlwjBkh9ZaHpLnObquQ13XSNOUc2rSWqNpGlRVxRrS0iLi6I8WbNsGkWUZkiRhu8/zeOvkoigKf/LHESj/cByHP5vqF1oVMOfdhmVmAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"snat\"\n        title=\"\"\n        src=\"/static/188f0abb2526b60722a87f39da470064/76aed/4.png\"\n        srcset=\"/static/188f0abb2526b60722a87f39da470064/c26ae/4.png 158w,\n/static/188f0abb2526b60722a87f39da470064/6bdcf/4.png 315w,\n/static/188f0abb2526b60722a87f39da470064/76aed/4.png 546w\"\n        sizes=\"(max-width: 546px) 100vw, 546px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li><strong>DNAT(Destination NAT)</strong>: 들어오는 패킷의 목적지 변경 (AWS ALB/NLB)</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 585px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/a4481de1170d3cb90af544093f05083a/78a22/5.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 22.78481012658228%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABD0lEQVR42m2QO0vDYBSG8y/FzcnB0sWli876A6qT4g2hZlAkBLEQbAdBx1iNRggkqIm532+E5LXfgXZQH3j5DnzwnJfDFUWBqqrA6Lpumd/UdQ3P8yi6rsP8svDwMcVIOcCtdo2rt3NcqmfgBEGAJEl/JGxJkiQIwxBZlpGwaRqaXc9F7McYPu5iY7yC7Wkfg7t19Mar4DRNg6qqsG0bQRAgiiLEcUwi13UhyzKJ0zQlaZ7nJGZ8p59QXBnvvgLVf6ZwPM9DFEXabFkWSVg7dgomNwyD5rIs0bbtMozT2T7681Y79wNsTXrYlNbAmaYJx3HwH2wJ+1s0WjC/Mr0T4wbHT0OMXg5x8XqEk9kefgCC/Wt7WiNwEgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"snat\"\n        title=\"\"\n        src=\"/static/a4481de1170d3cb90af544093f05083a/78a22/5.png\"\n        srcset=\"/static/a4481de1170d3cb90af544093f05083a/c26ae/5.png 158w,\n/static/a4481de1170d3cb90af544093f05083a/6bdcf/5.png 315w,\n/static/a4481de1170d3cb90af544093f05083a/78a22/5.png 585w\"\n        sizes=\"(max-width: 585px) 100vw, 585px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>DNAT는 서버 구성할 때 많이 씁니다. 보통 보안이나 이중화를 위해 서버는 사설 IP를 쓰고, 공인 IP는 라우터나 방화벽 같은 네트워크 장비에 할당합니다.</p>\n<h2>VPN</h2>\n<p>백엔드 서버를 개발하고 운영하다 보면 서버나 DB에 접속할 일이 많습니다. SSH로 서버에 접속해서 프로세스를 확인하거나 OS 설정을 바꿔야 할 때도 있고, DB에 접속해서 SQL을 실행해야 할 때도 있죠.</p>\n<p>서버 네트워크의 노드에 안전하게 접근하려면 <strong>VPN</strong>(Virtual Private Network, 가상 사설 네트워크)을 사용합니다. VPN은 인터넷 같은 공용 네트워크에서 서로 다른 네트워크 간에 암호화된 연결을 제공합니다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1a31889900d9f6791e839395c7e1c624/084e2/6.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36.075949367088604%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABbklEQVR42pWRzU/bQBDF898iOCCOqEVCOfeAeoRDb0gVl0oETkCBEFBBlUyRFSikxCSQKCTGGyfO2t71/vCazwOXjjSat6vRm3lvSsYYXjLLMrJn/FHY/yRJMNpwJ9octnZxOscc5bXR/0umMkpKKXq9Ho1GAxEIxpMRnf4tD0MfOZFIKYnjmCiKCEKfrn+HSQ1Vb4v5vSmWTsp82p/mx8UqZFCykx3HYXNzg+t/TUIpODzb5bzp4jU96vU6rptj74aLG5eD023EUPD79ogvvz7zzfma1wW2ritPhFprWq0W1WoVIUQuW+MHAyYywm4fhiFBEGD7ZDzBHw5AQc3bYfFglqXjMuXaHJXLtSdC69t4PC5kt9ttup0uWulXX9/7Z3tTlRbvmvezkGolL+zPULlae5NsG+02NgsyLNHbsV6IjclyP2WB6/0/rLrLrF9+z+tKcRj0M+H/hB2apgkjMaLfHdDr3BNHCTrVKK14BN1nBmPVDY7wAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"snat\"\n        title=\"\"\n        src=\"/static/1a31889900d9f6791e839395c7e1c624/f058b/6.png\"\n        srcset=\"/static/1a31889900d9f6791e839395c7e1c624/c26ae/6.png 158w,\n/static/1a31889900d9f6791e839395c7e1c624/6bdcf/6.png 315w,\n/static/1a31889900d9f6791e839395c7e1c624/f058b/6.png 630w,\n/static/1a31889900d9f6791e839395c7e1c624/084e2/6.png 632w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>개발자는 VPN 클라이언트로 VPN에 접속할 수 있습니다. 집이나 카페에서 서버 네트워크에 접근해야 할 때 이 방식을 씁니다.</p>\n<h2>프로토콜과 TCP, UDP, QUIC</h2>\n<p>네트워크에서 두 노드가 데이터를 주고받기 위해 정한 규칙을 <strong>프로토콜</strong>(protocol)이라고 합니다. 네트워크는 여러 계층으로 구성되고 각 계층마다 사용하는 프로토콜이 있습니다.</p>\n<p><strong>TCP/IP 모델의 계층별 프로토콜</strong>:</p>\n<ul>\n<li>애플리케이션 계층: HTTP, FTP, SMTP</li>\n<li>전송 계층: TCP, UDP</li>\n<li>네트워크 계층: IP</li>\n</ul>\n<h3>TCP (Transmission Control Protocol)</h3>\n<p>TCP는 연결 기반 프로토콜입니다. 전화 통화처럼 먼저 연결을 맺고 나서 데이터를 주고받습니다. TCP에서 두 노드가 연결을 맺는 과정을 <strong>3-Way Handshake</strong>라고 부릅니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 288px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/cb29290e24696aca7edccfca61f34e87/477c9/7.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 101.26582278481011%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAABq0lEQVR42pWUaavCMBBF/f8/SEFQUUE/+EXrgoIK7rjv+zKPM5CSatOngdCSSU7u3BkS22w2UqlUpN1uS6fTkapXleVyKYzX6yVRg33NZlMOh4O/P7ZarcTzPBmPxzIajRS83+8DB9kYBl+v19Lr9YJAs3GxWEir1dL/5/MZgLnG8XiURqMR2OcD+/2+JJNJhXGjWecQMdsGE0NhJpMJiPCBg8FACoWC/m+3W8EKvlhRr9dlOp1+KMb/XC7nBhaLxUCQ7+l0kvP5rHBU4i+qjcJsNhsOJC0DfDweoZ6xlwuwxPiXSqXcQJMyQdYp1GQyUQBqUGgO3m436Xa7bg/fgUzaiPXZbKYdUC6X9RL8vVwu6mtkygZ4v981bQ6RGubzNet2UZxAipJIJOR6vWpqpAgEqKsXI4EojMfjkUX5GZhOpzWAKkxnUFVi+GYX7CtgPp/3+4u52+10nQeAav+s8L2xKQITlTQ0l9DgxldUf93YYYVgHSuA0pu1Wi26sd8V/vd8zedzt0LeNbuxo4b92jiBw+FQSqXSV0D7gf0AmiDmY/YvgzNU2n5g/wCoNQWFHlgvlQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"3handshake\"\n        title=\"\"\n        src=\"/static/cb29290e24696aca7edccfca61f34e87/477c9/7.png\"\n        srcset=\"/static/cb29290e24696aca7edccfca61f34e87/c26ae/7.png 158w,\n/static/cb29290e24696aca7edccfca61f34e87/477c9/7.png 288w\"\n        sizes=\"(max-width: 288px) 100vw, 288px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">클라이언트 → 서버: SYN (Seq=1000)\n서버 → 클라이언트: SYN-ACK (Seq=3000, Ack=1001)\n클라이언트 → 서버: ACK (Seq=1001, Ack=3001)</code></pre></div>\n<p><strong>Seq와 Ack가 뭔가요?</strong></p>\n<ul>\n<li><strong>Seq(Sequence Number)</strong>: \"내가 보내는 데이터의 번호\"</li>\n<li><strong>Ack(Acknowledgment Number)</strong>: \"다음에 받고 싶은 상대방 데이터의 번호\"</li>\n</ul>\n<p>예를 들어 서버가 <code class=\"language-text\">Ack=1001</code>을 보내면 \"클라이언트님, 1000번까지 잘 받았고 이제 1001번 주세요\"라는 의미입니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b2b62ce43413961e186c907eaabc0bb5/e51a6/8.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 58.86075949367089%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAPoAAAD6AG1e1JrAAABOUlEQVR42nWSO0/EMBCE7/+XlPwACgoKGiQKaJGQ6GhoqMiLKE6c+JnH8fmSs0w4rMTZjHdmZ20fjucxjVPXdc654z9jWZa2bb33ETnwDtqzYIxRSmmtQbyfslLEJBKY0UV9JYtO8QTyw1tZVG1a5P0ju7q+iwVvnj7xlSbc3r88Pr8GMtWstcxCiKqqkOcXIzG173sQKSUJZVlikFWMBDKRnxbrx6+8lIMiZpAdyUY7wF6ZrKi0pacFkIQzeXbWm7zKhRTjMlrv1uY3slGAvZbFd8FMrJ3dyKntuq5X27/Ip8qYojIGV/ACOfackrUesCZVt1YOvmJlPgi7caJnrWwU3m0YM+eMNQKktw1j4dRn6LluGlTDk1T+e3M47XmeA5mtj7abpkF+Zzt1EeU4kcNF4R2YXskU+QFmPrlMmnHaUgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"3handshake\"\n        title=\"\"\n        src=\"/static/b2b62ce43413961e186c907eaabc0bb5/f058b/8.png\"\n        srcset=\"/static/b2b62ce43413961e186c907eaabc0bb5/c26ae/8.png 158w,\n/static/b2b62ce43413961e186c907eaabc0bb5/6bdcf/8.png 315w,\n/static/b2b62ce43413961e186c907eaabc0bb5/f058b/8.png 630w,\n/static/b2b62ce43413961e186c907eaabc0bb5/e51a6/8.png 783w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>HTTP/1.0</strong>: 매 요청마다 새로운 TCP 연결을 맺어야 했습니다 (Connection: close가 기본값)</p>\n<p><strong>HTTP/1.1</strong>: <strong>Keep-Alive</strong>로 하나의 TCP 연결을 재사용할 수 있게 되었습니다 (Connection: keep-alive가 기본값)</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d835a9de463d539b677b5f425319b517/4ff83/9.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70.88607594936708%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC80lEQVR42nVT7UtTURh/pm6uzTXnptO0uc05w2KmVzOxvJR7ueqducEg0BD6MKms8A03W50PGUzUypDKNLRSkQmWEZElXqfLCGYYmFIhfZD+jtt92co5euDynHvOc37Py+93AKKGI7HQjkyiGmQES89xMPvyoRbxHkAQieK8mEQaqEGlYPUYwOorEtl8BQC0AGKsEImg7IoSKjoywIoMYO7WwCmPnvv2G+aWcGA2pIUznXlQfl0LrkAi7M3aNRaSETefjbY+mNdFD6ZDW49nNna97Jqi6CTWXxx4VWzrmRhDFMX9uxASTa59fze5vuvkLiGaTmD9RPBr1a3p5VDLvZfaKODMyrf50dWfPCDNAz5aWG/xPl96y0BxFXkeTimmVre+jHzcqYupUGH2y7nZAEqItCXkWlHWy/bGqS0oA872ZP9tv75LBsWXcwGIZH5jhLm4eV8Dy3350DZoALQpguZxMSCmpQaPEpo6pFwcxextP9LCh7t6aH9iBJyp2B0WskdSu1eNud1CHpBm2PkxlAz+brnE0Ztlta6lYY5gViW5qjGQczhHAGuBQGLur3Fx+jBKkTtelMgbgyWp5xdNxY4V4nDD7Lk44gDHkzB85IgfC2vCWWEJDUz2Oo8CSCTZ2zLQIGgtnXOismBVR/kS1mheqdbbZ53xgC5GNnW92TC4dgAuvVFkO6gcVcMUFq3wN+NpQ2fehqnd2IaNnggVbMteY2E+GdMyN/NYbWFC/OSw4X3B+qEBjFIFsB15afVTfbRCmhEuzRDWZOmQphDe9Mi8BP8HLHSJgPRr4MJnJTRTqcDqzjGUwwhcHjsaJAaWaV50vCJqUSaQkVmzWWl9t3zx2DW1/XS/LoBvpjRVLGQ4zZ/yjfaZSrD5jsYBkkgVA0jcyIs8UUYNgJLo3M7MoKlV56gcLJor21KiwoCIPZOwme131DGkWPqlQKAcHi8CaL+tg/o+2f73KQRrW1rMZQIdjGOZuJr8Ly4yQ7JdxVTOvaQ/bznqEwV5Wg0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"파이프라이닝\"\n        title=\"\"\n        src=\"/static/d835a9de463d539b677b5f425319b517/f058b/9.png\"\n        srcset=\"/static/d835a9de463d539b677b5f425319b517/c26ae/9.png 158w,\n/static/d835a9de463d539b677b5f425319b517/6bdcf/9.png 315w,\n/static/d835a9de463d539b677b5f425319b517/f058b/9.png 630w,\n/static/d835a9de463d539b677b5f425319b517/4ff83/9.png 843w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>파이프라이닝 없음</strong>: 요청을 보내고 응답을 받은 후에야 다음 요청을 보낼 수 있습니다</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> (요청-응답-요청-응답)</code></pre></div>\n<p><strong>파이프라이닝 있음</strong>: 응답을 기다리지 않고 여러 요청을 연속으로 보낼 수 있습니다</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(요청-요청-요청 → 응답-응답-응답)</code></pre></div>\n<p>그렇지만 파이프 라이닝은 일부 패킷이 유실되면 그 패킷이 도착할 때까지 이후 패킷을 처리하지 못하는 <strong>HOL 블로킹</strong>(Head-of-Line Blocking) 문제가 있습니다.</p>\n<h2>HTTP/2.0</h2>\n<h3>바이너리 프레이밍</h3>\n<p>HTTP/1.x는 Plain Text(평문)를 사용하고 개행으로 구별했지만, HTTP/2.0에서는 <strong>바이너리 포맷</strong>으로 인코딩된 Message, Frame으로 구성됩니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ca41c32e632a7d7081411873edec7de2/33e10/10.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.26582278481012%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAPoAAAD6AG1e1JrAAABeElEQVR42nWSbW+CMBRG/f+/QedkIRFkb06NsinC2AYWrOI0qCBFMaB+UBeX6D7MXYEQE7OTJzftbU/apE1JHFu5vuJzuXI2I+bzgUPW6/U2hBDiuu72H3zfT+HqHXqitNJN6zHXe2adQd+27WMIQohhGI7joBYKhWaz+RaCdRVWN5tNSpfqQ100sTTQm5+txtwl0I1kVVXT6TRFUTRNQy0Wi5IkaZqG0fvvfnuSMcbtEDgH6mKxSGTYBxrLsmDyPC/LsqIo0OzqrViufhh1fZRkMp1H8u7wjdp6JQQurJ1hGMbvz+4kl5DFSP0cj+h6u4w9y1smsud54/HYu2C1WsUy99G41UQIo77ct+XhjCSyO8LTnrCyFNIRJl1hMXqHMWRJBrFc7skPXYF+LRY0vmaptu8m8sxUAqMMQZWMXs1inoqmBNdiGV5sc8bhcIjkr/3ONeW9I0Ic5a4v0n6nFE2Xdit+quMF0I2+wcyxiNm5zHRiwmoQBH+BSft2wJ+BfgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"HTTP/2 바이너리 프레이밍\"\n        title=\"\"\n        src=\"/static/ca41c32e632a7d7081411873edec7de2/f058b/10.png\"\n        srcset=\"/static/ca41c32e632a7d7081411873edec7de2/c26ae/10.png 158w,\n/static/ca41c32e632a7d7081411873edec7de2/6bdcf/10.png 315w,\n/static/ca41c32e632a7d7081411873edec7de2/f058b/10.png 630w,\n/static/ca41c32e632a7d7081411873edec7de2/33e10/10.png 844w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>HTTP/2의 구성 요소:</strong></p>\n<ul>\n<li><strong>Stream</strong>: 구성된 연결 내에서 전달되는 바이트의 양방향 흐름, 하나 이상의 메시지가 전달 가능합니다</li>\n<li><strong>Message</strong>: 논리적 요청 또는 응답 메시지에 매핑되는 프레임의 전체 시퀀스입니다</li>\n<li><strong>Frame</strong>: HTTP/2에서 통신의 최소 단위. 각 최소 단위에는 하나의 프레임 헤더가 포함됩니다. 이 프레임 헤더는 최소한으로 프레임이 속하는 스트림을 식별합니다. <strong>HEADERS Type Frame, DATA Type Frame</strong>이 존재합니다</li>\n</ul>\n<p><img src=\"/15.gif\" alt=\"HTTP/2 멀티플렉싱 애니메이션\"></p>\n<p>위처럼, 하나의 커넥션에서 여러 병렬 스트림(3개)이 동시에 존재할 수 있습니다. 각 스트림의 프레임들이 뒤섞여서 전송되더라도, Stream Number를 통해 어떤 스트림에 속하는지 식별하여 정확하게 재조립됩니다.</p>\n<h3>HTTP/2의 한계: TCP HOL 블로킹</h3>\n<p>HTTP/2는 응용 계층에서의 HOL 블로킹을 해결했지만, <strong>TCP 레벨에서는 여전히 문제가 있습니다</strong>.</p>\n<p><strong>계층별 동작 이해:</strong></p>\n<p>네트워크는 계층으로 나뉘어 동작합니다:</p>\n<ul>\n<li><strong>응용 계층 (HTTP/2)</strong>: 프레임과 스트림으로 멀티플렉싱 구현</li>\n<li><strong>전송 계층 (TCP)</strong>: 순서를 보장하는 바이트 스트림 전송</li>\n</ul>\n<p>HTTP/2의 모든 스트림은 결국 <strong>하나의 TCP 연결</strong>을 통해 전송됩니다. TCP는 HTTP/2의 스트림 개념을 모르고, 단지 순서대로 바이트를 전달할 뿐입니다.</p>\n<p><strong>실제 예시: 10MB 이미지 + 1KB CSS 파일 요청</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">HTTP/1.1 (순차 처리):\n1. 10MB 이미지 요청 → 완료 (10초)\n2. 1KB CSS 요청 → 완료 (0.1초)\n총 시간: 10.1초\n\nHTTP/2 (멀티플렉싱):\n1. 10MB 이미지 + 1KB CSS 동시 요청 (프레임 교대로 전송)\n2. CSS는 1초 만에 완료 (이미지 중간에 끼워서 전송)\n3. 이미지는 10초 만에 완료\n총 시간: 10초 (CSS는 1초에 완료!)</code></pre></div>\n<p><img src=\"/16.gif\" alt=\"HTTP/2 한계\"></p>\n<p>HTTP/2는 하나의 TCP 연결만 사용하기 때문에, 패킷 하나만 유실되어도 <strong>모든 스트림이 영향을 받습니다</strong>. 오히려 HTTP/1.1이 여러 TCP 연결을 사용할 때보다 더 심각할 수 있죠.</p>\n<p><strong>TCP 패킷 손실 시나리오:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">TCP 패킷: [1][2][3][4][5][6][7][8][9][10]\n                ↑\n           3번 패킷 유실!\n\nTCP 패킷 손실 발생:\nHTTP/1.1: 모든 데이터 정지 \nHTTP/2: 모든 스트림 정지 \n\n결과: 패킷 4~10번이 도착해도 처리 못함\n→ TCP가 3번을 기다리느라 모든 HTTP/2 스트림이 멈춤</code></pre></div>\n<h3>Stream 우선순위</h3>\n<p><img src=\"/%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84.gif\" alt=\"우선순위\"></p>\n<p>HTTP 메시지가 많은 개별 프레임으로 분할될 수 있고 여러 스트림의 프레임을 다중화(Multiplexing)할 수 있게 되면서, <strong>스트림들의 우선순위를 지정할 필요가 생겼습니다.</strong></p>\n<p>클라이언트는 우선순위 지정을 위해 '우선순위 지정 트리'를 사용하여 서버의 스트림 처리 우선순위를 지정할 수 있습니다. <strong>서버는 우선순위가 높은 응답이 클라이언트에 우선적으로 전달될 수 있도록 대역폭을 설정합니다.</strong></p>\n<h3>HTTP 헤더 압축 (HPACK)</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/32365d82b3ad2829ce14a7bbe090d7e3/4ff83/12.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 83.54430379746836%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAPoAAAD6AG1e1JrAAACmUlEQVR42o2S60/aYBTG+38bF6Nyk4soVUAolksBC1haoBer406FgCAIODbnzGS4uJBliW5+2NwDOOe+6E7enLxpz+885/ISvV6v1WoNBoO7u7v7J/brj93c3DQajW63e3Fxcf+vERzHURRlMpkMBkOiqngz0YC6y9X2q9WqJEmapqXTaZZl19fXLRbL6uoq7rjAy7JMMAwD2G63G41Gpig4U0FKZcOlFKRA9vt9ZAkEAiRJOhwOq9WKYJvN5vP5ksnkBPZ4PPiq1+sBu0Rmkw8Brtfr2WwWBefz+RkMxmw2A4Oy1+t9gP1+P5Tn5uasYeeC22IObVijrk6nc3l5ORqNeJ4PhwI4JoNOv7ykW1pcXHhlWTFFIiFCEIRUKkXTNMrmT/JeOeKWwkInf3V19XNqo48ffpznv7/PVUUqGyebe4G3ldiRQtfzwkQZVaHm+fl5ktvW+dYMtGODp9EwRnJ4eAjlCBP0uF0rRj0EjbpleOgndxNEMBjcnJpOpwOzlthGCt9+rN1uFwoF+EqlgqE4nU60Bg1429QmPauqirnPZk6GqbiaThYkuZYbDoffpoZXgLh4PI4YrBM+FothweVymXjc+NnZWTQavX/WsC2k+/tIsEm012w2sU9sBTrIcnt7+xiBF1adGuavKAoawWX22ghVO45IRXdEYMTcVjQl105xxGp/PB7P4OHoc0brucI8u6dRMXFHqcx86ahH4Adz0LJHRFqp2UPpeKkvt0fS8SesagZ/GX+tnbzL1dra8Ztysw+m2OhWWqcng/MJjGiQSOHiciS75xVK4WzzEX7GHmBfuhKQax6+CB7iT5VfgIXGORjwKBtH74mKreF/wTuZ1042Y/PFKO7AEUzibCVUNnt0fX39IvwblxYUZWSHwBIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"HTTP 헤더 압축\"\n        title=\"\"\n        src=\"/static/32365d82b3ad2829ce14a7bbe090d7e3/f058b/12.png\"\n        srcset=\"/static/32365d82b3ad2829ce14a7bbe090d7e3/c26ae/12.png 158w,\n/static/32365d82b3ad2829ce14a7bbe090d7e3/6bdcf/12.png 315w,\n/static/32365d82b3ad2829ce14a7bbe090d7e3/f058b/12.png 630w,\n/static/32365d82b3ad2829ce14a7bbe090d7e3/4ff83/12.png 843w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>이전 Header의 내용과 중복되는 필드를 재전송하지 않도록 하여 데이터를 절약합니다. 기존에 HTTP Header가 Plain Text(평문)이었지만, HTTP/2에서는 <strong>Huffman Coding</strong>을 사용하는 <strong>HPACK</strong>이라는 Header 압축방식을 이용하여 데이터 전송 효율을 높였습니다.</p>\n<p><strong>Huffman Coding</strong>: 데이터 문자의 빈도에 따라서 다른 길이의 부호를 사용하는 알고리즘</p>\n<p><strong>TCP의 장점은 신뢰성</strong>입니다. 패킷 순서를 보장하고 패킷이 유실되면 재전송해줘서 <strong>안정적으로 데이터를 전송할 수 있습니다.</strong> 그래서 <strong>HTTP, SMTP</strong> 같은 많은 프로토콜이 TCP를 기반으로 동작합니다.</p>\n<p>하지만 시퀀스 번호, 확인 응답, 재전송 같은 기능 때문에 <strong>UDP보다는 느립니다.</strong></p>\n<h3>UDP (User Datagram Protocol)</h3>\n<p>TCP와 달리 UDP는 연결 과정 없이 바로 데이터를 보냅니다. <strong>데이터가 제대로 전송됐는지도 모르고, 순서도 보장하지 않습니다.</strong></p>\n<p>UDP를 쓰는 애플리케이션은 데이터가 유실될 수 있다고 가정하고 개발해야 합니다.</p>\n<p>UDP는 응답 확인이나 패킷 정렬 같은 과정이 없어서 <strong>TCP보다 빠릅니다.</strong></p>\n<p>그래서 속도가 중요하거나 약간의 데이터 유실이 괜찮은 통신에 씁니다. <strong>DNS, VoIP, 게임 등이 UDP를 사용하는 대표적인 예입니다.</strong></p>\n<h3>QUIC</h3>\n<p>TCP는 신뢰성이 있지만 느립니다. UDP는 빠르지만 신뢰성이 없죠. 이 둘의 장점을 합친 프로토콜이 <strong>QUIC</strong>입니다.</p>\n<p>QUIC은 UDP를 기반으로 하면서 TCP의 연결 관리 기능을 프로토콜 수준에서 제공합니다:</p>\n<ul>\n<li><strong>데이터에 연결 ID</strong>(Connection ID)를 포함시켜 연결을 유지합니다</li>\n<li>TCP의 혼잡 제어나 패킷 유실 복구 기능을 QUIC에서 제어합니다</li>\n<li><strong>TLS를 통합해서 기본적으로 암호화됩니다</strong></li>\n<li>멀티플렉싱으로 한 연결에서 여러 스트림을 동시에 처리합니다</li>\n</ul>\n<h3>HTTP/3</h3>\n<p>HTTP/3 프로토콜은 QUIC을 기반으로 사용합니다.</p>\n<p><strong>HTTP/3는 TCP를 버리고 UDP 위에 QUIC을 만들었습니다:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">HTTP/1.1: 여러 TCP 연결 (한 연결 막혀도 다른 연결은 OK)\nHTTP/2:  하나의 TCP 연결 (패킷 하나 유실 → 전체 멈춤)\nHTTP/3:  QUIC 스트림들 (각 스트림이 독립적으로 동작!)</code></pre></div>\n<p><strong>QUIC의 독립적인 스트림:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Stream 1: 패킷 유실 → Stream 1만 대기\nStream 2: 정상 진행 ✓\nStream 3: 정상 진행 ✓</code></pre></div>\n<p>각 QUIC 스트림이 <strong>자체적으로 순서 보장과 재전송을 처리</strong>하기 때문에, 한 스트림의 패킷 유실이 다른 스트림에 영향을 주지 않습니다. 마치 여러 개의 독립적인 TCP 연결을 쓰는 것처럼요!</p>\n<p><strong>현재 지원 현황:</strong></p>\n<ul>\n<li><strong>브라우저</strong>: 크롬, 에지, 사파리 등 주요 브라우저</li>\n<li><strong>기업</strong>: 구글, 페이스북 등 주요 기업</li>\n<li><strong>CDN</strong>: 아카마이, 클라우드플레어, AWS 클라우드프론트 등</li>\n</ul>\n<h3>TCP 연결은 65,535개가 한계인가?</h3>\n<p>포트 번호는 부호 없는 16비트 정수를 씁니다. 그래서 65,535가 포트 번호의 최대값입니다.</p>\n<p><strong>하지만</strong> 한 장비에서 만들 수 있는 TCP 연결 개수는 이론적으로 <strong>2^96개</strong>입니다.</p>\n<p>TCP의 각 연결은 다음 4가지 조합으로 구분되거든요:</p>\n<ul>\n<li><strong>로컬 IP</strong></li>\n<li><strong>로컬 포트</strong></li>\n<li><strong>원격 IP</strong></li>\n<li><strong>원격 포트</strong></li>\n</ul>\n<p>하나의 로컬 IP에서 특정 원격 IP의 1개 포트에 연결할 수 있는 TCP 연결이 65,535개인 겁니다.</p>\n<blockquote>\n<p>실제로는 OS 설정(파일 디스크립터 개수, 포트 범위 설정 등)에 따라 제약을 받습니다.</p>\n</blockquote>","wordCount":{"words":1675},"frontmatter":{"title":"네트워크 기초 정리","date":"September 17, 2025","description":"서버 개발자가 알아야 할 네트워크 기초 지식을 정리합니다."}},"previous":{"fields":{"slug":"/non-blocking/"},"frontmatter":{"title":"Blocking & Non-Blocking I/O로 성능 개선하기"}},"next":{"fields":{"slug":"/oneToone/"},"frontmatter":{"title":"JPA @OneToOne 양방향 관계에서 발생하는 N+1 문제 해결 방법"}}},"pageContext":{"id":"2d2d4eb1-9394-5be7-b05a-2d63b09febde","previousPostId":"05152dfc-1fc7-52d3-bbc8-33b7c98519ad","nextPostId":"88c8c3ad-07c2-5c35-a23f-b46b8737daab"}},"staticQueryHashes":["3257411868","3517523002"],"slicesMap":{}}