{"componentChunkName":"component---src-templates-blog-post-js","path":"/TCP/","result":{"data":{"site":{"siteMetadata":{"title":"GoToBill"}},"markdownRemark":{"id":"2d2d4eb1-9394-5be7-b05a-2d63b09febde","excerpt":"네트워크 서버에는 2개의 공인 IP가 있었습니다: 인바운드 IP: 외부에서 서버로 들어올 때 쓰는 IP 아웃바운드 IP: 서버에서 외부로 나갈 때 쓰는 IP…","html":"<h2>네트워크</h2>\n<p>서버에는 2개의 공인 IP가 있었습니다:</p>\n<ul>\n<li><strong>인바운드 IP</strong>: 외부에서 서버로 들어올 때 쓰는 IP</li>\n<li><strong>아웃바운드 IP</strong>: 서버에서 외부로 나갈 때 쓰는 IP</li>\n</ul>\n<h2>노드, 네트워크, 라우터</h2>\n<p>데이터를 송수신하는 모든 장치를 <strong>노드</strong>라고 부릅니다. 우리가 쓰는 휴대폰, 노트북, 서버 장비 등이 모두 노드에 해당합니다. 이런 각 노드가 서로 데이터를 주고받기 위해 연결된 시스템을 <strong>네트워크</strong>라고 합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 326px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/bb40e9042d33fa7156d113367c4fd2fb/ce9b1/1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75.9493670886076%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAABlUlEQVR42qVUy4rCQBD0w/wxr4JnTwHFg1cRPAuKV0HworCKRqJGD74RTXyb2q2WljGr4rINTaZnaqqfk0gQBDgcDrhcLjifz9jv99jtdvI11dzTNfHU4/EoNrki+JFutwvLspDP52XzEz2dThiNRnAcB7PZTGyqEDabTTmoVqvwPA9hIYHK9XqVr+u6KBQKSCaTKBaLsvdAOJ1OUa/XsVqt8E6UnFlls1mkUinkcjkhY/pC2G63EY/Hkclk4Hu+KAEUOqCzxWIhNuvn+77YjUZDgiA5M2MfIkyBoMFggOVyKZd4QACbxTrxkm3bQqTFVxwbQuFXIuQmQeFaKYjeO52OEOplxSpeJ+UXoSmMnEBGNZ/P75GFnar9NMJnQqAZ2Tvcy5QZXb/fF2UNWeN/EY7HY1QqFZnNWCyGcrn8tMYfE67Xa6TTaZRKJUSjUSQSiXtX/0RokvZ6PdRqNenyZDJ5OQWbzebhbQuh1sh8qzrE2hDzTJ8f57b11cLQHWK73d4GmwDzT8J5Cq/1PHymE8A1lY6+AbtUfhM60tHPAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"네트워크 구조\"\n        title=\"\"\n        src=\"/static/bb40e9042d33fa7156d113367c4fd2fb/ce9b1/1.png\"\n        srcset=\"/static/bb40e9042d33fa7156d113367c4fd2fb/c26ae/1.png 158w,\n/static/bb40e9042d33fa7156d113367c4fd2fb/6bdcf/1.png 315w,\n/static/bb40e9042d33fa7156d113367c4fd2fb/ce9b1/1.png 326w\"\n        sizes=\"(max-width: 326px) 100vw, 326px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>패킷(Packet)</h3>\n<p>노드가 네트워크를 통해 전송하는 데이터의 단위를 패킷이라고 합니다. 패킷은 헤더와 페이로드로 구성됩니다:</p>\n<ul>\n<li><strong>헤더</strong>: 패킷의 발신자와 수신자 정보가 들어있습니다</li>\n<li><strong>페이로드</strong>: 실제 전송되는 데이터가 들어있습니다</li>\n</ul>\n<p>데이터는 일정 크기를 가진 여러 패킷으로 나뉘어 전송됩니다.</p>\n<p>네트워크의 예로 집에서 쓰는 공유기에 연결된 장치들을 들 수 있습니다. 공유기에 연결된 휴대폰이나 컴퓨터가 하나의 네트워크를 구성하죠. 마찬가지로 사무실에서 사용하는 컴퓨터들도 하나의 네트워크를 구성합니다.</p>\n<p>서로 다른 네트워크에 속한 노드는 직접 연결해서 패킷을 송수신할 수 없습니다.</p>\n<p>이때 사용되는 것이 <strong>라우터</strong>입니다. 라우터는 네트워크 간에 패킷을 전송하는 역할을 합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 452px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ff661b761b1304066995c38c7f19de5a/fcb94/2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 20.253164556962027%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA1klEQVR42mWQ206DQBCGeSLqBfb9Q7g2mmJRRIlE3Q0Q7C5YTmU/OxiunMkm/2y+OXrGGJIkoe975nlmmibGccRdfXEL7vrERC/LnxZOeOFEW2uROpLrpWlKGIbUdU3TNGRZxjiMtD+W58+Yonxb4/fqlaePA925oz6VPBb31G2JVprdzQ7f91FK4UmBKIqoqmr9kAZd12Hab47FA7nO6M89uXpZY9saykZzyO8oTwr1pdjvbwmCAK01nowaxzHDMKwjbytv5pz7py/zZWWElZXlFNu5fgF70Sc47UttLAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"라우터를 통한 네트워크 연결\"\n        title=\"\"\n        src=\"/static/ff661b761b1304066995c38c7f19de5a/fcb94/2.png\"\n        srcset=\"/static/ff661b761b1304066995c38c7f19de5a/c26ae/2.png 158w,\n/static/ff661b761b1304066995c38c7f19de5a/6bdcf/2.png 315w,\n/static/ff661b761b1304066995c38c7f19de5a/fcb94/2.png 452w\"\n        sizes=\"(max-width: 452px) 100vw, 452px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>도메인과 IP 주소</h2>\n<p>각 노드의 IP 주소를 외우기는 쉽지 않습니다. 그래서 IP 주소에 기억하기 쉬운 이름을 붙이는데, 그게 바로 <strong>도메인 이름</strong>입니다. 도메인 이름을 IP 주소로 변환하는 체계가 <strong>DNS</strong>입니다.</p>\n<p>DNS를 인터넷 전화번호부라고 생각하시면 됩니다.</p>\n<p><strong>도메인 이름은 계층 구조를 갖습니다. 각 계층은 점(.)으로 구분되며, 오른쪽이 상위 계층이고 왼쪽이 하위 계층입니다.</strong></p>\n<h3>도메인 계층 구조</h3>\n<p>가장 오른쪽이 <strong>최상위 계층</strong>입니다. 최상위 계층에는 두 가지 종류가 있습니다:</p>\n<ul>\n<li><strong>일반 최상위 도메인</strong>: com, org, net, gov, app, biz, tech 등</li>\n<li><strong>국가 최상위 도메인</strong>: kr, jp, au, cn 등</li>\n</ul>\n<h4>일반 최상위 도메인 (예: .com)</h4>\n<ul>\n<li><strong>2차 도메인이 주요 이름이 됩니다</strong> (회사나 브랜드 이름)</li>\n<li>예: naver.com → naver가 2차 도메인</li>\n<li>3차부터는 용도별로 사용: cafe.naver.com, <a href=\"http://www.google.com\">www.google.com</a></li>\n</ul>\n<h4>국가 최상위 도메인 (예: .kr)</h4>\n<ul>\n<li><strong>2차 계층</strong>까지 미리 정의되어 있습니다\n<ul>\n<li>ac.kr: 대학 등 교육 기관용</li>\n<li>co.kr: 기업용</li>\n<li>go.kr: 정부 기관용</li>\n</ul>\n</li>\n<li><strong>3차 계층이 주요 이름이 됩니다</strong></li>\n<li>예: gasapp.co.kr → gasapp이 주요 이름</li>\n</ul>\n<h3>DNS 작동 방식</h3>\n<p>도메인 이름에 해당하는 IP 주소는 DNS 서버를 통해 알아냅니다.</p>\n<h4>간단한 설명</h4>\n<p><a href=\"http://www.naver.com%EC%9D%84\">www.naver.com을</a> 브라우저에 입력하면, 브라우저가 DNS 서버한테 \"<a href=\"http://www.naver.com%EC%9D%98\">www.naver.com의</a> IP 주소가 뭐예요?\"라고 물어봅니다. DNS 서버는 해당 IP 주소를 알려주고, 브라우저는 그 IP 주소로 데이터를 보냅니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. www.naver.com의 IP 주소 요청\n2. 223.130.192.248 응답\n3. 데이터 전송</code></pre></div>\n<h4>실제 DNS 조회 과정 (상세)</h4>\n<p>실제로는 여러 DNS 서버를 거쳐가며 IP 주소를 찾습니다. <strong>구글</strong>에 접속하는 과정을 예로 들어보겠습니다:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 482px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/a582629e39a7beedfb929d27de7ec9c4/37e0d/3.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 201.8987341772152%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEXElEQVR42p1XaXfiRhAk6wNzSUInutGJACFO23iTteO3m+Qlb///36l0j4FgO7aRP/Sb0SCVqrv6EA0vGuGlBVmFYLSEl83h5wv4tB7vA1qDfI7/e7bx7GCYI0hLaMEMPdWF5Y+gWENoTgLTz6HaCXQnhWKGUL0SfjKh5/K3Ad1hhpDe3NUDXDUvkSQZ1L4Gz/EQRTEsawCX9rLUQ1t14KdTQeJthvQ2Px7DSdcwwhn0sBSrMZzBiiroQSnOeLWzDby4+MDlnfl0Y0DuBOlEvCAuKhSztQDgs6fz4oQYHsVyby5ZlJcYTVdiL2L2ws2PAY+YMqvLqx7OL1oESGfJGO898y4gM+prNmzHx8D2aD+AE2ZvuvuuyyHFqW84aLe7WCyvsdrcQlFU9BSDfpvu3K/JkN3t6zYkqY8eGTP0oqKey+wOGzNIRjMkxRytbl/EMabrbDIXv+3v+xCQYzTwU4TZlMBm4uF9Crn0e0yKs+oDPxH2DmABh1ScVmvMlxtUFDf3DaGWFM/F6hrr6+0rlv8BDlO6OUUxmWG5XNFaijNh+3qlJA8obSazJba/3mNz8/UpyY9SqbFn5482VE4rUWZJ9ZvY2yl1nNFGAPF9lhtDM6mWNQcOhUXVXXFt2uGBaYNTxKcO0xk9Qhk/YLD4E/byL7HydSu9p5et4BNLFqYnKUhSEi+IEA4TqJqJxi+XokSfATbTB8jFPZz13zCqH/A3/6A/fcRF9A1BQSypE111ZBiGjSgmocJYmE7XX86bRwx3+eaOtzDTaxjUaUzqJGa6EatTbOGRyj7dp5k+FNWCZrjQTTLLE5WkqIMjhgdRMgQRW75bqcTY6HwvCgsS7kTg7jOk1OKz4LUoH5u/qxDLi2HYQ2TjCjbloelGz8rwJEB+gBNdJtdkRadmEcBxQ2oYvriWFPNFDE8AHGYlupKOTkdCnk8wLeeYTCtopPJVWzm4fTpDip1KOXfZ7JIojhDFoOt2VxHMX4tyonGT5RpmRk6QUe3nzzpQLUBmybFkNuXyFhF1H1acz2oDMiOFcq5Fyd2TdQycUOSk3Dcptpp4GadXDcAJBV+GJKskxhyjYirMptFwdn61Y5nXY9imRntx2aJaLmANPIRhgm5PxpczBizrAYouTgJYlMj6IBSCmE4kzKbO4yefUJlBudw4XiwKjwTeixzcVUstQE4RlRqDTMPKDVJou+Zg075WpexjqFk+ms0O0qwQvZB7YqvVFYm9H62nx5AAOXZfzi6R5WPko4kAbjTOxfxm12sB7iei1LcgESN2ndeebIiu88nSK5DTXC7KBWY0FafVij6iFgewmv2QGPoxylmF7e0Nvt7dkW2xXtN4CJNPAHIeFjfQaUwo4QLR4lHs1XhN4+Pu0CBOb1/5DN3sHp38HuHNT1g0FYPbn5Anv6OVfyfRnj6Pa/TDEsroAd38G8zqD2jld7FKxQOk8Y/DB3y9SqG/FE62gJ1UB3NS/ruxPMTwXzqpUAzdL4adAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"머메이드\"\n        title=\"\"\n        src=\"/static/a582629e39a7beedfb929d27de7ec9c4/37e0d/3.png\"\n        srcset=\"/static/a582629e39a7beedfb929d27de7ec9c4/c26ae/3.png 158w,\n/static/a582629e39a7beedfb929d27de7ec9c4/6bdcf/3.png 315w,\n/static/a582629e39a7beedfb929d27de7ec9c4/37e0d/3.png 482w\"\n        sizes=\"(max-width: 482px) 100vw, 482px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>이 과정이 복잡해 보이지만 실제로는 1초도 안 걸립니다. 한 번 조회한 결과는 캐시에 저장되어 다음에 더 빠르게 접속할 수 있습니다.</p>\n<p>로컬에서 개발할 때 쓰는 localhost는 특별한 주소입니다. localhost의 IP 주소는 127.0.0.1입니다.</p>\n<p>이건 <strong>루프백 주소</strong>라고 해서 자기 자신을 가리킬 때 쓰는 IP 주소입니다.</p>\n<h3>hosts 파일</h3>\n<p>모든 컴퓨터는 hosts 파일을 가지고 있습니다:</p>\n<ul>\n<li><strong>리눅스</strong>: <code class=\"language-text\">/etc</code> 디렉토리에 있습니다</li>\n<li><strong>윈도우</strong>: <code class=\"language-text\">C:\\Windows\\System32\\drivers\\etc</code> 디렉토리에 있습니다</li>\n</ul>\n<h3>도메인 이름과 IP 주소 개수</h3>\n<p>하나의 도메인에 여러 IP 주소가 매핑될 수 있습니다. nslookup 명령어로 확인해볼 수 있습니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">nslookup</span> www.naver.com\n<span class=\"token punctuation\">..</span>.\nAddress: <span class=\"token number\">223.130</span>.192.248\nAddress: <span class=\"token number\">223.130</span>.192.247\nAddress: <span class=\"token number\">223.130</span>.200.219\nAddress: <span class=\"token number\">223.130</span>.200.236</code></pre></div>\n<p>한 도메인에 IP 주소를 여러 개 매핑하는 이유 중 하나는 <strong>부하 분산</strong> 때문입니다.</p>\n<h2>고정 IP와 동적 IP</h2>\n<p>같은 네트워크에서 각 노드는 서로 다른 IP 주소를 가져야 합니다. IP 주소로 패킷을 보낼 노드를 구분하기 때문에, 같은 IP 주소를 가진 노드가 있으면 IP 충돌이 일어납니다.</p>\n<p>노드의 IP 주소는 2가지 방식으로 지정합니다:</p>\n<ul>\n<li><strong>고정 IP</strong>: 노드가 고정된 IP를 갖습니다. 서버 IP가 대표적이죠.</li>\n<li><strong>동적 IP</strong>: 노드가 네트워크에 연결할 때마다 IP를 할당받습니다. DHCP(Dynamic Host Configuration Protocol) 서버가 이걸 담당합니다.</li>\n</ul>\n<h2>DHCP 서버</h2>\n<h4>DHCP 동작 과정 (DORA)</h4>\n<p>DHCP는 <strong>브로드캐스팅</strong>을 통해 IP를 할당받습니다. 이 과정을 <strong>DORA</strong>라고 부르는데, 각 단계의 앞글자를 딴 것입니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">D - Discover (발견)\nO - Offer (제안)\nR - Request (요청)\nA - Acknowledgment (확인)</code></pre></div>\n<h4>상세한 DHCP 과정</h4>\n<p>노트북을 WiFi에 연결하는 상황을 예로 들어보겠습니다:</p>\n<p><strong>① DHCP Discover - \"DHCP 서버 어디있어요?\"</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">노트북: \"저 IP가 없는데 누가 좀 줘요!\" (브로드캐스트)\n발신: 0.0.0.0 (아직 IP가 없음)\n수신: 255.255.255.255 (네트워크 전체에 외침)</code></pre></div>\n<p><strong>② DHCP Offer - \"내가 줄 수 있어\"</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">공유기(DHCP 서버): \"192.168.0.105 쓸래?\"\n제안 내용:\n- IP 주소: 192.168.0.105\n- 서브넷 마스크: 255.255.255.0\n- 게이트웨이: 192.168.0.1\n- DNS: 8.8.8.8\n- 임대 시간: 24시간</code></pre></div>\n<p><strong>③ DHCP Request - \"그거 주세요!\"</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">노트북: \"네, 192.168.0.105 주세요!\" (브로드캐스트)\n→ 여러 DHCP 서버가 있을 수 있어서 가장 먼저 응답을 주는 DHCP 서버를 선택\n→ 브로드 캐스팅으로 알림\n\n메시지 내용:\n- Transaction ID: 이전 DHCP 메시지와 동일한 ID\n- DHCP Message Type: REQUEST\n- Requested IP Address (Option 50): 192.168.0.105\n- DHCP Server Identifier (Option 54): 선택한 서버의 IP</code></pre></div>\n<p><strong>④ DHCP ACK - \"자, 여기 있어\"</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">공유기: \"확인! 192.168.0.105는 24시간 동안 네 거야\"\n→ 이제 노트북은 정식으로 IP를 받음</code></pre></div>\n<h4>브로드캐스팅이란?</h4>\n<p>브로드캐스팅은 네트워크의 모든 기기에게 동시에 메시지를 보내는 방식입니다:</p>\n<ul>\n<li><strong>유니캐스트</strong>: 1:1 통신 (특정 IP로 전송)</li>\n<li><strong>브로드캐스트</strong>: 1:전체 통신 (255.255.255.255로 전송)</li>\n<li><strong>멀티캐스트</strong>: 1:그룹 통신 (특정 그룹에만 전송)</li>\n<li><strong>애니캐스트</strong>: 1:가장 가까운 1개 (같은 IP를 가진 여러 서버 중 가장 가까운 곳으로)</li>\n</ul>\n<p><strong>애니캐스트 예시:</strong>\nCDN이나 DNS 루트 서버가 애니캐스트를 사용합니다. 예를 들어 구글 DNS(8.8.8.8)는 전 세계에 수백 개 서버가 있는데, 모두 같은 IP를 갖습니다. 한국에서 8.8.8.8에 접속하면 한국에서 가장 가까운 서버로 자동 연결됩니다.</p>\n<p>DHCP가 브로드캐스트를 쓰는 이유는 간단합니다. <strong>아직 IP가 없는 기기는 DHCP 서버가 어디 있는지 모르기 때문입니다</strong>. 그래서 \"야! 다들 들어봐! 나 IP 필요해!\"라고 네트워크 전체에 외치는 거죠.</p>\n<h4>IP 임대 시간과 갱신</h4>\n<p>DHCP로 받은 IP는 영구적이지 않습니다:</p>\n<ol>\n<li><strong>임대 시간</strong>: 보통 24시간 (설정 가능)</li>\n<li><strong>50% 시점</strong>: 12시간 지나면 갱신 시도</li>\n<li><strong>87.5% 시점</strong>: 갱신 실패 시 다시 시도</li>\n<li><strong>만료</strong>: 새로 DHCP Discover부터 다시 시작</li>\n</ol>\n<p>이렇게 임대 방식을 쓰는 이유는 한정된 IP 주소를 효율적으로 관리하기 위해서입니다.</p>\n<h2>공인 IP와 사설 IP</h2>\n<p>웹 브라우저에 <a href=\"http://www.google.com%EC%9D%B4%EB%82%98\">www.google.com이나</a> <a href=\"http://www.daum.net\">www.daum.net</a> 같은 도메인을 입력하면 DNS 서버에서 IP 주소를 받아와서 접속합니다. 이때 사용하는 IP 주소는 인터넷 어디서든 접근 가능한 <strong>공인(public) IP</strong> 주소입니다.</p>\n<p>모든 네트워크에서 쓸 수 있는 공인 IP와 달리, 네트워크 내부에서만 쓰는 <strong>사설(private) IP</strong> 주소도 있습니다. 사설 IP는 특정 네트워크 안에서만 유효하고 외부에서는 접근할 수 없습니다.</p>\n<p>사설 IP로 쓸 수 있는 주소 범위입니다:</p>\n<ul>\n<li><strong>192.168.x.x</strong></li>\n<li><strong>10.x.x.x</strong></li>\n<li><strong>172.16.x.x ~ 172.31.x.x</strong></li>\n</ul>\n<h3>공인 IP 알아내기</h3>\n<p>간단한 방법은 <a href=\"https://ifconfig.me\">https://ifconfig.me</a> 같은 사이트에 접속해서 확인하는 겁니다.</p>\n<p>리눅스에서도 아래 명령어로 공인 IP 주소를 확인할 수 있습니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> ifconfig.me</code></pre></div>\n<h2>NAT</h2>\n<p><strong>NAT</strong>(Network Address Translation, 네트워크 주소 변환)는 네트워크 주소를 변환하는 기술입니다. 인터넷에 연결하려면 내부의 사설 IP와 인터넷의 공인 IP 간 변환이 필요한데, NAT가 이걸 처리합니다.</p>\n<ul>\n<li><strong>SNAT(Source NAT)</strong>: 나가는 패킷의 출발지 변경 (AWS NAT Gateway)</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 546px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/188f0abb2526b60722a87f39da470064/76aed/4.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 20.253164556962027%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAArklEQVR42n1PSwqFMAzs/W/iPYQiupVurYiKFrX+6n8kActbvcDQpDNJJkJKiSAIcF0XfuM8TyzLwu+/IH7fd9z3zbVQSiGKIgzDgHVdMc8zoyxLxHEMYww30HDnnMc4jpimibVt26LvezYlwjBkh9ZaHpLnObquQ13XSNOUc2rSWqNpGlRVxRrS0iLi6I8WbNsGkWUZkiRhu8/zeOvkoigKf/LHESj/cByHP5vqF1oVMOfdhmVmAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"snat\"\n        title=\"\"\n        src=\"/static/188f0abb2526b60722a87f39da470064/76aed/4.png\"\n        srcset=\"/static/188f0abb2526b60722a87f39da470064/c26ae/4.png 158w,\n/static/188f0abb2526b60722a87f39da470064/6bdcf/4.png 315w,\n/static/188f0abb2526b60722a87f39da470064/76aed/4.png 546w\"\n        sizes=\"(max-width: 546px) 100vw, 546px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li><strong>DNAT(Destination NAT)</strong>: 들어오는 패킷의 목적지 변경 (AWS ALB/NLB)</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 585px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/a4481de1170d3cb90af544093f05083a/78a22/5.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 22.78481012658228%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABD0lEQVR42m2QO0vDYBSG8y/FzcnB0sWli876A6qT4g2hZlAkBLEQbAdBx1iNRggkqIm532+E5LXfgXZQH3j5DnzwnJfDFUWBqqrA6Lpumd/UdQ3P8yi6rsP8svDwMcVIOcCtdo2rt3NcqmfgBEGAJEl/JGxJkiQIwxBZlpGwaRqaXc9F7McYPu5iY7yC7Wkfg7t19Mar4DRNg6qqsG0bQRAgiiLEcUwi13UhyzKJ0zQlaZ7nJGZ8p59QXBnvvgLVf6ZwPM9DFEXabFkWSVg7dgomNwyD5rIs0bbtMozT2T7681Y79wNsTXrYlNbAmaYJx3HwH2wJ+1s0WjC/Mr0T4wbHT0OMXg5x8XqEk9kefgCC/Wt7WiNwEgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"snat\"\n        title=\"\"\n        src=\"/static/a4481de1170d3cb90af544093f05083a/78a22/5.png\"\n        srcset=\"/static/a4481de1170d3cb90af544093f05083a/c26ae/5.png 158w,\n/static/a4481de1170d3cb90af544093f05083a/6bdcf/5.png 315w,\n/static/a4481de1170d3cb90af544093f05083a/78a22/5.png 585w\"\n        sizes=\"(max-width: 585px) 100vw, 585px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>DNAT는 서버 구성할 때 많이 씁니다. 보통 보안이나 이중화를 위해 서버는 사설 IP를 쓰고, 공인 IP는 라우터나 방화벽 같은 네트워크 장비에 할당합니다.</p>\n<h2>VPN</h2>\n<p>백엔드 서버를 개발하고 운영하다 보면 서버나 DB에 접속할 일이 많습니다. SSH로 서버에 접속해서 프로세스를 확인하거나 OS 설정을 바꿔야 할 때도 있고, DB에 접속해서 SQL을 실행해야 할 때도 있죠.</p>\n<p>서버 네트워크의 노드에 안전하게 접근하려면 <strong>VPN</strong>(Virtual Private Network, 가상 사설 네트워크)을 사용합니다. VPN은 인터넷 같은 공용 네트워크에서 서로 다른 네트워크 간에 암호화된 연결을 제공합니다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1a31889900d9f6791e839395c7e1c624/084e2/6.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36.075949367088604%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABbklEQVR42pWRzU/bQBDF898iOCCOqEVCOfeAeoRDb0gVl0oETkCBEFBBlUyRFSikxCSQKCTGGyfO2t71/vCazwOXjjSat6vRm3lvSsYYXjLLMrJn/FHY/yRJMNpwJ9octnZxOscc5bXR/0umMkpKKXq9Ho1GAxEIxpMRnf4tD0MfOZFIKYnjmCiKCEKfrn+HSQ1Vb4v5vSmWTsp82p/mx8UqZFCykx3HYXNzg+t/TUIpODzb5bzp4jU96vU6rptj74aLG5eD023EUPD79ogvvz7zzfma1wW2ritPhFprWq0W1WoVIUQuW+MHAyYywm4fhiFBEGD7ZDzBHw5AQc3bYfFglqXjMuXaHJXLtSdC69t4PC5kt9ttup0uWulXX9/7Z3tTlRbvmvezkGolL+zPULlae5NsG+02NgsyLNHbsV6IjclyP2WB6/0/rLrLrF9+z+tKcRj0M+H/hB2apgkjMaLfHdDr3BNHCTrVKK14BN1nBmPVDY7wAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"snat\"\n        title=\"\"\n        src=\"/static/1a31889900d9f6791e839395c7e1c624/f058b/6.png\"\n        srcset=\"/static/1a31889900d9f6791e839395c7e1c624/c26ae/6.png 158w,\n/static/1a31889900d9f6791e839395c7e1c624/6bdcf/6.png 315w,\n/static/1a31889900d9f6791e839395c7e1c624/f058b/6.png 630w,\n/static/1a31889900d9f6791e839395c7e1c624/084e2/6.png 632w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>개발자는 VPN 클라이언트로 VPN에 접속할 수 있습니다. 집이나 카페에서 서버 네트워크에 접근해야 할 때 이 방식을 씁니다.</p>\n<h2>프로토콜과 TCP, UDP, QUIC</h2>\n<p>네트워크에서 두 노드가 데이터를 주고받기 위해 정한 규칙을 <strong>프로토콜</strong>(protocol)이라고 합니다. 네트워크는 여러 계층으로 구성되고 각 계층마다 사용하는 프로토콜이 있습니다.</p>\n<p><strong>TCP/IP 모델의 계층별 프로토콜과 전송 단위:</strong></p>\n<table>\n<thead>\n<tr>\n<th>계층</th>\n<th>프로토콜</th>\n<th>전송 단위</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>응용 계층</td>\n<td>HTTP, FTP, SMTP</td>\n<td>메시지 (Message)</td>\n</tr>\n<tr>\n<td>전송 계층</td>\n<td>TCP</td>\n<td>세그먼트 (Segment)</td>\n</tr>\n<tr>\n<td>전송 계층</td>\n<td>UDP</td>\n<td>데이터그램 (Datagram)</td>\n</tr>\n<tr>\n<td>네트워크 계층</td>\n<td>IP</td>\n<td>패킷 (Packet)</td>\n</tr>\n</tbody>\n</table>\n<h3>TCP (Transmission Control Protocol)</h3>\n<p>TCP는 연결 기반 프로토콜입니다. 전화 통화처럼 먼저 연결을 맺고 나서 데이터를 주고받습니다. TCP에서 두 노드가 연결을 맺는 과정을 <strong>3-Way Handshake</strong>라고 부릅니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 288px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/cb29290e24696aca7edccfca61f34e87/477c9/7.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 101.26582278481011%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAABq0lEQVR42pWUaavCMBBF/f8/SEFQUUE/+EXrgoIK7rjv+zKPM5CSatOngdCSSU7u3BkS22w2UqlUpN1uS6fTkapXleVyKYzX6yVRg33NZlMOh4O/P7ZarcTzPBmPxzIajRS83+8DB9kYBl+v19Lr9YJAs3GxWEir1dL/5/MZgLnG8XiURqMR2OcD+/2+JJNJhXGjWecQMdsGE0NhJpMJiPCBg8FACoWC/m+3W8EKvlhRr9dlOp1+KMb/XC7nBhaLxUCQ7+l0kvP5rHBU4i+qjcJsNhsOJC0DfDweoZ6xlwuwxPiXSqXcQJMyQdYp1GQyUQBqUGgO3m436Xa7bg/fgUzaiPXZbKYdUC6X9RL8vVwu6mtkygZ4v981bQ6RGubzNet2UZxAipJIJOR6vWpqpAgEqKsXI4EojMfjkUX5GZhOpzWAKkxnUFVi+GYX7CtgPp/3+4u52+10nQeAav+s8L2xKQITlTQ0l9DgxldUf93YYYVgHSuA0pu1Wi26sd8V/vd8zedzt0LeNbuxo4b92jiBw+FQSqXSV0D7gf0AmiDmY/YvgzNU2n5g/wCoNQWFHlgvlQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"3handshake\"\n        title=\"\"\n        src=\"/static/cb29290e24696aca7edccfca61f34e87/477c9/7.png\"\n        srcset=\"/static/cb29290e24696aca7edccfca61f34e87/c26ae/7.png 158w,\n/static/cb29290e24696aca7edccfca61f34e87/477c9/7.png 288w\"\n        sizes=\"(max-width: 288px) 100vw, 288px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">클라이언트 → 서버: SYN (Seq=1000)\n서버 → 클라이언트: SYN-ACK (Seq=3000, Ack=1001)\n클라이언트 → 서버: ACK (Seq=1001, Ack=3001)</code></pre></div>\n<p><strong>Seq와 Ack가 뭔가요?</strong></p>\n<ul>\n<li><strong>Seq(Sequence Number)</strong>: \"내가 보내는 데이터의 번호\"</li>\n<li><strong>Ack(Acknowledgment Number)</strong>: \"다음에 받고 싶은 상대방 데이터의 번호\"</li>\n</ul>\n<p>예를 들어 서버가 <code class=\"language-text\">Ack=1001</code>을 보내면 \"클라이언트님, 1000번까지 잘 받았고 이제 1001번 주세요\"라는 의미입니다.</p>\n<p><strong>왜 Sequence Number는 임의의 난수로 시작할까?</strong></p>\n<p>클라이언트와 서버 모두 각자의 Seq를 임의의 난수로 시작합니다. 위 예시에서 클라이언트는 1000, 서버는 3000으로 시작했죠.</p>\n<ol>\n<li><strong>보안</strong>: 예측 가능한 번호(0, 1, 2...)를 쓰면 공격자가 패킷을 위조하기 쉬움</li>\n<li><strong>이전 연결과 구분</strong>: 같은 포트로 새 연결을 맺을 때, 이전 연결의 지연된 패킷과 섞이는 것 방지</li>\n</ol>\n<p>TCP는 양방향 통신이라서 각자 자신의 송신 채널에 대한 Seq가 필요합니다:</p>\n<ul>\n<li>클라이언트의 Seq: 클라이언트 -> 서버 데이터 추적</li>\n<li>서버의 Seq: 서버 -> 클라이언트 데이터 추적</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b2b62ce43413961e186c907eaabc0bb5/e51a6/8.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 58.86075949367089%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAPoAAAD6AG1e1JrAAABOUlEQVR42nWSO0/EMBCE7/+XlPwACgoKGiQKaJGQ6GhoqMiLKE6c+JnH8fmSs0w4rMTZjHdmZ20fjucxjVPXdc654z9jWZa2bb33ETnwDtqzYIxRSmmtQbyfslLEJBKY0UV9JYtO8QTyw1tZVG1a5P0ju7q+iwVvnj7xlSbc3r88Pr8GMtWstcxCiKqqkOcXIzG173sQKSUJZVlikFWMBDKRnxbrx6+8lIMiZpAdyUY7wF6ZrKi0pacFkIQzeXbWm7zKhRTjMlrv1uY3slGAvZbFd8FMrJ3dyKntuq5X27/Ip8qYojIGV/ACOfackrUesCZVt1YOvmJlPgi7caJnrWwU3m0YM+eMNQKktw1j4dRn6LluGlTDk1T+e3M47XmeA5mtj7abpkF+Zzt1EeU4kcNF4R2YXskU+QFmPrlMmnHaUgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"3handshake\"\n        title=\"\"\n        src=\"/static/b2b62ce43413961e186c907eaabc0bb5/f058b/8.png\"\n        srcset=\"/static/b2b62ce43413961e186c907eaabc0bb5/c26ae/8.png 158w,\n/static/b2b62ce43413961e186c907eaabc0bb5/6bdcf/8.png 315w,\n/static/b2b62ce43413961e186c907eaabc0bb5/f058b/8.png 630w,\n/static/b2b62ce43413961e186c907eaabc0bb5/e51a6/8.png 783w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>TCP 연결 종료: 4-Way Handshake</h3>\n<p>TCP 연결은 <strong>양방향 채널</strong>입니다. 클라이언트 -> 서버, 서버 -> 클라이언트 두 개의 독립적인 채널이 있죠.</p>\n<p>연결을 끊으려면 <strong>각 채널을 따로 닫아야 합니다</strong>. 그래서 4-Way가 필요합니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">클라이언트 → 서버: FIN (\"나는 더 보낼 거 없어\")\n서버 → 클라이언트: ACK (\"알겠어\")\n서버 → 클라이언트: FIN (\"나도 더 보낼 거 없어\")\n클라이언트 → 서버: ACK (\"알겠어\")</code></pre></div>\n<p><strong>왜 3-Way가 아니라 4-Way인가?</strong></p>\n<p>3-Way Handshake처럼 서버가 ACK+FIN을 동시에 보내면 안 될까요?</p>\n<p>문제는 서버가 <strong>아직 보낼 데이터가 남아있을 수 있다</strong>는 겁니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">클라이언트: \"나 다 보냈어\" (FIN)\n서버: \"알겠어, 근데 나는 아직 보내는 중이야\" (ACK만)\n서버: (남은 데이터 전송...)\n서버: \"나도 이제 다 보냈어\" (FIN)\n클라이언트: \"알겠어\" (ACK)</code></pre></div>\n<p>만약 3-Way로 ACK+FIN을 동시에 보내면, 서버가 보내던 데이터가 중간에 끊길 수 있습니다.</p>\n<p><strong>서버가 먼저 FIN을 보낼 수도 있다</strong></p>\n<p>TCP는 대등한 양방향 통신이기 때문에, 누가 먼저 FIN을 보내든 상관없습니다:</p>\n<ul>\n<li>HTTP 서버가 응답을 다 보낸 후 먼저 연결을 끊는 경우</li>\n<li>서버가 타임아웃으로 연결을 정리하는 경우</li>\n</ul>\n<p>핵심은 <strong>양쪽 모두 \"나는 더 보낼 게 없다\"고 선언해야 연결이 완전히 종료된다</strong>는 것입니다.</p>\n<p><strong>TIME_WAIT: 마지막 ACK 후에도 기다리는 이유</strong></p>\n<p>클라이언트가 마지막 ACK를 보낸 후 바로 연결을 닫지 않고 <strong>TIME_WAIT</strong> 상태로 일정 시간(보통 60초) 대기합니다.</p>\n<p>왜 기다릴까요?</p>\n<ol>\n<li><strong>마지막 ACK가 유실될 수 있음</strong></li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">클라이언트 → 서버: ACK (마지막)\n         ↑\n      이게 유실되면?\n\n서버: \"어? ACK 안 왔네, FIN 다시 보내야겠다\"\n서버 → 클라이언트: FIN (재전송)</code></pre></div>\n<p>클라이언트가 이미 연결을 닫았다면 서버의 FIN 재전송을 받을 수 없고, 서버는 계속 FIN을 보내며 대기하게 됩니다.</p>\n<ol start=\"2\">\n<li><strong>지연된 패킷이 새 연결에 섞이는 것 방지</strong></li>\n</ol>\n<p>이전 연결의 패킷이 네트워크 어딘가에서 지연되다가, 새 연결이 같은 포트를 사용하면 이전 연결의 패킷이 새 연결에 섞일 수 있습니다. TIME_WAIT으로 대기하면 이전 연결의 모든 패킷이 네트워크에서 사라질 시간을 확보합니다.</p>\n<p><strong>HTTP/1.0</strong>: 매 요청마다 새로운 TCP 연결을 맺어야 했습니다 (Connection: close가 기본값)</p>\n<p><strong>HTTP/1.1</strong>: <strong>Keep-Alive</strong>로 하나의 TCP 연결을 재사용할 수 있게 되었습니다 (Connection: keep-alive가 기본값)</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d835a9de463d539b677b5f425319b517/4ff83/9.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70.88607594936708%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC80lEQVR42nVT7UtTURh/pm6uzTXnptO0uc05w2KmVzOxvJR7ueqducEg0BD6MKms8A03W50PGUzUypDKNLRSkQmWEZElXqfLCGYYmFIhfZD+jtt92co5euDynHvOc37Py+93AKKGI7HQjkyiGmQES89xMPvyoRbxHkAQieK8mEQaqEGlYPUYwOorEtl8BQC0AGKsEImg7IoSKjoywIoMYO7WwCmPnvv2G+aWcGA2pIUznXlQfl0LrkAi7M3aNRaSETefjbY+mNdFD6ZDW49nNna97Jqi6CTWXxx4VWzrmRhDFMX9uxASTa59fze5vuvkLiGaTmD9RPBr1a3p5VDLvZfaKODMyrf50dWfPCDNAz5aWG/xPl96y0BxFXkeTimmVre+jHzcqYupUGH2y7nZAEqItCXkWlHWy/bGqS0oA872ZP9tv75LBsWXcwGIZH5jhLm4eV8Dy3350DZoALQpguZxMSCmpQaPEpo6pFwcxextP9LCh7t6aH9iBJyp2B0WskdSu1eNud1CHpBm2PkxlAz+brnE0Ztlta6lYY5gViW5qjGQczhHAGuBQGLur3Fx+jBKkTtelMgbgyWp5xdNxY4V4nDD7Lk44gDHkzB85IgfC2vCWWEJDUz2Oo8CSCTZ2zLQIGgtnXOismBVR/kS1mheqdbbZ53xgC5GNnW92TC4dgAuvVFkO6gcVcMUFq3wN+NpQ2fehqnd2IaNnggVbMteY2E+GdMyN/NYbWFC/OSw4X3B+qEBjFIFsB15afVTfbRCmhEuzRDWZOmQphDe9Mi8BP8HLHSJgPRr4MJnJTRTqcDqzjGUwwhcHjsaJAaWaV50vCJqUSaQkVmzWWl9t3zx2DW1/XS/LoBvpjRVLGQ4zZ/yjfaZSrD5jsYBkkgVA0jcyIs8UUYNgJLo3M7MoKlV56gcLJor21KiwoCIPZOwme131DGkWPqlQKAcHi8CaL+tg/o+2f73KQRrW1rMZQIdjGOZuJr8Ly4yQ7JdxVTOvaQ/bznqEwV5Wg0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"파이프라이닝\"\n        title=\"\"\n        src=\"/static/d835a9de463d539b677b5f425319b517/f058b/9.png\"\n        srcset=\"/static/d835a9de463d539b677b5f425319b517/c26ae/9.png 158w,\n/static/d835a9de463d539b677b5f425319b517/6bdcf/9.png 315w,\n/static/d835a9de463d539b677b5f425319b517/f058b/9.png 630w,\n/static/d835a9de463d539b677b5f425319b517/4ff83/9.png 843w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>파이프라이닝 없음</strong>: 요청을 보내고 응답을 받은 후에야 다음 요청을 보낼 수 있습니다</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> (요청-응답-요청-응답)</code></pre></div>\n<p><strong>파이프라이닝 있음</strong>: 응답을 기다리지 않고 여러 요청을 연속으로 보낼 수 있습니다</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(요청-요청-요청 → 응답-응답-응답)</code></pre></div>\n<p>그렇지만 파이프 라이닝은 일부 패킷이 유실되면 그 패킷이 도착할 때까지 이후 패킷을 처리하지 못하는 <strong>HOL 블로킹</strong>(Head-of-Line Blocking) 문제가 있습니다.</p>\n<h2>HTTP/2.0</h2>\n<h3>HTTP/1.1의 문제</h3>\n<p>HTTP/1.1은 <strong>한 번에 하나씩</strong> 처리합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">브라우저: \"index.html 줘\"\n서버: \"여기\"\n브라우저: \"style.css 줘\"\n서버: \"여기\"\n브라우저: \"image.png 줘\"\n서버: \"여기\"</code></pre></div>\n<p>파일이 10개면 10번 왔다갔다 해야 합니다. 느리죠.</p>\n<h3>HTTP/2의 해결책: 멀티플렉싱</h3>\n<p>HTTP/2는 <strong>동시에 여러 개</strong>를 요청합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">브라우저: \"index.html 줘, style.css 줘, image.png 줘\" (한꺼번에)\n서버: (섞어서 보냄)</code></pre></div>\n<p>근데 문제가 있습니다. 데이터가 섞여서 오면 <strong>어떤 게 index.html이고 어떤 게 style.css인지</strong> 어떻게 구분할까요?</p>\n<h3>바이너리 프레이밍</h3>\n<p>그래서 HTTP/2는 데이터를 <strong>작은 조각</strong>(Frame)으로 나누고, 각 조각에 <strong>번호표</strong>(Stream ID)를 붙입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[Frame: Stream 1번, index.html 조각]\n[Frame: Stream 2번, style.css 조각]\n[Frame: Stream 1번, index.html 조각]\n[Frame: Stream 3번, image.png 조각]</code></pre></div>\n<p>받는 쪽에서는 번호표를 보고 조각들을 다시 모읍니다:</p>\n<ul>\n<li>Stream 1번 조각들 모으기 -> index.html 완성</li>\n<li>Stream 2번 조각들 모으기 -> style.css 완성</li>\n<li>Stream 3번 조각들 모으기 -> image.png 완성</li>\n</ul>\n<p>HTTP/1.x는 Plain Text(평문)를 사용하고 개행으로 구별했지만, HTTP/2.0에서는 <strong>바이너리 포맷</strong>으로 인코딩된 Message, Frame으로 구성됩니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ca41c32e632a7d7081411873edec7de2/33e10/10.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.26582278481012%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAPoAAAD6AG1e1JrAAABeElEQVR42nWSbW+CMBRG/f+/QedkIRFkb06NsinC2AYWrOI0qCBFMaB+UBeX6D7MXYEQE7OTJzftbU/apE1JHFu5vuJzuXI2I+bzgUPW6/U2hBDiuu72H3zfT+HqHXqitNJN6zHXe2adQd+27WMIQohhGI7joBYKhWaz+RaCdRVWN5tNSpfqQ100sTTQm5+txtwl0I1kVVXT6TRFUTRNQy0Wi5IkaZqG0fvvfnuSMcbtEDgH6mKxSGTYBxrLsmDyPC/LsqIo0OzqrViufhh1fZRkMp1H8u7wjdp6JQQurJ1hGMbvz+4kl5DFSP0cj+h6u4w9y1smsud54/HYu2C1WsUy99G41UQIo77ct+XhjCSyO8LTnrCyFNIRJl1hMXqHMWRJBrFc7skPXYF+LRY0vmaptu8m8sxUAqMMQZWMXs1inoqmBNdiGV5sc8bhcIjkr/3ONeW9I0Ic5a4v0n6nFE2Xdit+quMF0I2+wcyxiNm5zHRiwmoQBH+BSft2wJ+BfgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"HTTP/2 바이너리 프레이밍\"\n        title=\"\"\n        src=\"/static/ca41c32e632a7d7081411873edec7de2/f058b/10.png\"\n        srcset=\"/static/ca41c32e632a7d7081411873edec7de2/c26ae/10.png 158w,\n/static/ca41c32e632a7d7081411873edec7de2/6bdcf/10.png 315w,\n/static/ca41c32e632a7d7081411873edec7de2/f058b/10.png 630w,\n/static/ca41c32e632a7d7081411873edec7de2/33e10/10.png 844w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>HTTP/2의 구성 요소:</strong></p>\n<table>\n<thead>\n<tr>\n<th>용어</th>\n<th>의미</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Frame</strong></td>\n<td>데이터 조각 + 번호표 (HTTP/2 통신의 최소 단위)</td>\n</tr>\n<tr>\n<td><strong>Stream</strong></td>\n<td>같은 번호표를 가진 조각들의 그룹 (= 하나의 요청/응답)</td>\n</tr>\n<tr>\n<td><strong>Message</strong></td>\n<td>Stream을 모아서 완성한 전체 요청 또는 응답</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"/15.gif\" alt=\"HTTP/2 멀티플렉싱 애니메이션\"></p>\n<p>위처럼, 하나의 커넥션에서 여러 병렬 스트림(3개)이 동시에 존재할 수 있습니다. 각 스트림의 프레임들이 뒤섞여서 전송되더라도, Stream Number를 통해 어떤 스트림에 속하는지 식별하여 정확하게 재조립됩니다.</p>\n<p><strong>HTTP/2 프레임과 TCP 세그먼트의 관계</strong></p>\n<p>HTTP/2 프레임은 결국 TCP 세그먼트의 페이로드로 들어갑니다. 중요한 점은 <strong>TCP는 HTTP/2 프레임이 뭔지 모른다</strong>는 겁니다. TCP 입장에서는 그냥 \"바이트 덩어리\"일 뿐이죠.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">HTTP/2 레이어: [Frame A: Stream 1] [Frame B: Stream 3] [Frame C: Stream 1]\n                        ↓\nTCP 레이어: \"그냥 바이트 덩어리로 보임\"\n                        ↓\nTCP 세그먼트: [Frame A + Frame B 일부] [Frame B 나머지 + Frame C]</code></pre></div>\n<ul>\n<li>하나의 TCP 세그먼트에 <strong>여러 개의 작은 프레임</strong>이 담길 수 있습니다</li>\n<li>하나의 큰 프레임이 <strong>여러 TCP 세그먼트에 나뉘어</strong> 담길 수도 있습니다</li>\n<li>같은 세그먼트 안에 <strong>서로 다른 스트림의 프레임</strong>이 함께 있을 수 있습니다</li>\n</ul>\n<p>수신 측의 HTTP/2 레이어가 각 프레임의 헤더에서 Stream ID와 길이를 읽고 \"여기부터 여기까지가 하나의 프레임이다\"를 파싱해서 재조립합니다.</p>\n<h3>HTTP/2의 한계: TCP HOL 블로킹</h3>\n<p>HTTP/2는 응용 계층에서의 HOL 블로킹을 해결했지만, <strong>TCP 레벨에서는 여전히 문제가 있습니다</strong>.</p>\n<p><strong>계층별 동작 이해:</strong></p>\n<p>네트워크는 계층으로 나뉘어 동작합니다:</p>\n<ul>\n<li><strong>응용 계층 (HTTP/2)</strong>: 프레임과 스트림으로 멀티플렉싱 구현</li>\n<li><strong>전송 계층 (TCP)</strong>: 순서를 보장하는 바이트 스트림 전송</li>\n</ul>\n<p>HTTP/2의 모든 스트림은 결국 <strong>하나의 TCP 연결</strong>을 통해 전송됩니다. TCP는 HTTP/2의 스트림 개념을 모르고, 단지 순서대로 바이트를 전달할 뿐입니다.</p>\n<p><strong>실제 예시: 10MB 이미지 + 1KB CSS 파일 요청</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">HTTP/1.1 (순차 처리):\n1. 10MB 이미지 요청 → 완료 (10초)\n2. 1KB CSS 요청 → 완료 (0.1초)\n총 시간: 10.1초\n\nHTTP/2 (멀티플렉싱):\n1. 10MB 이미지 + 1KB CSS 동시 요청 (프레임 교대로 전송)\n2. CSS는 1초 만에 완료 (이미지 중간에 끼워서 전송)\n3. 이미지는 10초 만에 완료\n총 시간: 10초 (CSS는 1초에 완료!)</code></pre></div>\n<p><img src=\"/16.gif\" alt=\"HTTP/2 한계\"></p>\n<p>HTTP/2는 하나의 TCP 연결만 사용하기 때문에, 패킷 하나만 유실되어도 <strong>모든 스트림이 영향을 받습니다</strong>. 오히려 HTTP/1.1이 여러 TCP 연결을 사용할 때보다 더 심각할 수 있죠.</p>\n<p><strong>TCP 패킷 손실 시나리오:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">TCP 패킷: [1][2][3][4][5][6][7][8][9][10]\n                ↑\n           3번 패킷 유실!\n\nTCP 패킷 손실 발생:\nHTTP/1.1: 모든 데이터 정지 \nHTTP/2: 모든 스트림 정지 \n\n결과: 패킷 4~10번이 도착해도 처리 못함\n→ TCP가 3번을 기다리느라 모든 HTTP/2 스트림이 멈춤</code></pre></div>\n<h3>Stream 우선순위</h3>\n<p><img src=\"/%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84.gif\" alt=\"우선순위\"></p>\n<p>HTTP 메시지가 많은 개별 프레임으로 분할될 수 있고 여러 스트림의 프레임을 다중화(Multiplexing)할 수 있게 되면서, <strong>스트림들의 우선순위를 지정할 필요가 생겼습니다.</strong></p>\n<p>클라이언트는 우선순위 지정을 위해 '우선순위 지정 트리'를 사용하여 서버의 스트림 처리 우선순위를 지정할 수 있습니다. <strong>서버는 우선순위가 높은 응답이 클라이언트에 우선적으로 전달될 수 있도록 대역폭을 설정합니다.</strong></p>\n<h3>HTTP 헤더 압축 (HPACK)</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/32365d82b3ad2829ce14a7bbe090d7e3/4ff83/12.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 83.54430379746836%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAPoAAAD6AG1e1JrAAACmUlEQVR42o2S60/aYBTG+38bF6Nyk4soVUAolksBC1haoBer406FgCAIODbnzGS4uJBliW5+2NwDOOe+6E7enLxpz+885/ISvV6v1WoNBoO7u7v7J/brj93c3DQajW63e3Fxcf+vERzHURRlMpkMBkOiqngz0YC6y9X2q9WqJEmapqXTaZZl19fXLRbL6uoq7rjAy7JMMAwD2G63G41Gpig4U0FKZcOlFKRA9vt9ZAkEAiRJOhwOq9WKYJvN5vP5ksnkBPZ4PPiq1+sBu0Rmkw8Brtfr2WwWBefz+RkMxmw2A4Oy1+t9gP1+P5Tn5uasYeeC22IObVijrk6nc3l5ORqNeJ4PhwI4JoNOv7ykW1pcXHhlWTFFIiFCEIRUKkXTNMrmT/JeOeKWwkInf3V19XNqo48ffpznv7/PVUUqGyebe4G3ldiRQtfzwkQZVaHm+fl5ktvW+dYMtGODp9EwRnJ4eAjlCBP0uF0rRj0EjbpleOgndxNEMBjcnJpOpwOzlthGCt9+rN1uFwoF+EqlgqE4nU60Bg1429QmPauqirnPZk6GqbiaThYkuZYbDoffpoZXgLh4PI4YrBM+FothweVymXjc+NnZWTQavX/WsC2k+/tIsEm012w2sU9sBTrIcnt7+xiBF1adGuavKAoawWX22ghVO45IRXdEYMTcVjQl105xxGp/PB7P4OHoc0brucI8u6dRMXFHqcx86ahH4Adz0LJHRFqp2UPpeKkvt0fS8SesagZ/GX+tnbzL1dra8Ztysw+m2OhWWqcng/MJjGiQSOHiciS75xVK4WzzEX7GHmBfuhKQax6+CB7iT5VfgIXGORjwKBtH74mKreF/wTuZ1042Y/PFKO7AEUzibCVUNnt0fX39IvwblxYUZWSHwBIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"HTTP 헤더 압축\"\n        title=\"\"\n        src=\"/static/32365d82b3ad2829ce14a7bbe090d7e3/f058b/12.png\"\n        srcset=\"/static/32365d82b3ad2829ce14a7bbe090d7e3/c26ae/12.png 158w,\n/static/32365d82b3ad2829ce14a7bbe090d7e3/6bdcf/12.png 315w,\n/static/32365d82b3ad2829ce14a7bbe090d7e3/f058b/12.png 630w,\n/static/32365d82b3ad2829ce14a7bbe090d7e3/4ff83/12.png 843w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>이전 Header의 내용과 중복되는 필드를 재전송하지 않도록 하여 데이터를 절약합니다. 기존에 HTTP Header가 Plain Text(평문)이었지만, HTTP/2에서는 <strong>Huffman Coding</strong>을 사용하는 <strong>HPACK</strong>이라는 Header 압축방식을 이용하여 데이터 전송 효율을 높였습니다.</p>\n<p><strong>Huffman Coding</strong>: 데이터 문자의 빈도에 따라서 다른 길이의 부호를 사용하는 알고리즘</p>\n<p><strong>TCP의 장점은 신뢰성</strong>입니다. 패킷 순서를 보장하고 패킷이 유실되면 재전송해줘서 <strong>안정적으로 데이터를 전송할 수 있습니다.</strong> 그래서 <strong>HTTP, SMTP</strong> 같은 많은 프로토콜이 TCP를 기반으로 동작합니다.</p>\n<p>하지만 시퀀스 번호, 확인 응답, 재전송 같은 기능 때문에 <strong>UDP보다는 느립니다.</strong></p>\n<h3>UDP (User Datagram Protocol)</h3>\n<p>TCP와 달리 UDP는 연결 과정 없이 바로 데이터를 보냅니다. <strong>데이터가 제대로 전송됐는지도 모르고, 순서도 보장하지 않습니다.</strong></p>\n<p>UDP를 쓰는 애플리케이션은 데이터가 유실될 수 있다고 가정하고 개발해야 합니다.</p>\n<p>UDP는 응답 확인이나 패킷 정렬 같은 과정이 없어서 <strong>TCP보다 빠릅니다.</strong></p>\n<p>그래서 속도가 중요하거나 약간의 데이터 유실이 괜찮은 통신에 씁니다. <strong>DNS, VoIP, 게임 등이 UDP를 사용하는 대표적인 예입니다.</strong></p>\n<h3>QUIC</h3>\n<p>TCP는 신뢰성이 있지만 느립니다. UDP는 빠르지만 신뢰성이 없죠. 이 둘의 장점을 합친 프로토콜이 <strong>QUIC</strong>입니다.</p>\n<p>QUIC은 UDP를 기반으로 하면서 TCP의 연결 관리 기능을 프로토콜 수준에서 제공합니다:</p>\n<ul>\n<li><strong>데이터에 연결 ID</strong>(Connection ID)를 포함시켜 연결을 유지합니다</li>\n<li>TCP의 혼잡 제어나 패킷 유실 복구 기능을 QUIC에서 제어합니다</li>\n<li><strong>TLS를 통합해서 기본적으로 암호화됩니다</strong></li>\n<li>멀티플렉싱으로 한 연결에서 여러 스트림을 동시에 처리합니다</li>\n</ul>\n<h3>HTTP/3</h3>\n<p>HTTP/3 프로토콜은 QUIC을 기반으로 사용합니다.</p>\n<p><strong>HTTP/3는 TCP를 버리고 UDP 위에 QUIC을 만들었습니다:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">HTTP/1.1: 여러 TCP 연결 (한 연결 막혀도 다른 연결은 OK)\nHTTP/2:  하나의 TCP 연결 (패킷 하나 유실 → 전체 멈춤)\nHTTP/3:  QUIC 스트림들 (각 스트림이 독립적으로 동작!)</code></pre></div>\n<p><strong>QUIC의 독립적인 스트림:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Stream 1: 패킷 유실 → Stream 1만 대기\nStream 2: 정상 진행 ✓\nStream 3: 정상 진행 ✓</code></pre></div>\n<p>각 QUIC 스트림이 <strong>자체적으로 순서 보장과 재전송을 처리</strong>하기 때문에, 한 스트림의 패킷 유실이 다른 스트림에 영향을 주지 않습니다. 마치 여러 개의 독립적인 TCP 연결을 쓰는 것처럼요!</p>\n<p><strong>QUIC의 순서 보장: 스트림 간이 아니라 스트림 내부</strong></p>\n<p>QUIC은 <strong>스트림 간의 순서</strong>는 보장하지 않습니다. 스트림 1이 먼저 끝나든 스트림 3이 먼저 끝나든 상관없습니다.</p>\n<p>대신 <strong>스트림 내부의 순서</strong>를 보장합니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">받는 쪽 (QUIC 라이브러리):\n  UDP 데이터그램 수신\n  ↓\n  Stream ID 확인 후 각 스트림 버퍼에 분류\n  ↓\n  Stream 1 버퍼: [1][ ][3] ← 2번 아직 안 옴, 대기\n  Stream 2 버퍼: [1][2][3] ← 완성! 애플리케이션에 전달\n  Stream 3 버퍼: [1][2]    ← 정상 진행</code></pre></div>\n<p>TCP는 OS 커널이 <strong>연결 전체</strong>에서 순서를 맞추지만, QUIC은 애플리케이션 레벨에서 <strong>스트림별로 독립된 버퍼</strong>를 관리합니다. 그래서 한 스트림의 패킷 유실이 다른 스트림에 영향을 주지 않습니다.</p>\n<p><strong>HOL 블로킹 비교:</strong></p>\n<table>\n<thead>\n<tr>\n<th>계층</th>\n<th>HTTP/1.x</th>\n<th>HTTP/2</th>\n<th>HTTP/3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>응용 계층 HOL</td>\n<td>O (순차 응답)</td>\n<td>X (멀티플렉싱)</td>\n<td>X</td>\n</tr>\n<tr>\n<td>전송 계층 HOL</td>\n<td>O (TCP)</td>\n<td>O (TCP)</td>\n<td>X (QUIC)</td>\n</tr>\n</tbody>\n</table>\n<p>HTTP/1.x는 응답을 순서대로 보내야 해서 무거운 요청이 앞에 있으면 뒤의 가벼운 요청이 대기합니다. HTTP/2는 멀티플렉싱으로 이를 해결했지만, TCP를 사용하기 때문에 패킷 유실 시 모든 스트림이 멈춥니다. HTTP/3(QUIC)만이 두 계층 모두에서 HOL 블로킹을 해결했습니다.</p>\n<p><strong>현재 지원 현황:</strong></p>\n<ul>\n<li><strong>브라우저</strong>: 크롬, 에지, 사파리 등 주요 브라우저</li>\n<li><strong>기업</strong>: 구글, 페이스북 등 주요 기업</li>\n<li><strong>CDN</strong>: 아카마이, 클라우드플레어, AWS 클라우드프론트 등</li>\n</ul>\n<h3>TCP 연결은 65,535개가 한계인가?</h3>\n<p>포트 번호는 부호 없는 16비트 정수를 씁니다. 그래서 65,535가 포트 번호의 최대값입니다.</p>\n<p><strong>하지만</strong> 한 장비에서 만들 수 있는 TCP 연결 개수는 이론적으로 <strong>2^96개</strong>입니다.</p>\n<p>TCP의 각 연결은 다음 4가지 조합으로 구분되거든요:</p>\n<ul>\n<li><strong>로컬 IP</strong></li>\n<li><strong>로컬 포트</strong></li>\n<li><strong>원격 IP</strong></li>\n<li><strong>원격 포트</strong></li>\n</ul>\n<p>하나의 로컬 IP에서 특정 원격 IP의 1개 포트에 연결할 수 있는 TCP 연결이 65,535개인 겁니다.</p>\n<blockquote>\n<p>실제로는 OS 설정(파일 디스크립터 개수, 포트 범위 설정 등)에 따라 제약을 받습니다.</p>\n</blockquote>\n<h2>웹 통신의 큰 흐름: <a href=\"http://www.google.com\">www.google.com</a> 접속 과정</h2>\n<p>면접에서 자주 나오는 질문입니다. 한 질문으로 DNS, TCP, 라우팅, 프로토콜 스택까지 다양한 개념을 확인할 수 있기 때문입니다.</p>\n<h3>1단계: 브라우저의 URL 파싱</h3>\n<p>브라우저에 <code class=\"language-text\">https://www.google.com</code>을 입력하면, 브라우저는 URL을 파싱해서 다음을 추출합니다:</p>\n<ul>\n<li>프로토콜: HTTPS</li>\n<li>도메인: <a href=\"http://www.google.com\">www.google.com</a></li>\n<li>포트: 443 (HTTPS 기본 포트)</li>\n<li>경로: / (루트)</li>\n</ul>\n<p><strong>URI와 URL의 차이</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">URI (Uniform Resource Identifier) - 리소스 식별자\n├── URL (Uniform Resource Locator) - 위치로 식별\n└── URN (Uniform Resource Name) - 이름으로 식별</code></pre></div>\n<ul>\n<li><strong>URL</strong>: <code class=\"language-text\">https://google.com/search</code> - 위치(주소)로 리소스를 찾음</li>\n<li><strong>URN</strong>: <code class=\"language-text\">urn:isbn:0451450523</code> - 고유한 이름으로 리소스를 찾음 (웹에서 거의 안 씀)</li>\n</ul>\n<p>웹에서는 거의 URL만 쓰기 때문에 URI = URL로 봐도 무방합니다.</p>\n<h3>2단계: DNS Lookup</h3>\n<p>도메인으로는 패킷을 보낼 수 없습니다. IP 주소가 필요하죠. 브라우저는 다음 순서로 IP를 찾습니다:</p>\n<ol>\n<li><strong>브라우저 DNS 캐시</strong> 확인</li>\n<li><strong>OS의 hosts 파일</strong> 확인</li>\n<li><strong>OS DNS 캐시</strong> 확인</li>\n<li><strong>DNS 서버에 질의</strong> (앞서 설명한 DNS 조회 과정)</li>\n</ol>\n<h3>3단계: 브라우저에서 OS로 전송 요청</h3>\n<p>여기서 중요한 개념이 나옵니다. <strong>브라우저는 직접 네트워크 통신을 할 수 없습니다.</strong></p>\n<p>브라우저는 User Space에서 실행되는 일반 프로세스입니다. 네트워크 하드웨어(랜카드)에 접근하려면 Kernel Space의 권한이 필요합니다. 그래서 브라우저는 <strong>시스템 콜</strong>을 통해 OS에 전송을 요청합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">┌─────────────────────────────────────┐\n│         User Space                  │\n│  ┌─────────┐  ┌─────────┐           │\n│  │ Chrome  │  │ Slack   │  ...      │\n│  └────┬────┘  └────┬────┘           │\n│       │            │                │\n│       ▼            ▼                │\n│  ┌─────────────────────────────┐    │\n│  │      System Call            │    │\n│  │  socket(), connect(), send()│    │\n│  └─────────────────────────────┘    │\n├─────────────────────────────────────┤\n│         Kernel Space                │\n│  ┌─────────────────────────────┐    │\n│  │     Protocol Stack          │    │\n│  │  (TCP/IP 처리)               │    │\n│  └─────────────────────────────┘    │\n│  ┌─────────────────────────────┐    │\n│  │     Network Driver          │    │\n│  └─────────────────────────────┘    │\n│  ┌─────────────────────────────┐    │\n│  │     NIC (랜카드)              │    │\n│  └─────────────────────────────┘    │\n└─────────────────────────────────────┘</code></pre></div>\n<p>브라우저가 직접 랜카드를 제어할 수 없습니다. 하드웨어 접근은 커널만 가능하거든요. 그래서 브라우저는 <code class=\"language-text\">socket()</code>, <code class=\"language-text\">connect()</code>, <code class=\"language-text\">send()</code> 같은 시스템 콜을 통해 OS에 \"이 데이터 좀 보내줘\"라고 요청하는 겁니다.</p>\n<h3>4단계: TCP 연결 (3-Way Handshake)</h3>\n<p>OS의 <strong>프로토콜 스택</strong>이 TCP 연결을 맺습니다. 프로토콜 스택은 OS에 내장된 네트워크 제어 소프트웨어입니다.</p>\n<p>TCP 연결은 \"브라우저 - 구글 서버\" 사이에 맺어지지만, 실제 SYN/ACK 패킷 처리는 <strong>양쪽 OS 커널</strong>이 담당합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[내 PC]                           [구글 서버]\nChrome -> Kernel(TCP) &lt;---------> Kernel(TCP) -> Nginx\n              ^                        ^\n        실제 패킷 처리는 여기서 발생</code></pre></div>\n<p><strong>TCP 스택의 구조</strong></p>\n<p>TCP 스택은 OS 커널에 내장된 <strong>TCP/IP 프로토콜 처리 소프트웨어 전체</strong>입니다. 패킷 생성, 순서 보장, 재전송, 흐름 제어 등 TCP의 모든 기능을 담당합니다.</p>\n<p>TCP 스택은 크게 두 가지 역할을 합니다:</p>\n<ol>\n<li><strong>연결 관리</strong>: SYN Queue, Accept Queue로 연결 요청을 관리</li>\n<li><strong>데이터 전송</strong>: 각 연결(소켓)마다 Send/Receive Buffer로 데이터를 버퍼링</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/57bba669b9310351688b828dd8802588/27f8b/tcp.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 94.9367088607595%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAAD9klEQVR42nWT2W9UZRiHJzEsCa1QEy0xtrOdMz3nzNp2zmyn09Lp7DNdhhm6CYkgQUValiIFKYUoEjSVVEQIFlsFJAZiuMALTZQbvfDOP+nxnZlWi+DFk9/3vd/Jm3f5HZvDY2JXe4XwPzg8TexqD76eLKFoGTO5j6BZbMQ23p/HxObSoqj+PlRfH4q3qS49jlOLbSLa1Ofiz+LSItg83jiR2B56w1aDWHyQUE8Crz+CPxAVRIOiwcgzBP5D/RvFiGHTjF5OFZwsjodYqOqczrQxn2vjfOEVFkttXCrv4qPhXVwe28mVyk6u7n2Zz2qtLI23cm2yleXJFm7u38HS5E50n7SsGz1cqbpZO57l5sFuVt6J8vXhbu68HeD+TJwbtTa+GNvGV9Xt3Kpt5/b4Nu5MbmVteit392/h/oEtPDz4EqsHtktXZr3lKNmUTimvU8x2MVzyMVr2MVI2GBvxyrmLsbJKZURl76hKdUylVlEZrwo1lYmah+lJhVpVo57L5vBFeOPAAIH3x9DeK6MfG0GbHcE/V8M5k2fHIZOWIzFa303QejRByzFh1qLlRB8tJ5O0zg3QMj/ArpMDuAMyQ4fXRD/cT2FxiuhcmdTCPpLnKyQXKmQvT9ExG+fVYybtJyK8dko4HaX9TIz2s3F2f2ix+7xF+0WL18+JS4KS0C2bccVjOOJijcQ6fWKDPtGkaH8ch6ijHhsQ2+xJ4BxM4KqTauJMW3K3qOeyNYztCv+LUwzqMnG4zaY6TboCSYzoIE4l2rg34pvZiG0YuytgCQm0uvoTqDJctxHBrTdR/TE8Mh+3Ycr9RYQbWs9lU8XYoWiGgJkmFMvRHc+jdQ/i8iYl0QCK4PY2UQOD66TWGVon3VBFl5ZdhoWSmsUoXsCTu0BH8izhvUskp28Rqtykt/YN1v4HxN98hFr6gY7cIzoLT+gs/kJn6Sn20h90Dv8l+juKrx+b4pWE1lsoySMo/UdxJWcw0mfw5RbQ04sY2Y/lfBVv/nOU9DWcqes4h27JIlZwZr7FlbmPM/ej6HfUc8mWLdTBoxi5D9Cy89iTc4RHL9M3cY3ukSXCletYEyvEJ9ZQ8yvYh1axZ77Hnn2IPfcYe/4n7MWnOPJPmhW6jQSe/kPoQzN0pY43KvSm5wkWLqKlL0mFnxAsLeEvLkuFy7iGvsSVvi0VrkqFd4UHOPOPpcJ7mypMSZv5c2jSpr1/HrPyKcmpG3SPXidcvY01fZfE1APU4j06JIFdWuzMyRwLP2Mv/Caz/FP01/UZGnHZUH2bewTZYFC2JRtz+0WDGTln5JfKiuZQQ/l1ipsoCcMNdetiG7d4R9E3E/kfzBcQRtE2aPrwbyBbkYWRlGx/AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tcp 스택 정리\"\n        title=\"\"\n        src=\"/static/57bba669b9310351688b828dd8802588/f058b/tcp.png\"\n        srcset=\"/static/57bba669b9310351688b828dd8802588/c26ae/tcp.png 158w,\n/static/57bba669b9310351688b828dd8802588/6bdcf/tcp.png 315w,\n/static/57bba669b9310351688b828dd8802588/f058b/tcp.png 630w,\n/static/57bba669b9310351688b828dd8802588/40601/tcp.png 945w,\n/static/57bba669b9310351688b828dd8802588/78612/tcp.png 1260w,\n/static/57bba669b9310351688b828dd8802588/27f8b/tcp.png 1730w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>연결 관리 큐:</strong></p>\n<ul>\n<li><strong>SYN Queue</strong>: SYN 받고 SYN-ACK 보낸 상태 (반쯤 연결된 상태)</li>\n<li><strong>Accept Queue</strong>: 3-Way 완료됐지만 아직 <code class=\"language-text\">accept()</code> 안 된 연결</li>\n</ul>\n<p><strong>데이터 전송 버퍼:</strong></p>\n<ul>\n<li><strong>Send Buffer</strong>: 애플리케이션이 보낼 데이터를 담아두는 버퍼</li>\n<li><strong>Receive Buffer</strong>: 네트워크에서 받은 데이터를 담아두는 버퍼</li>\n</ul>\n<blockquote>\n<p><strong>중요</strong>: Accept Queue는 <strong>이미 3-Way Handshake가 완료된</strong> 연결들입니다. 커널 레벨에서는 연결이 완료됐지만, 서버 애플리케이션이 아직 <code class=\"language-text\">accept()</code>를 호출하지 않아 대기 중인 상태입니다.</p>\n</blockquote>\n<p><strong>1000개 연결 시 몇 개의 큐와 버퍼가 생길까?</strong></p>\n<p>서버가 80 포트에서 <code class=\"language-text\">listen()</code>하고 1000개의 클라이언트가 연결했다면:</p>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>개수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Listen Socket</td>\n<td>1개</td>\n<td>80 포트에서 연결 대기</td>\n</tr>\n<tr>\n<td>SYN Queue</td>\n<td>1개</td>\n<td>Listen Socket당 1개</td>\n</tr>\n<tr>\n<td>Accept Queue</td>\n<td>1개</td>\n<td>Listen Socket당 1개</td>\n</tr>\n<tr>\n<td>TCP Buffer 쌍</td>\n<td>1000개</td>\n<td>연결(소켓)당 1쌍</td>\n</tr>\n</tbody>\n</table>\n<p><strong>핵심 포인트:</strong></p>\n<ul>\n<li><strong>큐는 Listen Socket당 1개</strong>: 포트 80으로 연결 요청이 오면 하나의 SYN Queue, 하나의 Accept Queue로 관리</li>\n<li><strong>버퍼는 연결당 1쌍</strong>: 1000개 연결이면 1000개의 Send Buffer + 1000개의 Receive Buffer</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">포트 80 Listen Socket\n├── SYN Queue (1개) ─────────────┐\n├── Accept Queue (1개) ──────────┤ 연결 요청 관리\n│                             \n└── 연결된 소켓들 ────────────────────┐\n    ├── Client 1: [Send] [Recv]    │\n    ├── Client 2: [Send] [Recv]    │\n    │                              │\n    ├── Client 3: [Send] [Recv]    │ 1000개의 버퍼 쌍\n    │    ...                       │\n    └── Client 1000: [Send] [Recv] ┘</code></pre></div>\n<p>Backlog가 가득 차면 새 연결 요청이 거부됩니다. 서버 튜닝할 때 다음 설정으로 큐 크기를 조절합니다:</p>\n<ul>\n<li><code class=\"language-text\">net.core.somaxconn</code>: Accept Queue 크기</li>\n<li><code class=\"language-text\">net.ipv4.tcp_max_syn_backlog</code>: SYN Queue 크기</li>\n</ul>\n<h3>5단계: 패킷 생성 및 전송</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/adbe98da5e3b97a0de6ed52f28c02f18/87488/protocol.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 89.24050632911393%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAAD40lEQVR42n3UWW8bVRTAcX+ApkFtMmN77BnbY0/GdrzFseN6TZylzuLEiZs0pGq6qUWqhOABFNSFUtKWgLoAKiWhEhU0Aipo+1KJh4gH+swTQnwHPsWf40kCSCAefjpntjNz77l3XN5gDt0cwxfsGMcfmhBH8Qcb6KFJgta0mBFNMSvmCFmtPfOE+hYw+9piES1UwmVaS9Qrm8zNPKLVfExzclt8y9z098xNPaU0uC2+ozz4A5Xcc/GCWv5HakM7jBR+ol74mdHCSxql30gm3sEVjMxSHNpgrH6X+vA9RqqfMly9T732OaO1LYYGPiOffsBQZotC9kuK2a8odl6S+4ZS/gmV/FPxTIrvEI1dxKUaCVQ9Qa+v36H4E47ePe5AEj02iJHIO/n/6dRyKUaSHj1Fr5HepafleF+KQ74E/sQRAumSkx/2J/ek/kXRk7i8wSShUJRAwCIYiBAM7jJNm3AkLmJEzBiW5BFL4j9EIrbDEn2WjS8kX1hJBrk87eXddoz3j/ezvhzj1orEBT/XJrtYb3ZzY7abW62DbMx38VG7i9vHDnDveBcPTqlsnlbYOqOyfb6bdtmPq5oMcLXp4/pykpsnMtw6keLD1TQ3jxlcnzqwV/AgH7S6/ip4Z/EAH0vBzTNuvjgrzrnZvtDNsbIPlyZDDodtzFBYmIRNIdGKWNh2XMQc0WicqB2VuCvWibbliIl4tA+/2WmKTHCPJk3R0o4eR4Yer0SvNMUt3fMP4DEGnfywRxrg/g+q1PBJU9x2CveRNEohiXJEHi6mUEtp3OUMakViLYN7eMDhqWd3jYqxQTzjHTk8E2IyhzudwdVbkiG/XiO/1iazNkfucpuBK/NkrraobaxiX2nwypsD9L5doGdtiMOXChy6PETgxiix2zPE7swQv9skcH8CZSEnCzuVwjOdxZgrYrTEfJFAu4SvXcBYKuNdLMiNgyiLOZTjeZRl8aos8hMFtNUS2qki2ukS3vMlGVVWCsocqjJ2RZNdIgvXiULdy1UtgVcWuWZknNwt9zo0ec6R+FtnDjvbRelsPX0/9jsUoQbknPCGUmjhDIqxe26fYuzr370mXN7oCGb5LFb1ApHqRazhN7Drb2GNrGGU19DLl8Q19Mo6enUDvXYbf+0T9OEHBMceEhx/hDnxmFDjOd7UOVye/mmyC+tUV+5QWZE/zeoWjQvb1E5vYzY20ccfYhz9GqPxBGPyGfrUC/TpHQLNl8SXfyG58ivZ1d+Jn/wDb/49KRjO44mOo9odR1HsBkrfFGq0idbfQku0hfw8E0toyWWxIk7K16ziSZ4SZ1AT5/CkXsNjjfIngUhXlFm8uH8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"프로토콜 스택\"\n        title=\"\"\n        src=\"/static/adbe98da5e3b97a0de6ed52f28c02f18/f058b/protocol.png\"\n        srcset=\"/static/adbe98da5e3b97a0de6ed52f28c02f18/c26ae/protocol.png 158w,\n/static/adbe98da5e3b97a0de6ed52f28c02f18/6bdcf/protocol.png 315w,\n/static/adbe98da5e3b97a0de6ed52f28c02f18/f058b/protocol.png 630w,\n/static/adbe98da5e3b97a0de6ed52f28c02f18/40601/protocol.png 945w,\n/static/adbe98da5e3b97a0de6ed52f28c02f18/78612/protocol.png 1260w,\n/static/adbe98da5e3b97a0de6ed52f28c02f18/87488/protocol.png 1282w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>프로토콜 스택이 HTTP 요청 메시지를 패킷으로 만들고, 각 계층에서 헤더를 붙입니다:</p>\n<table>\n<thead>\n<tr>\n<th>계층</th>\n<th>추가되는 정보</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>HTTP</td>\n<td>요청 메시지 (GET / HTTP/1.1)</td>\n</tr>\n<tr>\n<td>TCP</td>\n<td>출발지/목적지 포트, 시퀀스 번호</td>\n</tr>\n<tr>\n<td>IP</td>\n<td>출발지/목적지 IP 주소</td>\n</tr>\n<tr>\n<td>Ethernet</td>\n<td>MAC 주소</td>\n</tr>\n</tbody>\n</table>\n<p>완성된 패킷은 <strong>LAN 어댑터</strong>(NIC)로 전달되고, 전기 신호로 변환되어 송출됩니다.</p>\n<h3>6단계: 네트워크 경유</h3>\n<p>패킷은 여러 장비를 거쳐 목적지로 이동합니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">내 PC -> 공유기 -> ISP 라우터 -> 인터넷 코어 -> 구글 라우터 -> 구글 서버</code></pre></div>\n<p>각 라우터는 패킷의 목적지 IP를 보고 다음 경로를 결정합니다.</p>\n<h3>7단계: 서버 도착 및 응답</h3>\n<p>구글 서버에 도착한 패킷은:</p>\n<ol>\n<li><strong>방화벽</strong>이 검사</li>\n<li><strong>로드밸런서</strong>가 적절한 서버로 분배</li>\n<li>서버의 <strong>프로토콜 스택</strong>이 패킷에서 HTTP 메시지 추출</li>\n<li><strong>웹 서버</strong>(Nginx 등)가 요청 처리</li>\n<li>응답 데이터를 같은 경로로 회신</li>\n</ol>\n<h3>전체 흐름 요약</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. URL 입력\n2. DNS로 IP 획득\n3. 브라우저 -> OS (시스템 콜)\n4. OS 커널에서 TCP 3-Way Handshake\n5. HTTP 요청을 패킷으로 만들어 전송\n6. 라우터들을 거쳐 서버 도착\n7. 서버가 응답 패킷 회신\n8. 브라우저가 HTML 렌더링</code></pre></div>","wordCount":{"words":2731},"frontmatter":{"title":"네트워크 기초 정리","date":"September 17, 2025","description":"서버 개발자가 알아야 할 네트워크 기초 지식을 정리합니다."}},"previous":{"fields":{"slug":"/java/"},"frontmatter":{"title":"JVM 핵심 정리"}},"next":{"fields":{"slug":"/oneToone/"},"frontmatter":{"title":"JPA @OneToOne 양방향 관계에서 발생하는 N+1 문제 해결 방법"}}},"pageContext":{"id":"2d2d4eb1-9394-5be7-b05a-2d63b09febde","previousPostId":"181ca4df-5804-5faf-8f7d-4ce57a2b598f","nextPostId":"88c8c3ad-07c2-5c35-a23f-b46b8737daab"}},"staticQueryHashes":["3257411868","3517523002"],"slicesMap":{}}