{"componentChunkName":"component---src-templates-blog-post-js","path":"/javaGarbage/","result":{"data":{"site":{"siteMetadata":{"title":"GoToBill"}},"markdownRemark":{"id":"f60b3d8a-8c99-58c6-b386-5b2d2490e208","excerpt":"가비지 컬렉션이란? Garbage Collection(GC)은 더 이상 참조되지 않는 객체를 자동으로 메모리에서 제거하는 메커니즘입니다. C/C++에서는 개발자가 직접 /로 메모리를 관리해야 합니다. Java는 GC…","html":"<h2>가비지 컬렉션이란?</h2>\n<p><strong>Garbage Collection</strong>(GC)은 더 이상 참조되지 않는 객체를 자동으로 메모리에서 제거하는 메커니즘입니다.</p>\n<p>C/C++에서는 개발자가 직접 <code class=\"language-text\">malloc</code>/<code class=\"language-text\">free</code>로 메모리를 관리해야 합니다. Java는 GC가 자동으로 처리하므로 메모리 해제를 신경 쓰지 않아도 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">C/C++: 개발자가 직접 메모리 해제 → 실수 시 메모리 누수\nJava:  GC가 자동으로 메모리 해제 → 메모리 관리 부담 감소</code></pre></div>\n<hr>\n<h2>힙 메모리 구조</h2>\n<p>GC는 <strong>힙(Heap)</strong> 영역을 관리합니다. 힙은 객체와 배열이 저장되는 공간입니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e4c02b970833d0216f2e3c7f231c02bb/076ca/memory.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.92405063291139%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAADXUlEQVR42j2T7U9bZRjG+8kNtmnnOIe3c0p7Tk97Sk/f31sKrNC1ZYCryzpqg4wxwFpxyN4izvhGXLKwOYgMl7lhhnFmvmTRLO6DRhOTffCD8T/6+YjGD79c94fnvnJfee7bpruKmJ7TeIwaXmNK1A18nml83hn6vbOCOfzmvGARy2xi+VoEfEsEfct76nTGcTj8dHQYSJKBLWQtUz/1iLHSDunYHTKx+4IHZONfkYs/YiDxPfnEjwwmnzKU/Jmjqd8opH9nJPOH0GdikGH8/gS6HkNRAtgsX5N8dpOh3AaDmS1SUUHkM9LRu2SiO4JdsrGH5GLfCvPH/5k/Eea/MJT4CbeeR3dH6O216OryYXOGqgQLl9AzyzhSF3BmV3Hl3kcb+Bgtv442uIk2tI0+fA/96AP0wtfoI9+hF5+gjTzGqedQVb+I69nD5kw0qJzbIDq5hj76Ed7yOkZpE7WwhTpyD3X0S9TiN6ilH1DLT1Erv6JUnqEc/0von7jNIgErjWEkhHEQmxqbEI0LuIot9PJb6GOX0cZW6T12FaX0oWi6hjK2Lgw2UMdvo0zcRZn8AqX6UOguTncOzRWiu8f/b+SuUYvD9X4O1/p5sR7gyHSQjjMhpLkw0nwEaVHwepSON2JIb8aRlgUrCaTLSaQLSfp8EfoU8b7Dgyx5sfWUQoy+O0VkqUz3mRhdZ2PIc4JzgsU4cjOB3EoiL6WQz6eRVwQXM8hXssiXsvSZEQwzicsSkfUQNqkSpq81jPraID3NAY4sJLEvJLA3hbZS2JfS2Jcz2Fey2C8KruSwvz3AC1fz2Ffz9PVH0TWxMq4gPQ6xNvqwH61qoFe9eGp+vHULsxHANy2YCdI/G8I/J5gP418MYzXDBFoRAucFrSiamNDxf2QT2ytJhZuNIGtVN+8UDvLesef5oHyItcohro0f5PrkAW6cOMAn1XY2T7azdaqd7Vobn9f3sz3VRsAbxO1J43JFxGKLX57JdrP5qsmNaR/XawrrtW5uNVRu1WVuvtzGhjD49HQbt+tt3GkIo+n93J/Zx+7Z59iZ3UfIDOLxZsWl/HOCYWwJ06BgOSgEnBTDGqWIRjmqUYlpjAmOxzXGExoTSY3JlMaJtEY17eJk1sVLojb0yJ5Rp2zS2enjbykpy1NEAkAKAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"메모리 구조\"\n        title=\"\"\n        src=\"/static/e4c02b970833d0216f2e3c7f231c02bb/f058b/memory.png\"\n        srcset=\"/static/e4c02b970833d0216f2e3c7f231c02bb/c26ae/memory.png 158w,\n/static/e4c02b970833d0216f2e3c7f231c02bb/6bdcf/memory.png 315w,\n/static/e4c02b970833d0216f2e3c7f231c02bb/f058b/memory.png 630w,\n/static/e4c02b970833d0216f2e3c7f231c02bb/076ca/memory.png 914w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<table>\n<thead>\n<tr>\n<th>영역</th>\n<th>저장 내용</th>\n<th>특징</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>코드 영역</td>\n<td>실행할 프로그램 코드</td>\n<td>컴파일 시 결정</td>\n</tr>\n<tr>\n<td>데이터 영역</td>\n<td>전역 변수, static 변수</td>\n<td>프로그램 시작 시 할당</td>\n</tr>\n<tr>\n<td>힙 영역</td>\n<td>객체, 배열</td>\n<td><strong>GC 대상</strong></td>\n</tr>\n<tr>\n<td>스택 영역</td>\n<td>지역 변수, 매개변수</td>\n<td>메서드 호출 시 생성/소멸</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MemoryExample</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>                    <span class=\"token comment\">// 데이터 영역 (static 변수)</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">process</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>                  <span class=\"token comment\">// 코드 영역 (메서드 바이트코드)</span>\n        <span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>                          <span class=\"token comment\">// 스택 영역 (primitive 지역 변수)</span>\n        <span class=\"token class-name\">String</span> name <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// name(참조): 스택, String 객체: 힙</span>\n        <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>              <span class=\"token comment\">// user(참조): 스택, User 객체: 힙</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">name</code>과 <code class=\"language-text\">user</code>는 <strong>참조 변수</strong>(포인터)로 스택에 8바이트 주소가 저장됩니다.</p>\n<p>실제 객체는 힙에 생성되고, 스택의 참조 변수가 힙의 객체 주소를 가리킵니다.</p>\n<hr>\n<h2>Mark and Sweep</h2>\n<p>GC의 기본 알고리즘입니다.</p>\n<p><strong>Mark 단계</strong>: 루트 객체(GC Root)에서 시작해 참조 가능한 모든 객체를 마킹합니다.</p>\n<p><strong>Sweep 단계</strong>: 마킹되지 않은 객체를 메모리에서 제거합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">GC Root\n├── 스택의 지역 변수\n├── 메서드의 매개변수\n├── static 변수\n└── JNI 참조\n\nMark: GC Root → 참조 체인을 따라 살아있는 객체 마킹\nSweep: 마킹되지 않은 객체 제거</code></pre></div>\n<p><strong>GC Root에서 도달할 수 없는 객체 = 가비지</strong></p>\n<hr>\n<h2>세대별 가비지 컬렉션</h2>\n<p><strong>Weak Generational Hypothesis</strong>: 대부분의 객체는 생성 직후 곧바로 쓸모없어집니다.</p>\n<p>이 가설을 기반으로 힙을 <strong>Young</strong>과 <strong>Old</strong> 세대로 나눠 관리합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Heap\n├── Young Generation\n│   ├── Eden        (새 객체 할당)\n│   ├── Survivor 0  (Minor GC 생존 객체)\n│   └── Survivor 1  (Minor GC 생존 객체)\n└── Old Generation  (오래 살아남은 객체)</code></pre></div>\n<hr>\n<h2>Minor GC</h2>\n<p><strong>Young Generation</strong>에서 발생하는 GC입니다. 자주 발생하고 빠르게 끝납니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6444c0e4fc845e87b6ec50778f9cfa0c/46115/gc1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 77.84810126582278%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAADaklEQVR42mWU3W/bVBjG/T8ATdvUOfaJE9tJ/JnEduJ8tWlK2xHWdZN2031IDYOKre0mxKRJiIsJCbGtfIwLuAGhITEEXIGQoHcICf6rh8duYay7eHRk+3cev+953/co85qHTEa9A9NNoVsRn10s6B4Wdf8FZWxBOBDVNkyvB81s/8cv8Jti2DHKVgyz0UWVptKMoFVauVQjfM4se/6Xr9YYQL0LncY5b7RQMppQ3O4IDcrvj2EnfciQG5oJKq0Oo23zrydm2d/LdgS3M4KbLsMfjFEjXyZvkDfIG/UYSnlvBPFmDy9fa6LwRhuFtxLM3e6icCuF8NpYFDSUFI3VWhNytw+x18dLV0LMzdqY20vwyn4Xc4eMNqZh7d4Eg5tdhO+vonuQYnTQhfvxJgp3Iwi/hYWSd3I+NC41mtBmEcpktH0ezTsptLs8x/d6KNxj6p0Iir6xDfnaDkrTGfTNLcjpJagXrqF0fheC5yR4LjpTVcshBFcxfh2Lq5dR3NhFaXMbYroN9fwVqFszSH8IxZl+jur0ByxNfoMcPoS5/hjF5e8hJr9C1NewJF3Y/oBVbUKYPfiXj+Bff4LKxWPo/U9grz/C0spTqJNjSO8iI0zvoNS/DzH6FHpnH7L/LsTwI2jDI2j2gKk6LE5M44CGHVRXD1Hbug9j4zNoyW3yd8h/mO+XzqtQpBWyVQLopk8Fp/JzqUZwWmE3r3KJbVM2GWk5YKuc5fm9EkLx22sIonWE8QZ7ccReHFJcG0NCz7eNZA8G0TPeck75xglv1Fjl4fABkugBouARovAx4vBLdJtPkLa+ZgMv08ihYcBKu2ziHnr9D5B2jtD2H/6P/4b8t7Dq56BMtr/C5s53GI9+Qr/1CwbtY6zEf2El+YNTsUbDBg1DGjqQ1RHG0y9w7upTrI5/JPsz9Tv5PzFO/obduMRJaV2FH8/gBTfguHtwvZvwvUP4/i2m3MlTLeYRetCqCdzmDvyEfHgDbsa7b5M/yPcYNttmQauxkpRucyJszAuTw26iQOXFOL0QMmXP88JGQbW4Wjm/KC0ymUxm4kLJzqcoQ0YR5qkZzewGiSGtBCUOvqRhpdrKW0dSOt+X2fA6mYwv6s/2ZsVTzl5PRivNq2k6PU5IQkMPFi+JSnYbOWm+Wm6Ppkk+32f3/wPxfwlaX6ZD7wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Minor GC 과정\"\n        title=\"\"\n        src=\"/static/6444c0e4fc845e87b6ec50778f9cfa0c/f058b/gc1.png\"\n        srcset=\"/static/6444c0e4fc845e87b6ec50778f9cfa0c/c26ae/gc1.png 158w,\n/static/6444c0e4fc845e87b6ec50778f9cfa0c/6bdcf/gc1.png 315w,\n/static/6444c0e4fc845e87b6ec50778f9cfa0c/f058b/gc1.png 630w,\n/static/6444c0e4fc845e87b6ec50778f9cfa0c/40601/gc1.png 945w,\n/static/6444c0e4fc845e87b6ec50778f9cfa0c/78612/gc1.png 1260w,\n/static/6444c0e4fc845e87b6ec50778f9cfa0c/46115/gc1.png 1290w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>동작 과정</strong></p>\n<ol>\n<li>새 객체가 <strong>Eden</strong>에 할당됩니다</li>\n<li>Eden이 가득 차면 <strong>Minor GC</strong> 발생</li>\n<li>Eden + 현재 Survivor의 살아있는 객체가 <strong>반대편 Survivor</strong>로 이동</li>\n<li>매 Minor GC마다 S0 ↔ S1을 번갈아 사용</li>\n<li>여러 번 살아남은 객체는 <strong>Old Generation</strong>으로 승격</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[1차 Minor GC] Eden → S0 (S1은 비어있음)\n[2차 Minor GC] Eden + S0 → S1 (S0 비움)\n[3차 Minor GC] Eden + S1 → S0 (S1 비움)\n... 반복 ...\n[N회 생존] → Old Generation으로 승격</code></pre></div>\n<h3>카드 테이블</h3>\n<p>Minor GC는 Young 영역만 스캔합니다. 그런데 Old 영역의 객체가 Young 영역 객체를 참조하고 있다면 어떻게 될까요?</p>\n<p>Young 영역만 스캔하면 해당 객체가 참조되지 않는 것처럼 보여서 <strong>잘못 삭제될 수 있습니다</strong>. 그렇다고 매번 Old 영역 전체를 스캔하면 Minor GC가 느려져서 의미가 없습니다.</p>\n<p><strong>카드 테이블</strong>은 이 문제를 해결합니다.</p>\n<p><strong>Old→Young</strong> 참조가 발생하면 해당 위치를 미리 기록해두고, Minor GC 시 기록된 영역만 추가로 스캔합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/01d838c81cdcf16502e35f6294594adb/e996b/card1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.75949367088608%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACFElEQVR42o2RS2/TUBCF8yOokjhvX8fPGxzfh5+NQ9IkqJEQEkjAij0L1Eq8pG4AsQGEBCyQEH/2MHZSWtoisfg0M9eeM+fObRijKSragxCt/m20+yEMN4KhBMxZDns9Qy/RdW0IgU4VNRESw13vZRqGuRNjogBfb+BnCxhLhYMXMcw3K3TPjjB8OcetkxjNZwmaz1McnFL+JIHRIxHzquA+6TByxcjdiJgINMsY/F6G2dMcnTKFUWp0DsnpjJgTWsEY3OTwXJCw+QIsyGA7DyH97ziKX2ObvUUxPYMKvkEG7yl+RMy/gLsnaI8C6o1uFmwPIzC+hsnnsL3H0OIXyvwdyuIziuQDlPhJfKLzr9DyB/jkFfX8Q7BNy7XcEF7A4foBBnaEvqORRw4elV14PMTIVTBdSQgwT9E/4tp1/wi2aBeOH0LJEEJQs6Mw9Ascpx5Otx1EUwkroBendYwJZ5LTgLjuq8ycUwv2mMDQVugySS+m6HFo+rhComtptJhGf1/vuMirvsv0LIGGSZPy8hh3Vvch0iNYfkxOUnKS1tHmu3x85awmuMChekRrali0lwczBzJZIEpXmOolCa+QHN6FzjeQ6RrTeIlQLeo6SqqhyV9DxvshtSDzNHRc0I9LyGwNRU0VutjUAvl8Cy7m+6ZsT3oNZ0KCLglWO2F+hurqphfTCyZUUyQXVV65qb/9B/2xxG8WMXRRPBg/wgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"카드 테이블\"\n        title=\"\"\n        src=\"/static/01d838c81cdcf16502e35f6294594adb/f058b/card1.png\"\n        srcset=\"/static/01d838c81cdcf16502e35f6294594adb/c26ae/card1.png 158w,\n/static/01d838c81cdcf16502e35f6294594adb/6bdcf/card1.png 315w,\n/static/01d838c81cdcf16502e35f6294594adb/f058b/card1.png 630w,\n/static/01d838c81cdcf16502e35f6294594adb/40601/card1.png 945w,\n/static/01d838c81cdcf16502e35f6294594adb/e996b/card1.png 1050w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<table>\n<thead>\n<tr>\n<th>개념</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Card</td>\n<td>힙의 512바이트 메모리 블록</td>\n</tr>\n<tr>\n<td>Dirty Card</td>\n<td>Old→Young 참조가 있는 카드</td>\n</tr>\n<tr>\n<td>Write Barrier</td>\n<td>참조 변경 시 카드를 Dirty로 마킹</td>\n</tr>\n</tbody>\n</table>\n<p>Minor GC 시 <strong>Dirty 카드가 가리키는 영역만 추가로 스캔</strong>합니다.</p>\n<hr>\n<h2>Major GC (Full GC)</h2>\n<p><strong>Old Generation</strong>에서 발생하는 GC입니다. 드물게 발생하지만 오래 걸립니다.</p>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>Minor GC</th>\n<th>Major GC</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>대상</td>\n<td>Young Generation</td>\n<td>Old Generation (+ Young)</td>\n</tr>\n<tr>\n<td>빈도</td>\n<td>자주 발생</td>\n<td>드물게 발생</td>\n</tr>\n<tr>\n<td>속도</td>\n<td>빠름</td>\n<td>느림</td>\n</tr>\n</tbody>\n</table>\n<p><strong>동작 과정</strong></p>\n<ol>\n<li>Old Generation이 가득 차면 Major GC 발생</li>\n<li><strong>Mark</strong>: 살아있는 객체 마킹</li>\n<li><strong>Sweep</strong>: 죽은 객체 제거</li>\n<li><strong>Compact</strong> (선택): 메모리 단편화 해소</li>\n</ol>\n<hr>\n<h2>Stop-the-World</h2>\n<p>GC 실행 중에는 <strong>모든 애플리케이션 스레드가 일시 정지</strong>됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">애플리케이션 스레드: ====[정지]=====>\nGC 스레드:              [GC 실행]</code></pre></div>\n<p><strong>Minor GC</strong>: STW 시간이 짧다 (밀리초 단위)</p>\n<p><strong>Major GC</strong>: STW 시간이 길다 (수백 밀리초~초 단위)</p>\n<p>STW 시간을 줄이는 것이 GC 튜닝의 핵심입니다.</p>\n<hr>\n<h2>객체 할당 최적화</h2>\n<h3>Bump the Pointer</h3>\n<p>Eden 영역에서 빠르게 객체를 할당하는 기법입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">마지막 할당 위치를 기억 → 다음 객체는 바로 그 뒤에 할당</code></pre></div>\n<p>빈 공간을 찾지 않고 포인터만 증가시키면 되므로 매우 빠릅니다.</p>\n<h3>TLAB (Thread-Local Allocation Buffers)</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3e840b661baa16d3adce7afe1fd36eea/d8817/tla.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.10126582278481%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB3UlEQVR42o2RW2/TQBCF8y8gib3rey6O7fiyjmOnqZU0CQUVUPqAEBLqA5XoA0Ig8YIEf/1w1o1alRd4+LSz9szZMzO95zJC34oxsBMMLGLPnzB05hB+0SE9BWdawZlVsEYlhFd0mF7+kN+L5zuMJw3coEQwWTKuYPsKhpvxoaQ73ZAimlhh3NaIdzuMyjWciN8S5k/KR8GQYprpfItIXWA2W8GhuOlRkK5NK4O8qjD8rOBeH7F4+xvi0xbG1xr9byuIny1kW2FgUpDd9KxAW89ZmEA4KaSTQdCV6Z4EbcabEv0jv7/aw7u8gfm+hfhYY0CGtyvIJQXFSTBPD0jCFtPoHGG2QZRvkZd7hHQqR4oP5ZCvKXjXQH2Y4Muth/aOxd9bmD/WMH9ph8tHh8JOYbk57NECth44Z+iFDexAdTMx6FCsOKPLEuNdhvN9guiKizg2MK9rGO9qSMX/8jRDg+0afo6hmz7dMNvXC9EblC43bBcwHIVnxGAs6Fwj9eneb3rIml65fomzzRvExQZB1GCSnGEUr040dLuES+d6094J92+mVZdncUS9tDkgq3ZIFxfI6wMWfEA1LzoK3v1ZfS/4Dx4EAw7f58WfLRGwWJ9aRMc6SQZFl/g/6Lb/ABeRM/BFHvGIAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tlab\"\n        title=\"\"\n        src=\"/static/3e840b661baa16d3adce7afe1fd36eea/f058b/tla.png\"\n        srcset=\"/static/3e840b661baa16d3adce7afe1fd36eea/c26ae/tla.png 158w,\n/static/3e840b661baa16d3adce7afe1fd36eea/6bdcf/tla.png 315w,\n/static/3e840b661baa16d3adce7afe1fd36eea/f058b/tla.png 630w,\n/static/3e840b661baa16d3adce7afe1fd36eea/40601/tla.png 945w,\n/static/3e840b661baa16d3adce7afe1fd36eea/d8817/tla.png 1238w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>멀티스레드 환경에서 Bump the Pointer를 사용하면 문제가 생깁니다.</p>\n<p>여러 스레드가 동시에 Eden에 객체를 할당하면, 같은 포인터 위치에 객체를 쓰려고 경쟁합니다.</p>\n<p>이를 방지하려면 <strong>락</strong>이 필요한데, 객체 할당은 매우 빈번하게 발생하므로 락 경합이 심해져 <strong>성능이 급격히 저하됩니다.</strong></p>\n<p><strong>TLAB</strong>은 이 문제를 해결합니다. Eden 영역을 스레드별로 나눠서 <strong>각 스레드에 전용 할당 공간</strong>을 부여합니다. 각 스레드는 자신만의 포인터를 가지므로 다른 스레드와 경쟁할 필요가 없습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Thread 1 → [TLAB 1] ← Bump the Pointer (동기화 불필요)\nThread 2 → [TLAB 2] ← Bump the Pointer (동기화 불필요)\nThread 3 → [TLAB 3] ← Bump the Pointer (동기화 불필요)</code></pre></div>\n<p>각 스레드는 자신의 TLAB에서만 객체를 할당하므로 락 없이 빠르게 할당할 수 있습니다.</p>\n<hr>\n<h2>Java 버전별 기본 GC</h2>\n<table>\n<thead>\n<tr>\n<th>Java 버전</th>\n<th>기본 GC</th>\n<th>특징</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Java 8</strong></td>\n<td>Parallel GC</td>\n<td>높은 <strong>처리량</strong>(Throughput) 목표</td>\n</tr>\n<tr>\n<td><strong>Java 9~21</strong></td>\n<td>G1 GC</td>\n<td>처리량과 지연 시간의 균형</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>GC 알고리즘 비교</h2>\n<h3>Serial GC</h3>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token parameter variable\">-XX:+UseSerialGC</span></code></pre></div>\n<p><strong>단일 스레드</strong>로 GC를 수행합니다. 가장 단순한 GC입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[STW 시작]\n애플리케이션:  ──────[정지]──────────────────>\nGC Thread 1:        [Mark → Sweep → Compact]\n[STW 종료]</code></pre></div>\n<ul>\n<li>힙이 작고 CPU 코어가 1개인 환경에 적합</li>\n<li>클라이언트 애플리케이션이나 임베디드 시스템용</li>\n</ul>\n<h3>Parallel GC</h3>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token parameter variable\">-XX:+UseParallelGC</span></code></pre></div>\n<p><strong>여러 GC 스레드</strong>가 동시에 GC를 수행합니다. Serial GC의 멀티스레드 버전입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[STW 시작]\n애플리케이션:  ──────[정지]──────────────────>\nGC Thread 1:        [Eden 일부 스캔]\nGC Thread 2:        [Eden 일부 스캔]\nGC Thread 3:        [Survivor 스캔]\nGC Thread 4:        [Old 일부 스캔]\n[STW 종료]</code></pre></div>\n<ul>\n<li>Java 8의 기본 GC</li>\n<li>여러 스레드가 힙을 <strong>분할해서 병렬 처리</strong></li>\n<li><strong>처리량</strong>(Throughput)을 최대화</li>\n<li>STW 동안 모든 GC 스레드가 전력으로 작업하므로 <strong>총 GC 시간은 짧지만</strong>, STW 자체는 발생</li>\n</ul>\n<h3>G1 GC (Garbage-First)</h3>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token parameter variable\">-XX:+UseG1GC</span>  <span class=\"token comment\"># Java 9+ 기본값</span></code></pre></div>\n<p>힙을 <strong>동일 크기의 리전</strong>(Region)으로 분할하고, 가비지가 많은 리전부터 우선 정리합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">힙 구조 (전통적 GC)          힙 구조 (G1 GC)\n┌─────────────────┐        ┌──┬──┬──┬──┬──┬──┐\n│     Young       │        │E │E │S │O │O │H │\n├─────────────────┤   →    ├──┼──┼──┼──┼──┼──┤\n│      Old        │        │O │E │O │S │O │O │\n└─────────────────┘        └──┴──┴──┴──┴──┴──┘\n                           E=Eden, S=Survivor, O=Old, H=Humongous</code></pre></div>\n<p><strong>동작 방식</strong></p>\n<ol>\n<li>힙을 1~32MB 크기의 리전으로 분할</li>\n<li>각 리전은 Eden, Survivor, Old 중 하나의 역할을 동적으로 할당받음</li>\n<li><strong>가비지 비율이 높은 리전</strong>부터 먼저 정리 (Garbage-First)</li>\n<li>목표 STW 시간(기본 200ms) 내에 정리할 수 있는 리전만 선택</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[Minor GC]\n가비지 80%: Region 3 ← 우선 정리\n가비지 60%: Region 7 ← 다음 정리\n가비지 20%: Region 1 ← 나중에 정리</code></pre></div>\n<ul>\n<li>Java 9부터 기본 GC</li>\n<li><strong>예측 가능한 STW 시간</strong> 제공 (<code class=\"language-text\">-XX:MaxGCPauseMillis=200</code>)</li>\n<li>힙 4GB~32GB에서 최적</li>\n</ul>\n<h3>ZGC</h3>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token parameter variable\">-XX:+UseZGC</span> <span class=\"token parameter variable\">-XX:+ZGenerational</span>  <span class=\"token comment\"># Java 21+</span></code></pre></div>\n<p><strong>애플리케이션과 동시에</strong> GC를 수행합니다. STW가 거의 없습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">애플리케이션: ═══════════════════════════════>\n             ↑       ↑           ↑\nZGC:         [동시 Mark]  [동시 Relocate]\n             (앱 실행 중)  (앱 실행 중)\n\nSTW: 단 1ms 미만 (스레드 동기화 시점에만)</code></pre></div>\n<p><strong>핵심 기술: Colored Pointer</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d31ba55c8be2107810e880ae91f34da5/669eb/zg.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 86.0759493670886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAADD0lEQVR42o2U2WoUQRSG+yHUzJJket+m9226Z8kscRJNHI2OG15JICB6IYh4JUQhEAQJeCfqnW/kC/3+1UkkURQvPvpUVZ9Tp875qyTNKWEHQ+jdCm01Qkv5N+0z/rYuqXYBL96A6VVQrAyaU0C1c8hWCo1rv6OYWY1mFX8gc14SQVQtgcsMs3zOnz0ssrc4WvyAfGuEK3c9rCxjXHuY4OrjBMbBFM7zORr7PawclGg8q9B40Ufj5QCdQY8BmY0bDhEmE2TFHKZfYFrt4+nWCZzZBMpmBfPGCObNEazdDXQXY0TLLVi3J1i/0UNnp0Rnt0Jn0YecFJBkHiMoZwjzU1wev1sMYWc5gnAML5whzebISBRtwu+WiKMJfH8MQ+/BJMYZqplDWtdTnr1Ah4OmHKIlRzVtOUFDCdBUQjTkACukwfWmEtdzTTawrcVoXYRzPHIPlj+A7pZY05NftOjUMXpY13OsGwk3zEhKOz3ttppglUEu+oixZLgTRPmCXS7roKLbBhvUYnZ+soP+eAkvHXPTPhzWWqw3ZR9hegfdeAadqjDoZ7AUKm3JCgaYbC9RDLfhZRtc6FE6OXdL6DBCObqJgAE92j7razOwyDDtb6Mc73CzDQQFa8qv7rLL4jiyS+wEmpdjTQ0gGyJ91lZIyiNd6s7PoUdCa2m9plCnipNAD5hhyE4bMf1SETCmkIWzqJvH4wi6bIDLOnlY1f1LtFWx5qDRcYnDf4ni0tet/SXdnsGLlnCDPSjGDkx3Acffg2YuoBqC2+QO2SN3yT3o1n10g0f87xHthzWG9YT+u2yK/QCB/5q8Qhi8waB6h9n0GFl8iDR6z+8ROUYef0CRfCQnKNNP2Jp/xfXpN1TpZ1TZFwyL74jDQyGblJ3L2QzWyM34UJTwkmFtG6ydXpNeQmPtnN6A4q9ox5xLalTOS+JCi+5oDpXOWyOkEfHGiLFASOl3NGrXH7JU5aR+MM7nhX8dUGjM8itm1691JsY25XT+Av0vHdFl8TgE2ZQ64qUvZrQnvNPT2haBhUz+FyHBn8eXESDxjrxFAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"ZGC Colored Pointer\"\n        title=\"\"\n        src=\"/static/d31ba55c8be2107810e880ae91f34da5/f058b/zg.png\"\n        srcset=\"/static/d31ba55c8be2107810e880ae91f34da5/c26ae/zg.png 158w,\n/static/d31ba55c8be2107810e880ae91f34da5/6bdcf/zg.png 315w,\n/static/d31ba55c8be2107810e880ae91f34da5/f058b/zg.png 630w,\n/static/d31ba55c8be2107810e880ae91f34da5/40601/zg.png 945w,\n/static/d31ba55c8be2107810e880ae91f34da5/669eb/zg.png 1244w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>64비트 포인터에서 실제 주소로 44비트만 사용합니다.</p>\n<p>44비트면 16TB 주소 공간을 표현할 수 있어서 대부분의 서버에 충분합니다.</p>\n<p>남는 비트 중 4개를 <strong>색상 비트</strong>로 활용해서 객체 상태를 저장합니다.</p>\n<table>\n<thead>\n<tr>\n<th>색상 비트</th>\n<th>의미</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Marked0/Marked1</td>\n<td>살아있는 객체 표시 (GC 사이클마다 번갈아 사용)</td>\n</tr>\n<tr>\n<td>Remapped</td>\n<td>포인터가 새 주소를 가리킴 (참조 갱신 완료)</td>\n</tr>\n<tr>\n<td>Finalizable</td>\n<td>finalizer를 통해서만 도달 가능</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Marked vs Remapped</strong></p>\n<ul>\n<li><strong>Marked</strong>: \"이 객체는 살아있다\" (삭제 대상 아님)</li>\n<li><strong>Remapped</strong>: \"이 포인터는 새 주소를 가리킨다\" (참조 갱신 완료)</li>\n</ul>\n<p>두 비트는 서로 다른 정보입니다. Marked는 객체의 생존 여부, Remapped는 포인터의 갱신 여부를 나타냅니다.</p>\n<p><strong>ZGC 사이클</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. Mark 단계\n   - GC Root에서 도달 가능한 객체에 Marked 비트 설정\n   - \"이 객체는 살아있다\"\n\n2. Relocate 단계\n   - 살아있는 객체를 새 위치로 복사\n   - Forwarding Table에 이전 주소 → 새 주소 매핑 저장\n   - 아직 모든 포인터가 갱신되지 않음\n\n3. 참조 갱신 (Load Barrier)\n   - 객체 접근 시 색상 비트 확인\n   - Remapped가 아니면 → Forwarding Table에서 새 주소 조회 → 포인터 갱신 → Remapped 설정\n   - Remapped면 → 이미 갱신됨, 그냥 사용</code></pre></div>\n<h4>Forwarding Table</h4>\n<p>객체가 이동할 때 이전 주소와 새 주소의 매핑을 저장합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Forwarding Table\n┌─────────────────┬─────────────────┐\n│ Old Address     │ New Address     │\n├─────────────────┼─────────────────┤\n│ 0x1000          │ 0x5000          │\n│ 0x2000          │ 0x6000          │\n└─────────────────┴─────────────────┘</code></pre></div>\n<p>Load Barrier가 Remapped가 아닌 포인터를 만나면 이 테이블에서 새 주소를 조회합니다.</p>\n<p>모든 참조가 갱신되면(Remapped 상태가 되면) 해당 테이블 항목은 삭제됩니다.</p>\n<h4>Load Barrier</h4>\n<p>객체를 읽을 때마다 JVM이 자동으로 색상 비트를 확인합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Object</span> obj <span class=\"token operator\">=</span> field<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// JVM이 Load Barrier 삽입</span>\n<span class=\"token comment\">// 1. 포인터의 색상 비트 확인</span>\n<span class=\"token comment\">// 2. Remapped가 아니면 → Forwarding Table에서 새 주소 조회</span>\n<span class=\"token comment\">// 3. 포인터를 새 주소로 갱신하고 Remapped 설정</span>\n<span class=\"token comment\">// 4. 정상 진행</span></code></pre></div>\n<p><strong>기존 GC</strong>(G1, Parallel)는 객체 이동 후 <strong>모든 참조를 한 번에 업데이트</strong>해야 해서 STW가 길었습니다.</p>\n<p><strong>ZGC</strong>는 객체 접근 시점에 <strong>점진적으로 업데이트</strong>하므로 STW가 1ms 미만입니다.</p>\n<h4>ZPage</h4>\n<p>ZGC도 G1처럼 힙을 분할합니다. <strong>ZPage</strong>라는 단위를 사용합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7cefb571feb199bf99abdca02267f1f9/78612/zpa.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 74.68354430379746%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC1klEQVR42lVTSXITQRCcR5jAYKxZNPuqWbpn08hCkmUbDARgOwAfuPADrlwJglcn2S02HzJqprqruiqzynACiSidcGzmRIan9uIvntgJfSkezzJ9/s9f4pFZ4Vj7H8YYZtYg3JyhHV+i6i8wjyTRwvIrhMlbNN07yOkKZbunX8AKW0TRAs9lBrG8Rs0YN251nOU3MKxcorjcQY6XyOo13KSDn/awgwpl8xH9dAMxniOtzuDxzIk6pCzi8qyFmK5RyJ32zQkrEDBcBov9C1T7S5S7C4TVEl7cMaFA2V2gX98Qd3xsx0qkDo5ZxO2rFp9eC3y+mWgl7t80yApWeOpWcBJejA+w2ZYTCph+rV91415D0eCEqi0BN6qxGg44G4W267GGR79h85KfDgzqWFkPyxP/yLeKBzgIl+MxcfSswKPTEkenC9oDnlgURb3ekdx++QpVt0e+2sIl8fNAaqJVm4ps9Wi7uqJwOyy6K2TNlhWXPBf6jpf8FsXMqdzdCPv9Etb7Afb9hNNbkr/r4YUHgRy24scvMLQ/UVdf0cnvxA+I5hvi7JoJ64OQpMpw0hbF1Q7BesJ8ZPDAZBN5kz18qhpkvR6XKN9gWH5BIz8gyW810uIWYbaBxxxBNmiODdNrECVLBMmIuc+y5w1sV2gu1RgotZVwVlAjYDc+FbaDBWZ+TuFyzLxKt2oS6p5xQrKfkeSTWa55M50KJjdBWUt9OyUC8uxHA79r2Hxw7kkNl5Qk+QouCwk4ETaLMCyPcofqUEJ051xDKs7EPsdE+SO2UoktN+ac86c66TXUvUpu0Y0USmzI5chxapmQLfnZgfyF3CAqRr1KaiuUDfMRebPmpqz0t/KpbXI1v4PeLp88u0l7EEUnTDudoOn3DBo4j60W5A/Kdou62z3wKSTlxF1m5YulzuFQPGPGllVmhXhBpeP27/8fRMWSmPQG/e8P2Kbyq0rt39v1C7n40cFrsv/uAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"ZPage\"\n        title=\"\"\n        src=\"/static/7cefb571feb199bf99abdca02267f1f9/f058b/zpa.png\"\n        srcset=\"/static/7cefb571feb199bf99abdca02267f1f9/c26ae/zpa.png 158w,\n/static/7cefb571feb199bf99abdca02267f1f9/6bdcf/zpa.png 315w,\n/static/7cefb571feb199bf99abdca02267f1f9/f058b/zpa.png 630w,\n/static/7cefb571feb199bf99abdca02267f1f9/40601/zpa.png 945w,\n/static/7cefb571feb199bf99abdca02267f1f9/78612/zpa.png 1260w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<table>\n<thead>\n<tr>\n<th>ZPage 종류</th>\n<th>크기</th>\n<th>저장 객체</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Small</td>\n<td>2MB</td>\n<td>256KB 이하</td>\n</tr>\n<tr>\n<td>Medium</td>\n<td>32MB</td>\n<td>256KB ~ 4MB</td>\n</tr>\n<tr>\n<td>Large</td>\n<td>N x 2MB (가변)</td>\n<td>4MB 초과 (1개만 저장)</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Generational ZGC (Java 21+)</strong></p>\n<p>초기 ZGC는 세대 구분 없이 전체 힙을 동일하게 취급했습니다.</p>\n<p>Java 21부터 <strong>Generational ZGC</strong>가 도입되어 Young/Old 세대를 구분합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Young Generation          Old Generation\n┌──────┬──────┬──────┐    ┌──────┬──────┬──────┐\n│Small │Small │Medium│    │Medium│Large │Small │\n└──────┴──────┴──────┘    └──────┴──────┴──────┘\n   새 객체 할당              오래 살아남은 객체</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>비교</th>\n<th>G1 GC</th>\n<th>Generational ZGC</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>분할 단위</td>\n<td>Region (1~32MB 고정)</td>\n<td>ZPage (2MB/32MB/가변)</td>\n</tr>\n<tr>\n<td>세대 구분</td>\n<td>Eden, Survivor, Old</td>\n<td>Young, Old</td>\n</tr>\n<tr>\n<td>STW</td>\n<td>수백 ms 가능</td>\n<td>1ms 미만</td>\n</tr>\n<tr>\n<td>참조 갱신</td>\n<td>STW 중 일괄 처리</td>\n<td>Load Barrier로 점진적</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Java 21</span>\n<span class=\"token parameter variable\">-XX:+UseZGC</span> <span class=\"token parameter variable\">-XX:+ZGenerational</span>\n\n<span class=\"token comment\"># Java 23+ (기본값)</span>\n<span class=\"token parameter variable\">-XX:+UseZGC</span></code></pre></div>\n<ul>\n<li><strong>초저지연 GC</strong> (STW 1ms 미만)</li>\n<li>힙 크기와 관계없이 일정한 지연 시간</li>\n<li>수백 GB~TB 규모의 대용량 힙에 적합</li>\n<li>Java 15+ 프로덕션 사용 가능</li>\n</ul>\n<h3>Shenandoah GC</h3>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token parameter variable\">-XX:+UseShenandoahGC</span></code></pre></div>\n<p>ZGC와 마찬가지로 <strong>애플리케이션과 동시에</strong> GC를 수행합니다.</p>\n<p><strong>핵심 기술: Brooks Pointer</strong></p>\n<p>각 객체 앞에 <strong>포워딩 포인터</strong>를 추가합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">일반 객체              Shenandoah 객체\n┌─────────┐           ┌─────────────┐\n│ 객체     │           │ Forward Ptr │ ← 자기 자신 또는 새 위치\n└─────────┘           ├─────────────┤\n                      │ 객체         │\n                      └─────────────┘</code></pre></div>\n<p>객체가 이동하면 Forward Ptr만 새 주소로 갱신합니다. 이전 참조도 Forward Ptr을 통해 새 객체를 찾습니다.</p>\n<ul>\n<li>Red Hat에서 개발</li>\n<li>STW 1~10ms 범위</li>\n<li>8~64GB 중간 크기 힙에 최적</li>\n<li>OpenJDK에서 사용 가능 (Oracle JDK 미포함)</li>\n</ul>\n<h3>선택 가이드</h3>\n<table>\n<thead>\n<tr>\n<th>상황</th>\n<th>권장 GC</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>범용 애플리케이션</td>\n<td>G1 GC (기본값 사용)</td>\n</tr>\n<tr>\n<td>힙 &#x3C; 32GB</td>\n<td>G1 GC</td>\n</tr>\n<tr>\n<td>힙 > 64GB + 초저지연 필요</td>\n<td>ZGC</td>\n</tr>\n<tr>\n<td>힙 8~64GB + 저지연 필요</td>\n<td>Shenandoah</td>\n</tr>\n<tr>\n<td>높은 처리량 + 지연 덜 중요</td>\n<td>Parallel GC</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>JVM 튜닝 옵션</h2>\n<table>\n<thead>\n<tr>\n<th>옵션</th>\n<th>설명</th>\n<th>기본값</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">-Xms</code></td>\n<td>초기 힙 크기</td>\n<td>물리 메모리의 1/64</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">-Xmx</code></td>\n<td>최대 힙 크기</td>\n<td>물리 메모리의 1/4</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">-XX:NewRatio=N</code></td>\n<td>Old/Young 비율</td>\n<td>2 (Old:Young = 2:1)</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">-XX:SurvivorRatio=N</code></td>\n<td>Eden/Survivor 비율</td>\n<td>8 (Eden:S0:S1 = 8:1:1)</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">-XX:MaxGCPauseMillis=N</code></td>\n<td>목표 STW 시간 (G1)</td>\n<td>200ms</td>\n</tr>\n</tbody>\n</table>\n<h3>GC 로그 확인</h3>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Java 8</span>\n<span class=\"token function\">java</span> <span class=\"token parameter variable\">-XX:+PrintGCDetails</span> <span class=\"token parameter variable\">-XX:+PrintGCDateStamps</span> MyApp\n\n<span class=\"token comment\"># Java 9+</span>\n<span class=\"token function\">java</span> -Xlog:gc*:file<span class=\"token operator\">=</span>gc.log MyApp</code></pre></div>\n<hr>\n<h2>정리</h2>\n<table>\n<thead>\n<tr>\n<th>개념</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GC</td>\n<td>참조되지 않는 객체를 자동으로 메모리에서 제거</td>\n</tr>\n<tr>\n<td>Mark and Sweep</td>\n<td>GC Root에서 도달 가능한 객체를 마킹하고 나머지 제거</td>\n</tr>\n<tr>\n<td>세대별 GC</td>\n<td>Young(새 객체)과 Old(오래된 객체)를 분리 관리</td>\n</tr>\n<tr>\n<td>Minor GC</td>\n<td>Young Generation 대상, 자주 발생, 빠름</td>\n</tr>\n<tr>\n<td>Major GC</td>\n<td>Old Generation 대상, 드물게 발생, 느림</td>\n</tr>\n<tr>\n<td>Stop-the-World</td>\n<td>GC 중 애플리케이션 스레드 일시 정지</td>\n</tr>\n<tr>\n<td>G1 GC</td>\n<td>Java 9+ 기본, 예측 가능한 STW 시간</td>\n</tr>\n<tr>\n<td>ZGC</td>\n<td>초저지연 GC, 대용량 힙에 적합</td>\n</tr>\n</tbody>\n</table>\n<p>GC를 이해하면 메모리 문제를 진단하고 애플리케이션 성능을 최적화할 수 있습니다.</p>","wordCount":{"words":1122},"frontmatter":{"title":"Garbage Collection 핵심 정리","date":"September 10, 2025","description":"JVM의 가비지 컬렉션 동작 원리와 세대별 GC, 최적화 기법을 알아봅니다."}},"previous":null,"next":{"fields":{"slug":"/jvm-jit-compiler/"},"frontmatter":{"title":"JIT 컴파일러 심화"}}},"pageContext":{"id":"f60b3d8a-8c99-58c6-b386-5b2d2490e208","previousPostId":null,"nextPostId":"2082780b-02d4-51da-9cf9-d53183ff2475"}},"staticQueryHashes":["3257411868","3517523002"],"slicesMap":{}}