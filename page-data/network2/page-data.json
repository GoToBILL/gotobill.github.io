{"componentChunkName":"component---src-templates-blog-post-js","path":"/network2/","result":{"data":{"site":{"siteMetadata":{"title":"GoToBill"}},"markdownRemark":{"id":"200e4ba5-aeca-5981-bec6-e05f77f432f8","excerpt":"HTTP vs HTTPS HTTP는 데이터를 평문으로 전송한다. 즉, 중간에 누군가 패킷을 가로채면 내용을 그대로 볼 수 있다는 뜻이다. 로그인 정보, 결제 정보 같은 민감한 데이터가 그대로 노출될 수 있다. HTTPS는 이 문제를 해결하기 위해 HTTP에 보안 계층(SSL/TLS…","html":"<h2>HTTP vs HTTPS</h2>\n<p>HTTP는 데이터를 평문으로 전송한다. 즉, 중간에 누군가 패킷을 가로채면 내용을 그대로 볼 수 있다는 뜻이다. 로그인 정보, 결제 정보 같은 민감한 데이터가 그대로 노출될 수 있다.</p>\n<p>HTTPS는 이 문제를 해결하기 위해 HTTP에 <strong>보안 계층</strong>(SSL/TLS)을 추가한 것이다. 데이터가 암호화되어 전송되기 때문에 중간에 패킷을 가로채도 내용을 해독할 수 없다.</p>\n<h3>HTTPS가 사용하는 3가지 보안 메커니즘</h3>\n<p>HTTPS는 단순히 \"암호화\"만 하는 게 아니다. 3가지 보안 메커니즘을 조합해서 사용한다.</p>\n<table>\n<thead>\n<tr>\n<th>메커니즘</th>\n<th>목적</th>\n<th>사용 시점</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>제3자 인증</strong></td>\n<td>서버가 진짜인지 확인</td>\n<td>인증서 검증</td>\n</tr>\n<tr>\n<td><strong>공개키 암호화</strong>(비대칭키)</td>\n<td>비밀키를 안전하게 공유</td>\n<td>핸드셰이크</td>\n</tr>\n<tr>\n<td><strong>비밀키 암호화</strong>(대칭키)</td>\n<td>실제 데이터 암호화</td>\n<td>통신 전체</td>\n</tr>\n</tbody>\n</table>\n<p>왜 공개키 암호화와 비밀키 암호화를 둘 다 쓸까? 공개키 암호화는 안전하지만 느리고, 비밀키 암호화는 빠르지만 키를 어떻게 공유할지가 문제다. 그래서 <strong>처음에 공개키로 비밀키를 안전하게 공유</strong>하고, <strong>이후 통신은 빠른 비밀키로</strong> 진행한다.</p>\n<hr>\n<h2>SSL/TLS Handshake 과정</h2>\n<p>TCP 3-way handshake가 끝나면 SSL Handshake가 시작된다. 이 과정을 통해 클라이언트와 서버는 암호화 통신에 사용할 비밀키를 안전하게 공유한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/5ebee2c8c804a0425863b42af599674e/c1b63/tls.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 105.69620253164558%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC3ElEQVR42oVUSXLbMBDUM2ItJMFFIEhwJyVKsuRItpPKwQdX5ZpKzqm8IXl6ZwZcbFkq+9AkMAAas/RgMhU5PtkpXLVBvv6KmShw42TnsHu8svGZhV+j3HyDCNfGxlwT/szcAo5ssEz2ZtNMVliEtYETt/DSrYHQ7Wi34zWmbm5IBrKRkDH3Ciy8EnPaJLMaQdoYhMUautkhrreQNB7sQb7C3C9hB3TpsjFOnRHOek+ZMIwy+LKDjApESW0gVTHa3WVmnHDkyqRrTs6cE7ovhErnCFQHGZcdYVqb8WD3wy4ql/LnRZvLkKci6z0lr+iAJzvwwVDXUElD42K0u3IgbI2HZ4Ts3cKvYC9XlMcCKk4RhC8hK10iJO9kRN6RbVjjcxwyV/mMkIvhqjVV+RYWJXlBFbSTlrCBX+5HiGwHS7dmzS13YyEuqjxoi8PmP9/M4SiSisr20NXR/NP6DrrY9/ke1FGOxGc5ZM9c1ZoN86CCRVr02RPSoYjW9GfJbIxtsaR10uK0v3ggP8sh58KPtobQjhoS7gqWajrwPGrGOa+JtO0I3auEJGoSKZff5FARGeexh9Xj9VxkVFkmo1adXusUJmUyDsEjeQj5AWgPR8Nn7KudwokWLOwMSZaRTN7HUmVGHR6lKdC3mF12ClXLq0xOTKdEPfrOeDv3Vd6naQvn7Wtj8cPgakKEqU1wUvon9GQl3ZhwczFnaEwtRZBkozFFOOFNjn6APv5GdPoLUf1CkN3Ra/JAOBHue5xe5sUDZPkIt3hC9PkP1OkfrOSZLoiIkG6bBfTWFc8Q5Q/Y+gl+eoCr9+/gABHvSEpHeOV3iPon5uEDeZlg4pBI8/qAmGTA/ekEGSyf38bcwKbxdZBefVr3NGxKlRN078FEkOLX+0fUmy/IV/eo2kdkzRFxcUBS3cEjTbphcxViHHd7uEgTi9pMpjtIegiWemP+MtkaqOy2OyjrD+ESLL/Ef7uQbmynjxaUAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tls\"\n        title=\"\"\n        src=\"/static/5ebee2c8c804a0425863b42af599674e/f058b/tls.png\"\n        srcset=\"/static/5ebee2c8c804a0425863b42af599674e/c26ae/tls.png 158w,\n/static/5ebee2c8c804a0425863b42af599674e/6bdcf/tls.png 315w,\n/static/5ebee2c8c804a0425863b42af599674e/f058b/tls.png 630w,\n/static/5ebee2c8c804a0425863b42af599674e/40601/tls.png 945w,\n/static/5ebee2c8c804a0425863b42af599674e/c1b63/tls.png 1200w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>단계별 설명</h3>\n<p><strong>1. Client Hello</strong>\n클라이언트가 지원하는 암호화 방식 목록과 <strong>Client Random</strong>(랜덤 데이터)을 서버에 전송한다.</p>\n<p><strong>2. Server Hello + 인증서 전송</strong>\n서버가 암호화 방식을 선택하고, <strong>Server Random</strong>과 함께 자신의 인증서를 보낸다. 이 인증서 안에 서버의 공개키가 들어있다.</p>\n<p><strong>3. 인증서 검증</strong>\n클라이언트는 받은 인증서가 신뢰할 수 있는 <strong>CA</strong>(인증기관)가 발급한 것인지 확인한다. 브라우저에는 주요 CA들의 공개키가 미리 내장되어 있어서, CA의 서명을 검증할 수 있다.</p>\n<p><strong>4. Pre-Master Secret 전송</strong>\n클라이언트가 <strong>Pre-Master Secret</strong>을 생성하고, <strong>서버의 공개키로 암호화</strong>해서 전송한다. 서버만 자신의 개인키로 이를 복호화할 수 있다.</p>\n<p><strong>5. Session Key 생성</strong>\n양쪽 모두 <strong>Client Random + Server Random + Pre-Master Secret</strong>을 조합해서 동일한 <strong>세션 키</strong>(대칭키)를 생성한다.</p>\n<p><strong>6. 암호화 통신 시작</strong>\n이후 모든 HTTP 데이터는 이 세션 키로 암호화되어 전송된다.</p>\n<h3>왜 Random 데이터가 필요한가?</h3>\n<p>Pre-Master Secret만 사용하면 같은 값을 재사용할 경우 동일한 Session Key가 생성된다. 매 연결마다 다른 Random 값을 사용하면:</p>\n<ul>\n<li><strong>재생 공격 방지</strong>: 공격자가 이전 통신을 녹화해서 재전송해도, Random 값이 다르므로 Session Key가 달라진다</li>\n<li><strong>세션 고유성</strong>: 같은 서버에 여러 번 연결해도 각 세션이 독립적으로 동작한다</li>\n<li><strong>예측 불가능</strong>: 공격자가 Session Key를 추측할 수 없다</li>\n</ul>\n<h3>핵심 포인트</h3>\n<ul>\n<li>인증서는 <strong>CA의 개인키로 서명</strong>되어 있고, <strong>CA의 공개키로 검증</strong>한다</li>\n<li>Pre-Master Secret은 <strong>서버의 공개키로 암호화</strong>하고, <strong>서버의 개인키로 복호화</strong>한다</li>\n<li>실제 통신은 <strong>세션 키</strong>(대칭키)로 암호화한다</li>\n</ul>\n<hr>\n<h2>HTTP 메서드</h2>\n<p>HTTP 메서드는 클라이언트가 서버에 <strong>어떤 동작을 요청하는지</strong>를 나타낸다.</p>\n<h3>주요 메서드</h3>\n<table>\n<thead>\n<tr>\n<th>메서드</th>\n<th>역할</th>\n<th>CRUD</th>\n<th>특징</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>GET</strong></td>\n<td>리소스 조회</td>\n<td>R</td>\n<td>캐싱 가능, Body 없음</td>\n</tr>\n<tr>\n<td><strong>POST</strong></td>\n<td>리소스 생성</td>\n<td>C</td>\n<td>멱등성 없음</td>\n</tr>\n<tr>\n<td><strong>PUT</strong></td>\n<td>리소스 전체 수정/생성</td>\n<td>C, U</td>\n<td>리소스 없으면 생성</td>\n</tr>\n<tr>\n<td><strong>PATCH</strong></td>\n<td>리소스 부분 수정</td>\n<td>U</td>\n<td>일부 필드만 수정</td>\n</tr>\n<tr>\n<td><strong>DELETE</strong></td>\n<td>리소스 삭제</td>\n<td>D</td>\n<td>리소스 없어도 동일 동작</td>\n</tr>\n</tbody>\n</table>\n<h3>GET vs POST 차이</h3>\n<p><strong>GET 요청</strong></p>\n<ul>\n<li>서버에 존재하는 정보를 <strong>조회</strong>한다</li>\n<li>Request Body를 사용하지 않는 것이 관례. 레거시 시스템은 Body가 있으면 거부하기도 함</li>\n<li>응답이 <strong>캐싱</strong>될 수 있음</li>\n<li>같은 요청을 여러 번 해도 결과가 같다. 멱등성</li>\n</ul>\n<p><strong>POST 요청</strong></p>\n<ul>\n<li>서버에 새로운 리소스를 <strong>생성</strong>한다</li>\n<li>Request Body에 데이터를 담아 전송</li>\n<li>서버 상태를 변경하므로 <strong>멱등성이 없음</strong>. 같은 요청을 두 번 하면 두 개가 생성됨</li>\n</ul>\n<h3>알아두면 좋은 메서드</h3>\n<ul>\n<li><strong>OPTIONS</strong>: 해당 URI에서 서버가 허용하는 메서드 목록 확인. CORS preflight에서 사용</li>\n<li><strong>HEAD</strong>: GET과 동일하지만 Body 없이 헤더만 반환</li>\n</ul>\n<h3>보안 관점</h3>\n<p>불필요한 HTTP 메서드는 비활성화하는 것이 좋다. 예를 들어 PUT, DELETE가 필요 없는 API라면 해당 메서드를 허용하지 않는 <strong>Whitelist 방식</strong>으로 관리한다. HTTP Method 취약점으로 검색하면 관련 보안 이슈를 확인할 수 있다.</p>\n<hr>\n<h2>REST API</h2>\n<p>REST는 HTTP URI로 <strong>자원을 표현</strong>하고, HTTP Method로 <strong>자원에 대한 행위를 표현</strong>하는 아키텍처 스타일이다.</p>\n<h3>특징</h3>\n<ul>\n<li><strong>사람이 읽을 수 있는 API</strong>: <code class=\"language-text\">/users/123</code>을 보면 \"123번 유저\"라는 것을 직관적으로 알 수 있다</li>\n<li><strong>HTTP 활용</strong>: HTTP의 특성인 캐싱, 상태 코드 등을 그대로 사용</li>\n<li><strong>별도 인프라 불필요</strong>: HTTP만 있으면 됨</li>\n</ul>\n<h3>단점</h3>\n<ul>\n<li><strong>명확한 표준이 없음</strong>: 회사마다, 개발자마다 구현이 다름</li>\n<li><strong>완전한 REST 구현이 어려움</strong>: Roy Fielding이 정의한 REST의 모든 조건을 만족시키기는 매우 어렵다 (\"그런 REST API로 괜찮은가\" 발표 참고)</li>\n</ul>\n<h3>HATEOAS</h3>\n<p>REST의 제약 조건 중 하나로, 응답에 <strong>관련 동작의 URI를 함께 제공</strong>하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"id\"</span><span class=\"token operator\">:</span> <span class=\"token number\">123</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"John\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"links\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span> <span class=\"token property\">\"rel\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"self\"</span><span class=\"token punctuation\">,</span> <span class=\"token property\">\"href\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"/users/123\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span> <span class=\"token property\">\"rel\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"orders\"</span><span class=\"token punctuation\">,</span> <span class=\"token property\">\"href\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"/users/123/orders\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span> <span class=\"token property\">\"rel\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"delete\"</span><span class=\"token punctuation\">,</span> <span class=\"token property\">\"href\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"/users/123\"</span><span class=\"token punctuation\">,</span> <span class=\"token property\">\"method\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"DELETE\"</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>클라이언트는 하드코딩된 URI 대신 응답에 포함된 링크를 따라가면 되므로, API 변경에 유연하게 대응할 수 있다.</p>\n<hr>\n<h2>CORS (Cross-Origin Resource Sharing)</h2>\n<p>CORS는 <strong>서로 다른 출처(Origin) 간에 리소스를 공유</strong>하는 메커니즘이다.</p>\n<h3>왜 기본적으로 차단하는가?</h3>\n<p><strong>CSRF</strong>(Cross-Site Request Forgery) 공격을 막기 위해서다.</p>\n<p>예를 들어, 사용자가 <code class=\"language-text\">bank.com</code>에 로그인한 상태에서 악성 사이트 <code class=\"language-text\">evil.com</code>을 방문했다고 하자.</p>\n<p><code class=\"language-text\">evil.com</code>의 스크립트가 <code class=\"language-text\">bank.com/transfer?to=hacker&amp;amount=1000000</code> 같은 요청을 보낸다면?</p>\n<p>브라우저는 <strong>요청의 목적지 도메인을 보고 해당 도메인의 쿠키를 자동으로 첨부</strong>한다. <code class=\"language-text\">evil.com</code>이 쿠키를 \"읽는\" 게 아니라, 브라우저가 <code class=\"language-text\">bank.com</code>으로 가는 요청에 <code class=\"language-text\">bank.com</code> 쿠키를 알아서 붙이는 것이다. 그래서 사용자 모르게 인증된 요청이 실행될 수 있다.</p>\n<p>Same-Origin Policy는 이런 공격을 방어한다. <code class=\"language-text\">evil.com</code>에서 <code class=\"language-text\">bank.com</code>으로 요청을 보내면, 브라우저가 <strong>응답을 차단</strong>해버린다. 다만 요청 자체는 서버에 도달할 수 있어서, 추가로 CSRF 토큰 같은 방어가 필요하다.</p>\n<h3>정상 요청</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b9fcaae02e3bb25c85607a8330ab6ffc/efa1a/csrf_normal.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.65822784810127%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACS0lEQVR42nWS227TQBCG/QaAmsTxIbbj0/oUe+3EsR2nIW1AgqpVbyuhcrgBCYk3oUL0hsf9md0kKKBy8Wl2dmf+nZldZWTNMLJyqPae4SSDn/VoXt6iWl1hublFfX4jWayvJel8B5F3zDlF0aYcp4hAmy2RVJdgxUbaI3F5gVn9Wl74X0Ev7RBQgJt0cEho7BQYUvDATCVnRnKA1gdfdCHinkIZ6AxDI5IMDIaRGUOzM6hWijGhOxn5KQyyupNKxLmIO+YdGZkJlGcDG8+HDl6MppKzsQfdjsEihjRhyGcR2RAlT8DzCAntaVYk4445EtI400Iok6CC6Zc0kwz7B5pRS1SdqFJUQlWq1t7uyeT5abx6sALFjVdwox66W5MIzYEGK6wq18Vfe3JOp3v0O8Se6tKDeLm0ShC9x7p7QFs/YuJfQqUZjem1x9NC4kRLTOnBxKPZtFad4s+Z5nCoaYHg3RbR1zfQrxooUfIRffuAZv4TVriDHhTEHBqNwYpJLK3B8hJRUUmcuKKzimIqGCIuKzG9W8P7stsLsuQDCX4nwR9SUAtyaF6FscdhhnOqrgWblYhzjmjGMQm47ECjc1lhXMC928D/TIJvSTAMP2HdPqKtfsF0L6BOU9mWQHM57LiBG5cIMw5GGF5J+3sMly5OOfz7Ldg3avlatHz+CunmBsn5NYJ+A7ftwNZ042pN9NK36gZ6OYdeLWDO/6FeYNIvYW1bGOQrASUFXQefEv2uh9eswEg46HqJ8J1FA4PT9yLRpzAKgtOFSYnfMUmBPVbmWgMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"csrf 정상\"\n        title=\"\"\n        src=\"/static/b9fcaae02e3bb25c85607a8330ab6ffc/f058b/csrf_normal.png\"\n        srcset=\"/static/b9fcaae02e3bb25c85607a8330ab6ffc/c26ae/csrf_normal.png 158w,\n/static/b9fcaae02e3bb25c85607a8330ab6ffc/6bdcf/csrf_normal.png 315w,\n/static/b9fcaae02e3bb25c85607a8330ab6ffc/f058b/csrf_normal.png 630w,\n/static/b9fcaae02e3bb25c85607a8330ab6ffc/40601/csrf_normal.png 945w,\n/static/b9fcaae02e3bb25c85607a8330ab6ffc/78612/csrf_normal.png 1260w,\n/static/b9fcaae02e3bb25c85607a8330ab6ffc/efa1a/csrf_normal.png 2040w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>csrf 토큰을 통한 방어</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/895c70e53353f14c62931037a2fcb559/ac307/csrf_defense.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 77.84810126582278%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAACyElEQVR42o1Ty3LTQBBUUVw4EAhxbMmWVtJq9bBl+SXL7yR2SIpQqaKgCOEDyIEDV258Ale+t+ld2YEbHFqzOzvTOz2zspqigEbLHxjrqhJFdY3z63ssdx9Qrm8NNlefsH59h9XlR7NebN/DDkYm729YbTlGJxqjHfKQhHY4hBdXkL0VsUSQzQ1Uf40oXxl/lK/NmR0M/5AFNSw/ncHrLtAIx3gp6sNTr2/QcPNHnHR6j9D7Uy83sbYmc6my3UerU8ByRR8PcR8/yyW+xwUaDGjz5jatoHzFSlRvYazszhERXjQxRDrO9gsEtyv0Hm4g7jawOnTchj18IdldmMOmbI++ju4nk3w5gs+WaOuFe1CazvP2sFcTuDdzOBdTWMd2jCenEtZJiKdNieOWRLOTwPF7JO+i5WVoul1IpaBUiFCGSBIJEUR4sY8/Pgpw9MzDq+fkcSh5ywrvkwHessIG91qGwyo8NYGflMQUfjxBmE4gM70eM4Y9EzWcagxvN4OzKjkUyvoW5/g1nuOHYqM5GEGfS8khpUZxiTitoJIKEaE4RBlPKXuEgPJFOED4bo386w38z2ewZt0KV+UFtqMNdrSXww2uad9UO1xNzrEdrLBgdXM1xjyusTCYGCwTnvHiuRxiwj5bkp+E0g6IeahtRqkpqzM+xqh/QMdIvmFLUEYy2CAdnhmbsEKRTuEwoB3Vj77DZ6Kh9/WPsF/v4Uht6xhLsIqMJPqN+VwHHIBgVR4DDzjsZTZD0l+afZwvTaxiXlqszJnLGEtPMqEjZqC2h7XK6302WJtJe+yXpA1YvWDf/KwyftHl1JN67SpNqPvExLRYI2WyrrY7OjMI0so8GUEyfbFIy9oSAX0ubUoiFZdmrVFL1j0sNBmJiJDlayKdbAgYY5Dp6krTGhnrqkvkrDjVsXF9mdVhQ8V+c0jUvfhfiP2l7n6AvwGDy9l9nPAtDgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"csrf 방어\"\n        title=\"\"\n        src=\"/static/895c70e53353f14c62931037a2fcb559/f058b/csrf_defense.png\"\n        srcset=\"/static/895c70e53353f14c62931037a2fcb559/c26ae/csrf_defense.png 158w,\n/static/895c70e53353f14c62931037a2fcb559/6bdcf/csrf_defense.png 315w,\n/static/895c70e53353f14c62931037a2fcb559/f058b/csrf_defense.png 630w,\n/static/895c70e53353f14c62931037a2fcb559/40601/csrf_defense.png 945w,\n/static/895c70e53353f14c62931037a2fcb559/78612/csrf_defense.png 1260w,\n/static/895c70e53353f14c62931037a2fcb559/ac307/csrf_defense.png 2058w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>그럼 CORS는 언제 필요한가?</h3>\n<p>프론트엔드(<code class=\"language-text\">localhost:3000</code>)에서 백엔드 API(<code class=\"language-text\">localhost:8080</code>)를 호출하는 건 일상적인 일이다. 하지만 포트가 다르면 다른 출처로 간주되어 Same-Origin Policy에 걸린다.</p>\n<p>CORS는 서버가 \"이 출처는 접근을 허용해\"라고 명시적으로 알려주는 방법이다. 신뢰할 수 있는 출처만 허용 목록에 추가하면, 보안을 유지하면서 필요한 크로스 오리진 요청을 허용할 수 있다.</p>\n<h3>Preflight Request</h3>\n<p>브라우저는 실제 요청을 보내기 전에 <strong>OPTIONS 메서드로 사전 요청</strong>을 보낸다. 이를 <strong>Preflight Request</strong>라고 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">OPTIONS /api/users HTTP/1.1\nOrigin: https://frontend.com\nAccess-Control-Request-Method: POST</code></pre></div>\n<p>서버가 CORS를 허용하면 아래와 같이 응답한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">HTTP/1.1 200 OK\nAccess-Control-Allow-Origin: https://frontend.com\nAccess-Control-Allow-Methods: GET, POST, PUT, DELETE</code></pre></div>\n<p>이 응답을 받은 후에야 브라우저는 실제 요청을 보낸다.</p>\n<h3>Simple Request vs Preflight</h3>\n<p>모든 cross-origin 요청에 Preflight가 발생하는 건 아니다. <strong>Simple Request</strong> 조건을 만족하면 Preflight 없이 바로 요청이 간다.</p>\n<p><strong>Simple Request 조건</strong> (모두 만족해야 함)</p>\n<table>\n<thead>\n<tr>\n<th>조건</th>\n<th>허용 값</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>메서드</strong></td>\n<td>GET, HEAD, POST만</td>\n</tr>\n<tr>\n<td><strong>Content-Type</strong></td>\n<td><code class=\"language-text\">application/x-www-form-urlencoded</code>, <code class=\"language-text\">multipart/form-data</code>, <code class=\"language-text\">text/plain</code>만</td>\n</tr>\n<tr>\n<td><strong>헤더</strong></td>\n<td>Accept, Accept-Language, Content-Language, Content-Type만</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Preflight가 필요한 경우</strong> (위 조건 중 하나라도 벗어나면)</p>\n<ul>\n<li><code class=\"language-text\">Content-Type: application/json</code> 사용</li>\n<li><code class=\"language-text\">Authorization</code> 헤더 사용</li>\n<li>커스텀 헤더 사용 (예: <code class=\"language-text\">X-Custom-Header</code>)</li>\n<li>PUT, DELETE, PATCH 메서드 사용</li>\n</ul>\n<p><strong>왜 이렇게 나눴을까?</strong></p>\n<p>HTML <code class=\"language-text\">&lt;form></code> 태그는 Same-Origin Policy 이전부터 cross-origin 요청이 가능했다. 하위 호환성을 위해 이 범위의 요청은 Simple Request로 허용한다.</p>\n<p>반면 <code class=\"language-text\">fetch()</code>로 JSON을 보내거나 커스텀 헤더를 붙이는 건 JavaScript에서만 가능한 동작이므로, Preflight로 서버 허락을 먼저 받아야 한다.</p>\n<h3>주요 CORS 헤더</h3>\n<table>\n<thead>\n<tr>\n<th>헤더</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">Access-Control-Allow-Origin</code></td>\n<td>허용할 출처 (<code class=\"language-text\">*</code>는 모든 출처)</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Access-Control-Allow-Methods</code></td>\n<td>허용할 HTTP 메서드</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Access-Control-Allow-Headers</code></td>\n<td>허용할 요청 헤더</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Access-Control-Allow-Credentials</code></td>\n<td>인증 정보(쿠키 등) 포함 허용 여부</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>OSI 7계층과 TCP/IP 4계층</h2>\n<p>네트워크 통신을 이해하려면 계층 구조를 알아야 한다. OSI 7계층은 이론적 표준이고, 실제로는 TCP/IP 4계층을 많이 사용한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/aa20b91b83331a44d433c260b6470d0a/5eb90/osi.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 99.36708860759494%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAABYlAAAWJQFJUiTwAAAENElEQVR42pWUWYxTZRTHb4z6RAYzDO107+2+3tv2drpM92VmnA62BWZfpCKMoqIhhgdQI9G4oQkhGIgIguJIkAQd0BglYnwwPhhjYkzQN5cnffb959feBhU1wYeT3O373XPO/3+OZHREGLL5sPk1vGoJj5Jns93Xe2Z0KP8aQzY/Fk+coFbvfS+HM2yyeTA4wkgWVw6PfxZvYBl/aCf+4C4CwVVxv9IHRP8CizLsiOHytfAFlsT39/XOBEK7xbndWF0FJI9/hnTsdSr5NWbaH7G1cZVq5nMKqfUeZNgZwySLcMZ79yZnEk19gWzyJK3Gu0y3rlDLr1NKXRWJLSC5fE2S6hFy6ePUi29RK5ynmH6PTOJ0D2CwR7H70ti8KQFXdWDsFfKpM4yVLjBRWRdnPqSSuSaqWkKSvW1S8ROkEq+RSZ5hdORtStn3yaZP6WU6FQHM9OERHagcJq2eIq2cIaueJx+/RDn5MR7vPJI/eD/FkWtsqX/BjvnvWJn9gXtqPzFe+kpA1F5WFndSh9tFuBTMY1kszSLmdhHLTBnLQg3rjnFM8WS35G0iszfIZ89SFuXWShdFfEBu9LQuQrdMOYFRVjG7RR/dCoPLMQZWVfxPNIg/P8PggVE2HspiKGpIwfAqk9VvmRr7hsW568xNf8/c3C+0t3+pi9AVRI5jFjbpwo2ygquh4plRCC1qqDtGCHQ0grs0rFoMKRzZS6v+M3PNH3l09VdWO7/RWfyd+ZnrN+xicgmoOyZ8pmCVozxcNHCwfhfPNK28NOvixeYAR6c3kFc9woeRHN7GAt4tC3iaS3i3rxBc2olv23zfNgIosrOI3llcKjY5wsGJAV7ecjvH7zVxdo+bk4u3sdaRqGlOJEMmysadAYYeVFCevhv3U2UGDihs2pfQgSK7LtTqivYsZBJlp9JlcvkJRnOT5AtNipUFqmMd3KE8kjERxzSfxLycwvdABdeeEuaHspg72b5VhG08MazeZK+Hw7LGcG4/rsmjKNNrRGaviGo+xdD4muFoBykZ9vFI1cDeuoHHJ43sbwxxqD3IvoaxPxlR5FBaKKzpGQvF7Zm9eGrPkmi9Sqx1msDUOzjG1zGHZ5EqMZnDU3dwZNsG1h6L8eaqhXPLEsfm7xRzKwDCOjZ/Wle4P9ddqNGpsdkhQhjdII+I1qR6vpWCIZV2OU67kmJrbZTp8QJLjTLterGvshBCjN7fNo7oZS96P4joYY/03knDoUmMhSexVg+jTp/D27yIYewTjNVLfcsIhcUc64CbV5l6Uyhd20xhrzyHd+IYybkLRLdfxjH1mejJ5RvGNrsS/wH8Z0hm0Q+nr4DDVxJRweEXSzPSEBYY00evOyn/B2gVzZbFhc+jUSm3SKdqBMX2DgVTfQH6I3cLML1kkYEsLOH2jqAmqoSVotjGGbHbMn8KcIuwLvAPmzWZQyNUUnoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"osi\"\n        title=\"\"\n        src=\"/static/aa20b91b83331a44d433c260b6470d0a/f058b/osi.png\"\n        srcset=\"/static/aa20b91b83331a44d433c260b6470d0a/c26ae/osi.png 158w,\n/static/aa20b91b83331a44d433c260b6470d0a/6bdcf/osi.png 315w,\n/static/aa20b91b83331a44d433c260b6470d0a/f058b/osi.png 630w,\n/static/aa20b91b83331a44d433c260b6470d0a/40601/osi.png 945w,\n/static/aa20b91b83331a44d433c260b6470d0a/78612/osi.png 1260w,\n/static/aa20b91b83331a44d433c260b6470d0a/5eb90/osi.png 1612w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>계층별 역할과 헤더 구조</h3>\n<p>각 계층은 <strong>자신만의 헤더</strong>를 가진다. 데이터가 전송될 때 위에서 아래로 내려가면서 각 계층의 헤더가 추가된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[Ethernet Header] + [IP Header] + [TCP Header] + [HTTP Data]\n      L2              L3            L4             L7</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>계층</th>\n<th>헤더</th>\n<th>핵심 정보</th>\n<th>역할</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>L2</strong></td>\n<td>Ethernet Header</td>\n<td><strong>MAC 주소</strong></td>\n<td>같은 네트워크 내에서 다음 장비까지 전달</td>\n</tr>\n<tr>\n<td><strong>L3</strong></td>\n<td>IP Header</td>\n<td><strong>IP 주소</strong></td>\n<td>최종 목적지까지 경로 결정</td>\n</tr>\n<tr>\n<td><strong>L4</strong></td>\n<td>TCP/UDP Header</td>\n<td><strong>포트 번호</strong></td>\n<td>어떤 프로세스에 전달할지 결정</td>\n</tr>\n<tr>\n<td><strong>L7</strong></td>\n<td>-</td>\n<td><strong>HTTP 데이터</strong></td>\n<td>애플리케이션이 실제로 사용하는 데이터</td>\n</tr>\n</tbody>\n</table>\n<h3>각 계층이 하는 일</h3>\n<p><strong>L2 Data Link</strong> - \"다음 장비로 전달\"</p>\n<ul>\n<li><strong>MAC 주소</strong>로 같은 네트워크 내의 다음 장비를 찾는다</li>\n<li>라우터를 거칠 때마다 <strong>MAC 주소가 바뀐다</strong> (다음 hop의 MAC으로 변경)</li>\n<li>스위치가 이 계층에서 동작</li>\n</ul>\n<p><strong>L3 Network</strong> - \"최종 목적지까지 경로 결정\"</p>\n<ul>\n<li><strong>IP 주소</strong>는 출발지부터 목적지까지 <strong>변하지 않는다</strong></li>\n<li>라우터가 IP 주소를 보고 어느 방향으로 보낼지 결정</li>\n<li>라우터가 이 계층에서 동작</li>\n</ul>\n<p><strong>L4 Transport</strong> - \"어떤 프로세스로 전달?\"</p>\n<ul>\n<li><strong>포트 번호</strong>로 같은 IP의 여러 프로세스 중 어디로 보낼지 결정</li>\n<li>TCP: 신뢰성 보장 (순서, 재전송)</li>\n<li>UDP: 빠르지만 신뢰성 없음</li>\n</ul>\n<p><strong>L7 Application</strong> - \"실제 데이터 처리\"</p>\n<ul>\n<li>HTTP, FTP, SMTP 등 애플리케이션 프로토콜이 동작</li>\n<li>사용자가 실제로 주고받는 데이터를 처리</li>\n</ul>\n<h3>택배 비유로 이해하기</h3>\n<table>\n<thead>\n<tr>\n<th>계층</th>\n<th>택배 비유</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>L7</strong></td>\n<td>택배 박스 안의 <strong>실제 물건</strong></td>\n</tr>\n<tr>\n<td><strong>L4</strong></td>\n<td>아파트 <strong>동/호수</strong> (같은 주소지만 어느 집인지)</td>\n</tr>\n<tr>\n<td><strong>L3</strong></td>\n<td>배송 <strong>주소</strong> (목적지까지 변하지 않음)</td>\n</tr>\n<tr>\n<td><strong>L2</strong></td>\n<td><strong>중간 경유지</strong> 주소 (물류센터 → 허브 → 대리점, 계속 바뀜)</td>\n</tr>\n</tbody>\n</table>\n<p><strong>핵심</strong>: IP 주소는 \"최종 목적지\"라서 변하지 않고, MAC 주소는 \"다음 경유지\"라서 라우터를 거칠 때마다 바뀐다.</p>\n<h3>라우터의 동작 원리</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/a797e09682202fca812238db14e25299/8deec/router.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 53.79746835443038%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACYklEQVR42j2S227TQBCG/Qhp4tjx2Y0bJ7bXxyZOnLhJD0BPaSmFqqWIUgrtDUKiQlxwyRsgXoEH/Zm1Sy5+jb0z37+zsytIFoNiD+G6t9C7C0imj44drySaMQrmYJHYaFsxZCta5WQzguxGaC/ou08yIgjcQOuWKEd/4fQvIBoulPUMmrNJMcGaHuN+V8PjoYyWURupTgrFSSDrZJ4kUL9O0clSyFrIDSMo3Qzx+BhGLwf/513IZlhF0QjhpwsE2Tbaq1wtXqs6GaJiv/KQ6QSCbAbomB70dY+iS20Paui/DA+K5UO1A0i6u9qoNq5ZjfKK0atqhaaRoNHdgeQt0eyfoWFtUzGrdpNMBskpoAUHUP0lxN6S1uInM4amkaHZewbZP0XDvcCaNYfgeUOcH1zi6uQD7t48YDJ+BVH3K0PVZjh5cYSby3vcXT/g3cUXGE5WGbb0ABEb43J5javTT3j/+juGm0sIbrqBkxuG888prr6FyPcdiBp1QMPnR53nJo53u3j5fB3LPRWaPahyLarxcwdnH0NiE1w/Bkh3NiCo/T248x+Ij34hXP6Gmd1CollwiB+5YQzRtEu0aCwNi54VXRK/aUkfQPMP0d/9WbPHf2DEbyF0jBS6PoVpzmDqC3S0EdoGXQANX9QCtBX65h1rNDs1qtfItE2bdTTOEmeWFavqIwg9L0IQhfAYA4sjTGYzFNMtjMZTFLM5thY7mJZzTKZlFfnauCgxzAuqKRDSO+RsEDG4Pj3sjUGMgCXwg1osyhCEKZIsJ2BG8FYVN0dFpXxSVjmfGF7nP7EBqTeI8Q+C8E9T2xi2SwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"router\"\n        title=\"\"\n        src=\"/static/a797e09682202fca812238db14e25299/f058b/router.png\"\n        srcset=\"/static/a797e09682202fca812238db14e25299/c26ae/router.png 158w,\n/static/a797e09682202fca812238db14e25299/6bdcf/router.png 315w,\n/static/a797e09682202fca812238db14e25299/f058b/router.png 630w,\n/static/a797e09682202fca812238db14e25299/40601/router.png 945w,\n/static/a797e09682202fca812238db14e25299/78612/router.png 1260w,\n/static/a797e09682202fca812238db14e25299/8deec/router.png 2136w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>라우터는 <strong>L3까지만</strong> 본다. IP 주소를 확인해서 \"이 패킷을 어느 방향으로 보낼지\"만 결정하고, 포트 번호(L4)나 HTTP 데이터(L7)는 확인하지 않는다.</p>\n<p><strong>스위치 vs 라우터의 차이</strong>:</p>\n<ul>\n<li><strong>스위치</strong>(L2): MAC 주소를 보고 <strong>같은 네트워크 내</strong>에서 전달. 아파트 내 우편함 분류.</li>\n<li><strong>라우터</strong>(L3): IP 주소를 보고 <strong>다른 네트워크로</strong> 전달. 다른 도시로 택배 발송.</li>\n</ul>\n<h3>OSI vs TCP/IP 매핑</h3>\n<ul>\n<li>OSI L5, L6, L7 → TCP/IP Application Layer</li>\n<li>OSI L4 → TCP/IP Transport Layer</li>\n<li>OSI L3 → TCP/IP Internet Layer</li>\n<li>OSI L1, L2 → TCP/IP Network Access Layer</li>\n</ul>\n<hr>\n<h2>웹 서버(Apache, Nginx)는 어느 계층에서 동작하는가?</h2>\n<p>Apache, Nginx 같은 웹 서버는 <strong>L7</strong>(Application Layer)에서 동작한다. HTTP 프로토콜을 처리하기 때문이다.</p>\n<p>하지만 웹 서버가 제공하는 <strong>로드 밸런싱</strong> 기능은 계층에 따라 다르게 동작한다.</p>\n<h3>계층별로 볼 수 있는 정보</h3>\n<table>\n<thead>\n<tr>\n<th>계층</th>\n<th>볼 수 있는 정보</th>\n<th>예시</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>L4</strong></td>\n<td>IP 주소, 포트 번호</td>\n<td><code class=\"language-text\">192.168.1.1:8080</code></td>\n</tr>\n<tr>\n<td><strong>L7</strong></td>\n<td>L4 정보 + HTTP 헤더, URI, 쿠키, 바디</td>\n<td><code class=\"language-text\">GET /api/users</code>, <code class=\"language-text\">Host: example.com</code></td>\n</tr>\n</tbody>\n</table>\n<p>L4 장비는 패킷의 <strong>헤더 부분만</strong> 본다. TCP 헤더에는 출발지/목적지 포트, IP 헤더에는 출발지/목적지 IP가 있다.</p>\n<p>L7 장비는 <strong>패킷 내용</strong>(페이로드)까지 열어본다. HTTP 요청을 파싱해서 URI, 헤더 등을 분석한 후 라우팅을 결정한다.</p>\n<p><strong>비유</strong>: L4는 택배 기사가 <strong>주소</strong>(IP)와 <strong>호수</strong>(포트)만 보고 배달하는 것이고, L7은 택배 기사가 <strong>박스를 열어서 내용물</strong>을 확인한 후 배달 경로를 결정하는 것이다. L4가 빠른 이유는 박스를 안 열기 때문이다.</p>\n<h3>L4 로드 밸런싱</h3>\n<p><strong>TCP/UDP 포트 정보</strong>만 보고 분산한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"nginx\"><pre class=\"language-nginx\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">stream</span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token directive\"><span class=\"token keyword\">upstream</span> backend</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token directive\"><span class=\"token keyword\">server</span> 192.168.1.1:8080</span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">server</span> 192.168.1.2:8080</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token directive\"><span class=\"token keyword\">listen</span> <span class=\"token number\">8080</span></span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_pass</span> backend</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>요청의 내용(URI, 헤더)을 보지 않고, 단순히 연결을 분산시킨다. HTTP가 아닌 프로토콜(MySQL, Redis)도 로드밸런싱할 수 있다.</p>\n<h3>L7 로드 밸런싱</h3>\n<p><strong>HTTP URI, 헤더</strong> 등을 분석해서 분산한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"nginx\"><pre class=\"language-nginx\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">http</span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token directive\"><span class=\"token keyword\">location</span> /api/</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_pass</span> http://api-server</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token directive\"><span class=\"token keyword\">location</span> /static/</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_pass</span> http://static-server</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">/api/</code>로 시작하는 요청은 API 서버로, <code class=\"language-text\">/static/</code>으로 시작하는 요청은 정적 파일 서버로 보낼 수 있다. 더 세밀한 제어가 가능하지만, 패킷 내용을 분석해야 하므로 L4보다 느리다.</p>\n<hr>\n<h2>REST vs gRPC</h2>\n<p>마이크로서비스 아키텍처가 확산되면서, 서비스 간 통신 방식도 진화했다.</p>\n<h3>아키텍처 진화와 gRPC의 등장</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/a2ac9d53796ba299c1bb83192f8325e0/5e1f2/rest-grpc-timeline1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 13.29113924050633%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAg0lEQVR42nXO3Q6CMAwF4D2FjkE2mAgaWQv4EzLjnV75/s9zrNMYueDiS9rTNqnSJWPtaNHKElzdwVQh1SmbCR82oOUHVHWYoGU58/xjEkImebHpcYp37DhKT8hllvv+axCj7A6wzRljfEK59gJd0iIjh024we+nv5xn3l8X9RHb7ooXE2BVnnKAucYAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"rest-grpc-timeline\"\n        title=\"\"\n        src=\"/static/a2ac9d53796ba299c1bb83192f8325e0/f058b/rest-grpc-timeline1.png\"\n        srcset=\"/static/a2ac9d53796ba299c1bb83192f8325e0/c26ae/rest-grpc-timeline1.png 158w,\n/static/a2ac9d53796ba299c1bb83192f8325e0/6bdcf/rest-grpc-timeline1.png 315w,\n/static/a2ac9d53796ba299c1bb83192f8325e0/f058b/rest-grpc-timeline1.png 630w,\n/static/a2ac9d53796ba299c1bb83192f8325e0/40601/rest-grpc-timeline1.png 945w,\n/static/a2ac9d53796ba299c1bb83192f8325e0/78612/rest-grpc-timeline1.png 1260w,\n/static/a2ac9d53796ba299c1bb83192f8325e0/5e1f2/rest-grpc-timeline1.png 2134w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>모놀리스 시대에는 REST API로 충분했다. 하지만 마이크로서비스로 전환되면서 서비스 간 통신이 폭발적으로 증가했고, JSON 직렬화/역직렬화 오버헤드가 문제가 됐다.</p>\n<p>gRPC는 이 문제를 해결하기 위해 등장했다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/a9117968a92c2162c170ecdc7eceaae4/203d3/rest-grpc-flow1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 25.316455696202528%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAABdklEQVR42hWQzU4aYRhGuQSVgmiZGZjhT8bhG4bhRxlRQaTaaLWogSZNJFFoUm03RmNcaHTRhYkmXbjApDUkLtpNFzZpu/ICvKjTz8WbZ3ee5z2+8YhAi9rEUyVSZhkjkScSy+FXBWXLoDOrsl012KlF+bgY5k1JJaCaxJJNhHVI3j3BzZ2Ss7+QmujhUyI2ejSLN7NKrb6FOekRl1C/lmWjGOK6rXHTc+l/sPm2o3K0PEJQMzHTn/Dc72yt/2Jj9YGF8j+czJUESpgVyzMtKnjOHCXLI5ksENRzbE4pXK6McNUM87WlcPsuwMGSnzEjI4s/M1u5o14f0Gj8oLHwB8e+xKfqDkX57srUK9Yqr1l05jEnSgyrNu+9EIP2KPedBD+7KR66Yc7XhghoaSzrmKXl32y2/tJqP/J2/YmC08f3UrcxYi669PacCbnu2aNfEVRs6W4uREfebnWU/UaQpqfxQjGJJ9sIcYbInJIVF7jZa9LmHv8BS2ewpRwHsdwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"rest-grpc-flow\"\n        title=\"\"\n        src=\"/static/a9117968a92c2162c170ecdc7eceaae4/f058b/rest-grpc-flow1.png\"\n        srcset=\"/static/a9117968a92c2162c170ecdc7eceaae4/c26ae/rest-grpc-flow1.png 158w,\n/static/a9117968a92c2162c170ecdc7eceaae4/6bdcf/rest-grpc-flow1.png 315w,\n/static/a9117968a92c2162c170ecdc7eceaae4/f058b/rest-grpc-flow1.png 630w,\n/static/a9117968a92c2162c170ecdc7eceaae4/40601/rest-grpc-flow1.png 945w,\n/static/a9117968a92c2162c170ecdc7eceaae4/78612/rest-grpc-flow1.png 1260w,\n/static/a9117968a92c2162c170ecdc7eceaae4/203d3/rest-grpc-flow1.png 1322w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>REST vs gRPC 비교</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ad885e3543b8ae8b76409e2ddaa3e9ac/8c48a/rest-grpc-compare1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 41.77215189873418%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB0klEQVR42mWSPW/TUBhG8xca243tJLbjr+s4juPEdj6BlpYKiYEJJjogVHVCbSU2ZhADE2JAogMsLEggfgF/7fDagYnhke71PffReW13jOMc40mBLrHOlxRXj5lcPcK+3KJfLjGuNxhPS5R6wWL2RvJW8p6z08+cnXxhOb9lvfjKrvpBkb+joz/M0Z7N0M4Lehc14fUJ4atT7Jsd+s0a4/UW43lFmrykmn2gLj6yW97y4OgbZ0ffub/9yd36F8er33L2iU5vNKGvxNJPsNQMZ1pyGKV0vQjdV+iBZDTGcue4wQpzuMDxN3jhDj++h+0u6fVLzEFFb1jSsdyM4WhK14yI4xSV1oziGl32Wu9vLCWFEwb+RDgfNyuIyhXBuOJwqDgwR3QtH82O6JgtmHPQC/GTjDCtiLItTjiXorCFtH5TOG25rnBeWhIWa9R0i+VkrYxmxeh2IiM7E9ywwJBLI1nHSY3Kd9jeVKBoH1th/uNk3VcF4XTDOL+DMUikMGw5Xc46DegEuWxigigjkjG8uBLj4L/ChtOEi5IcNS5lorq1bmSaUr3fGA5TgdP2oikfZxDJ7yPvdV8Ut2nAZpKG68rzQKx8L2MQFHjRYm/ZGPYT/gAC//EwORAZPwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"rest-grpc-compare\"\n        title=\"\"\n        src=\"/static/ad885e3543b8ae8b76409e2ddaa3e9ac/f058b/rest-grpc-compare1.png\"\n        srcset=\"/static/ad885e3543b8ae8b76409e2ddaa3e9ac/c26ae/rest-grpc-compare1.png 158w,\n/static/ad885e3543b8ae8b76409e2ddaa3e9ac/6bdcf/rest-grpc-compare1.png 315w,\n/static/ad885e3543b8ae8b76409e2ddaa3e9ac/f058b/rest-grpc-compare1.png 630w,\n/static/ad885e3543b8ae8b76409e2ddaa3e9ac/40601/rest-grpc-compare1.png 945w,\n/static/ad885e3543b8ae8b76409e2ddaa3e9ac/78612/rest-grpc-compare1.png 1260w,\n/static/ad885e3543b8ae8b76409e2ddaa3e9ac/8c48a/rest-grpc-compare1.png 2096w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>언제 무엇을 쓸까?</h3>\n<p><strong>REST가 적합한 경우</strong>:</p>\n<ul>\n<li>브라우저 - 서버 통신</li>\n<li>외부 공개 API</li>\n<li>디버깅 편의성이 중요할 때</li>\n</ul>\n<p><strong>gRPC가 적합한 경우</strong>:</p>\n<ul>\n<li>서버 - 서버 내부 통신</li>\n<li>마이크로서비스 간 통신</li>\n<li>실시간 스트리밍</li>\n<li>고성능, 낮은 지연이 필요할 때</li>\n</ul>\n<p>외부는 <strong>REST</strong>, 내부는 <strong>gRPC</strong>.</p>\n<p>브라우저 → API Gateway(REST) → 마이크로서비스들(gRPC) 구조가 일반적이다.</p>","wordCount":{"words":1512},"frontmatter":{"title":"HTTP, HTTPS 그리고 웹의 동작 원리","date":"September 23, 2025","description":"HTTP와 HTTPS의 차이, SSL Handshake, HTTP 메서드, REST API, CORS, OSI 7계층까지 웹 개발자가 알아야 할 핵심 개념을 정리합니다."}},"previous":{"fields":{"slug":"/async/"},"frontmatter":{"title":"비동기 처리: 메시지 큐부터 CDC까지 5가지 구현 방법"}},"next":{"fields":{"slug":"/cache-part1/"},"frontmatter":{"title":"Facebook Memcached 아키텍처 (1탄) - 기본 설계와 클러스터 내부 최적화"}}},"pageContext":{"id":"200e4ba5-aeca-5981-bec6-e05f77f432f8","previousPostId":"7ebaac03-1a97-518a-8709-97b4c18db099","nextPostId":"7934a91e-9561-5a22-90e9-8ede258c0daf"}},"staticQueryHashes":["3257411868","3517523002"],"slicesMap":{}}