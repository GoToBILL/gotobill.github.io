{"componentChunkName":"component---src-templates-blog-post-js","path":"/jvm-jit-compiler/","result":{"data":{"site":{"siteMetadata":{"title":"GoToBill"}},"markdownRemark":{"id":"2082780b-02d4-51da-9cf9-d53183ff2475","excerpt":"컴파일 vs 인터프리터 프로그래밍 언어 실행 방식은 크게 두 가지입니다. 방식 특징 대표 언어 컴파일 전체 코드를 기계어로 변환 후 실행. 빠르지만 컴파일 시간 필요 C, C++ 인터프리터 한 줄씩 해석하며 실행. 시작은 빠르지만 실행 속도 느림 Python, JavaScript…","html":"<h2>컴파일 vs 인터프리터</h2>\n<p>프로그래밍 언어 실행 방식은 크게 두 가지입니다.</p>\n<table>\n<thead>\n<tr>\n<th>방식</th>\n<th>특징</th>\n<th>대표 언어</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>컴파일</td>\n<td>전체 코드를 기계어로 변환 후 실행. 빠르지만 컴파일 시간 필요</td>\n<td>C, C++</td>\n</tr>\n<tr>\n<td>인터프리터</td>\n<td>한 줄씩 해석하며 실행. 시작은 빠르지만 실행 속도 느림</td>\n<td>Python, JavaScript</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Java는 두 방식을 결합했습니다.</strong> 소스 코드를 바이트코드로 컴파일하고, JVM이 바이트코드를 해석하면서 필요한 부분만 기계어로 컴파일합니다.</p>\n<hr>\n<h2>JIT 컴파일러란?</h2>\n<p><strong>JIT(Just-In-Time) 컴파일러</strong>는 자주 실행되는 코드(Hotspot)를 찾아 네이티브 코드로 컴파일해 성능을 높입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">프로그램 시작\n     ↓\nInterpreter로 바이트코드 해석 실행\n     ↓\nRuntime Profiler가 메서드 호출 횟수 모니터링\n     ↓\n임계값 초과 (Hotspot 감지)\n     ↓\nJIT Compiler가 네이티브 코드로 컴파일\n     ↓\n이후 호출: 컴파일된 코드 직접 실행 (빠름)</code></pre></div>\n<p><strong>핵심</strong>: 모든 코드를 컴파일하지 않습니다. 자주 실행되는 코드만 컴파일해서 컴파일 오버헤드와 실행 속도의 균형을 맞춥니다.</p>\n<hr>\n<h2>C1 vs C2 컴파일러</h2>\n<p>JVM에는 두 가지 JIT 컴파일러가 있습니다.</p>\n<table>\n<thead>\n<tr>\n<th>컴파일러</th>\n<th>특징</th>\n<th>용도</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>C1 (Client)</td>\n<td>빠른 컴파일, 기본 최적화</td>\n<td>빠른 시작이 중요한 경우</td>\n</tr>\n<tr>\n<td>C2 (Server)</td>\n<td>느린 컴파일, 고급 최적화</td>\n<td>장기 실행 서버 애플리케이션</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>티어드 컴파일 (Tiered Compilation)</h2>\n<p><strong>Java 8부터 기본 활성화.</strong> C1과 C2를 함께 사용합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Level 0: Interpreter (해석 실행)\n     ↓ 호출 횟수 증가\nLevel 1-3: C1 컴파일 (빠른 컴파일, 기본 최적화)\n     ↓ 호출 횟수 계속 증가\nLevel 4: C2 컴파일 (느린 컴파일, 고급 최적화)</code></pre></div>\n<p>처음에는 C1으로 빠르게 컴파일해서 시작 속도를 높이고, 정말 자주 실행되는 코드는 C2로 재컴파일해서 최적의 성능을 냅니다.</p>\n<hr>\n<h2>JIT 최적화 기법</h2>\n<h3>인라이닝 (Inlining)</h3>\n<p>메서드 호출을 메서드 본문으로 대체합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// Before</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// After (Inlined)</span>\n<span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token number\">5</span> <span class=\"token operator\">+</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>메서드 호출 오버헤드(스택 프레임 생성, 매개변수 전달)가 제거됩니다.</p>\n<h3>루프 언롤링 (Loop Unrolling)</h3>\n<p>루프를 펼쳐서 반복 오버헤드를 줄입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// Before</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">process</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// After (Unrolled)</span>\n<span class=\"token function\">process</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">process</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">process</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">process</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>탈출 분석 (Escape Analysis)</h3>\n<p>객체가 메서드 밖으로 나가지 않으면 최적화를 적용합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Point</span> p <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Point</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 루프 내에서만 사용</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span>x <span class=\"token operator\">+</span> p<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li><strong>스택 할당</strong>: 힙 대신 스택에 할당 (GC 부담 감소)</li>\n<li><strong>동기화 제거</strong>: 불필요한 lock 제거</li>\n<li><strong>스칼라 치환</strong>: 객체를 개별 필드로 분해</li>\n</ul>\n<h3>OSR (On-Stack Replacement)</h3>\n<p>긴 루프가 실행 중일 때, 루프가 끝날 때까지 기다리지 않고 즉시 컴파일된 코드로 전환합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10_000_000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 루프 도중에 JIT 컴파일 코드로 교체</span>\n    <span class=\"token function\">compute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<hr>\n<h2>역최적화 (Deoptimization)</h2>\n<p>JVM이 기존에 컴파일한 코드를 다시 인터프리터 모드로 되돌리는 과정입니다.</p>\n<h3>발생 원인: 다형성 변화</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">MemberRepository</span> repo <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MemberRepositoryImpl</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 100만 번 실행 → JVM이 MemberRepositoryImpl 기준으로 최적화</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">1_000_000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    repo<span class=\"token punctuation\">.</span><span class=\"token function\">save</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"User-\"</span> <span class=\"token operator\">+</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 새로운 구현체로 교체 → 기존 최적화 무효화</span>\nrepo <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LoggingMemberRepository</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">MemberRepositoryImpl</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 역최적화 발생, 다시 프로파일링 시작</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">1_000_000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    repo<span class=\"token punctuation\">.</span><span class=\"token function\">save</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"User-\"</span> <span class=\"token operator\">+</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>JVM은 단일 타입(Monomorphic)으로 호출되는 메서드를 적극적으로 인라이닝합니다. 다른 구현체가 등장하면 기존 최적화가 무효화되고 역최적화가 발생합니다.</p>\n<h3>Inline Cache 상태</h3>\n<table>\n<thead>\n<tr>\n<th>상태</th>\n<th>설명</th>\n<th>성능</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Monomorphic</td>\n<td>단일 타입</td>\n<td>가장 빠름</td>\n</tr>\n<tr>\n<td>Polymorphic</td>\n<td>2~4개 타입</td>\n<td>빠름</td>\n</tr>\n<tr>\n<td>Megamorphic</td>\n<td>다수 타입</td>\n<td>느림 (vtable 사용)</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>웜업 (Warm-up)</h2>\n<p>프로그램 시작 직후에는 인터프리터로 실행되므로 성능이 낮습니다. JIT 컴파일이 완료되면 성능이 향상됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// 초기 실행: 인터프리터 모드 (느림)</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100_000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">compute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 웜업 후: JIT 컴파일 완료 (빠름)</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100_000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">compute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>실제 측정 시 웜업을 고려해야 합니다. 벤치마크 도구(JMH)는 자동으로 웜업을 수행합니다.</p>\n<hr>\n<h2>JVM 튜닝 옵션</h2>\n<table>\n<thead>\n<tr>\n<th>옵션</th>\n<th>설명</th>\n<th>기본값</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">-XX:+TieredCompilation</code></td>\n<td>티어드 컴파일 활성화</td>\n<td>true (Java 8+)</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">-XX:CompileThreshold=N</code></td>\n<td>컴파일 임계값</td>\n<td>10,000</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">-XX:ReservedCodeCacheSize=N</code></td>\n<td>코드 캐시 크기</td>\n<td>240MB (Tiered)</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">-XX:CICompilerCount=N</code></td>\n<td>컴파일 스레드 수</td>\n<td>CPU에 비례</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">-XX:MaxInlineSize=N</code></td>\n<td>인라이닝 대상 메서드 크기</td>\n<td>35 bytes</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">-XX:+DoEscapeAnalysis</code></td>\n<td>탈출 분석 활성화</td>\n<td>true</td>\n</tr>\n</tbody>\n</table>\n<h3>코드 캐시 부족 문제</h3>\n<p>코드 캐시가 가득 차면 JIT 컴파일이 중단되고 인터프리터로 실행됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 코드 캐시 크기 증가</span>\n<span class=\"token function\">java</span> <span class=\"token parameter variable\">-XX:ReservedCodeCacheSize</span><span class=\"token operator\">=</span>512m MyApplication</code></pre></div>\n<h3>컴파일 로그 확인</h3>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 컴파일 로그 출력</span>\n<span class=\"token function\">java</span> <span class=\"token parameter variable\">-XX:+PrintCompilation</span> MyApplication\n\n<span class=\"token comment\"># 인라이닝 로그</span>\n<span class=\"token function\">java</span> <span class=\"token parameter variable\">-XX:+PrintInlining</span> MyApplication</code></pre></div>\n<hr>\n<h2>정리</h2>\n<table>\n<thead>\n<tr>\n<th>개념</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JIT 컴파일러</td>\n<td>자주 실행되는 코드를 네이티브 코드로 컴파일</td>\n</tr>\n<tr>\n<td>Tiered Compilation</td>\n<td>C1(빠른 컴파일) + C2(고급 최적화) 조합</td>\n</tr>\n<tr>\n<td>인라이닝</td>\n<td>메서드 호출을 본문으로 대체</td>\n</tr>\n<tr>\n<td>탈출 분석</td>\n<td>객체가 스코프를 벗어나지 않으면 스택 할당</td>\n</tr>\n<tr>\n<td>역최적화</td>\n<td>다형성 변화 시 기존 최적화 무효화</td>\n</tr>\n<tr>\n<td>웜업</td>\n<td>JIT 컴파일 완료까지의 초기 성능 저하 구간</td>\n</tr>\n</tbody>\n</table>\n<p>JIT 컴파일러 덕분에 Java는 인터프리터 언어의 이식성과 컴파일 언어의 성능을 모두 얻을 수 있습니다.</p>","wordCount":{"words":418},"frontmatter":{"title":"JIT 컴파일러 심화","date":"September 12, 2025","description":"JVM의 JIT 컴파일러 동작 원리와 티어드 컴파일, 최적화 기법을 알아봅니다."}},"previous":{"fields":{"slug":"/javaGarbage/"},"frontmatter":{"title":"Garbage Collection 핵심 정리"}},"next":{"fields":{"slug":"/non-blocking/"},"frontmatter":{"title":"Blocking & Non-Blocking I/O로 성능 개선하기"}}},"pageContext":{"id":"2082780b-02d4-51da-9cf9-d53183ff2475","previousPostId":"f60b3d8a-8c99-58c6-b386-5b2d2490e208","nextPostId":"05152dfc-1fc7-52d3-bbc8-33b7c98519ad"}},"staticQueryHashes":["3257411868","3517523002"],"slicesMap":{}}