{"componentChunkName":"component---src-templates-blog-post-js","path":"/jvm-jit-compiler/","result":{"data":{"site":{"siteMetadata":{"title":"GoToBill's Dev Blog"}},"markdownRemark":{"id":"2082780b-02d4-51da-9cf9-d53183ff2475","excerpt":"JVM 자바를 공부하시는 분들은 JVM을 들어보셨을 겁니다. JVM은 어느 OS에서 실행해도 자바로 작성된 파일을 잘 실행시켜줍니다. 그렇기 때문에 이식성이 높다는 말을 듣죠. JVM은 JIT 컴파일러를 가지고 있습니다. 이 글에서 JIT…","html":"<h2>JVM</h2>\n<p>자바를 공부하시는 분들은 JVM을 들어보셨을 겁니다.</p>\n<p>JVM은 어느 OS에서 실행해도 자바로 작성된 파일을 잘 실행시켜줍니다. 그렇기 때문에 이식성이 높다는 말을 듣죠.</p>\n<p>JVM은 JIT 컴파일러를 가지고 있습니다. 이 글에서 JIT 컴파일러에 대해서 말씀드리겠습니다.</p>\n<h3>컴파일과 인터프리터의 차이</h3>\n<p>프로그래밍 언어를 실행하는 방식에는 크게 <strong>컴파일 방식</strong>과 <strong>인터프리터 방식</strong>이 있습니다.</p>\n<h4>컴파일 방식</h4>\n<ul>\n<li>전체 코드를 한 번에 기계어(네이티브 코드)로 변환하여 실행하는 방식입니다.</li>\n<li>실행 속도가 빠르지만, 실행 전에 <strong>컴파일 과정</strong>이 필요하므로 초기 실행 시간이 오래 걸립니다.</li>\n<li>대표적인 컴파일 언어: <strong>C, C++</strong></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, World!\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 실행 방식:</span>\n<span class=\"token comment\">// 1. 컴파일: gcc main.c -o main</span>\n<span class=\"token comment\">// 2. 실행: ./main</span></code></pre></div>\n<h4>인터프리터 방식</h4>\n<ul>\n<li>코드를 한 줄씩 읽어가며 즉시 실행하는 방식입니다.</li>\n<li>실행 준비가 필요 없지만 실행 속도가 느립니다.</li>\n<li>대표적인 인터프리터 언어: <strong>Python, JavaScript</strong></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># Python 예제 (인터프리터 방식)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, World!\"</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h4>어셈블리 명령어와 성능 차이</h4>\n<p>CPU는 <strong>기계어(바이너리 코드,네이티브 코드) 또는 어셈블리 언어 명령어</strong>만 실행할 수 있습니다.<br>\n컴파일러는 이 명령어들의 실행 순서를 최적화하여 성능을 높입니다.</p>\n<p>예를 들어, 두 개의 숫자를 더하는 프로그램을 생각해봅시다.</p>\n<ul>\n<li><strong>컴파일 방식:</strong>\n<ul>\n<li>미리 데이터를 메모리에서 가져와 <strong>레지스터</strong>에 저장한 후 덧셈 연산을 실행</li>\n<li>덧셈에 필요한 데이터가 미리 준비되어 있어 빠르게 실행됨</li>\n</ul>\n</li>\n<li><strong>인터프리터 방식 (Java는 Stack 방식):</strong>\n<ul>\n<li>실행할 때마다 메모리에서 데이터를 가져온 후 덧셈을 수행</li>\n<li>매번 메모리 접근을 해야 하므로 속도가 느려짐</li>\n</ul>\n</li>\n</ul>\n<p>컴파일된 코드는 미리 <strong>최적화된 실행 순서를 적용할 수 있지만</strong>,<br>\n인터프리터 방식은 실행 중에 코드 변환을 수행해야 하므로 속도가 느릴 수밖에 없습니다.</p>\n<p>이처럼 <strong>컴파일 방식은 빠른 실행 속도를 보장하지만, 실행 전에 컴파일 과정이 필요하고, 인터프리터 방식은 빠르게 실행되지만 속도가 느리다는 단점이 있습니다.</strong></p>\n<h3>JVM과 바이트코드</h3>\n<p><strong>Java는 위 두 가지 방식(컴파일, 인터프리터)을 적절히 결합한 방식</strong>을 사용합니다. Java 프로그램이 실행되기 전에는 <strong>소스 코드(.java)를 바이트코드(.class)로 변환</strong>하는 과정이 필요합니다.</p>\n<h4>바이트코드란?</h4>\n<p>바이트코드는 JVM이 이해할 수 있는 중간 코드입니다. 실행하기 위해서는 JVM이 바이트코드를 기계어로 변환해야 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">HelloWorld</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, World!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 실행 과정:</span>\n<span class=\"token comment\">// 1. 컴파일: javac HelloWorld.java  (바이트코드 생성)</span>\n<span class=\"token comment\">// 2. 실행: java HelloWorld  (JVM이 바이트코드를 해석하여 실행)</span></code></pre></div>\n<p>Java의 실행 방식은 <strong>\"컴파일 후 인터프리터 실행\"</strong> 방식입니다. 즉, 처음에는 바이트코드를 인터프리터 방식으로 실행하며, 이후 JIT 컴파일러가 최적화를 수행합니다.</p>\n<h3>JIT 컴파일러의 동작 원리</h3>\n<p>JIT 컴파일러는 Java 프로그램 실행 중 <strong>자주 실행되는 코드(핫스팟, Hotspot)를 찾아 네이티브 코드로 변환하여 실행 속도를 높이는 역할</strong>을 합니다.</p>\n<h4>JIT 컴파일러의 실행 과정</h4>\n<ol>\n<li><strong>처음 실행</strong>: JVM은 바이트코드를 인터프리터 방식으로 실행합니다.<br>\n-> <strong>모든 코드를 컴파일 하지 않는다.</strong></li>\n<li><strong>핫스팟 감지</strong>: JVM은 실행 중 특정 메서드나 루프가 자주 실행되는지 분석합니다.</li>\n<li><strong>JIT 컴파일 수행</strong>: 자주 실행되는 코드**(핫스팟)**를 **네이티브 코드(기계어)**로 변환하여 실행 속도를 높입니다.</li>\n<li><strong>최적화 지속 수행</strong>: JIT 컴파일러는 실행 도중에도 지속적으로 코드 실행 패턴을 분석하여 최적화를 적용합니다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">JITExample</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">long</span> startTime <span class=\"token operator\">=</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">nanoTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10_000_000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">compute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">long</span> endTime <span class=\"token operator\">=</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">nanoTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"실행 시간: \"</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>endTime <span class=\"token operator\">-</span> startTime<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">1_000_000</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" ms\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">compute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            sum <span class=\"token operator\">+=</span> i<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> sum<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드에서 <strong>compute() 메서드는 매우 자주 실행되므로 JVM</strong>은 <strong>핫스팟으로 감지하여 JIT 컴파일을 수행</strong>합니다.</p>\n<h3>JIT 컴파일러의 종류</h3>\n<p>JIT 컴파일러는 두 가지 형태로 나뉩니다. 애플리케이션이 실행되는 동안 어떤 방식으로 컴파일할지를 결정하는 것이 중요한데, 이에 따라 적절한 컴파일러를 선택해야 합니다.</p>\n<p>JVM에서 사용하는 두 가지 JIT 컴파일러는 <strong>클라이언트 컴파일러(Client Compiler, C1)</strong> 와 <strong>서버 컴파일러(Server Compiler, C2)</strong> 입니다. JVM 개발자들은 각각 <strong>C1(컴파일러 1), C2(컴파일러 2)</strong> 라고 부르기도 합니다.</p>\n<p>두 컴파일러의 가장 큰 차이점은 <strong>컴파일 방식의 적극성</strong>에 있습니다.</p>\n<p><strong>클라이언트 컴파일러</strong>는 실행 초기에 빠르게 코드를 컴파일하여 즉시 실행 속도를 높이는 데 초점을 맞추고 있습니다. 반면, <strong>서버 컴파일러</strong>는 <strong>더 많은 실행 정보를 수집한 후(초기에는 인터프리터 방식으로)에 보다 강력한 최적화를 적용</strong>하여 장기적으로 높은 성능을 제공합니다.</p>\n<p><strong>클라이언트 컴파일러는 빠르게 동작하는 대신, 깊이 있는 최적화가 부족하고, 서버 컴파일러는 초기에는 느리지만 시간이 지나면 훨씬 더 효율적인 실행 속도를 제공합니다.</strong></p>\n<p>이러한 차이점 때문에 <strong>애플리케이션의 특성에 따라 적절한 컴파일러를 선택하는 것이 중요</strong>합니다.</p>\n<ul>\n<li><strong>짧은 시간 동안 실행되는 프로그램</strong>이라면 <strong>클라이언트 컴파일러</strong>가 더 적합합니다.</li>\n<li><strong>장기간 실행되는 서버 애플리케이션</strong>이라면 <strong>서버 컴파일러</strong>를 선택하는 것이 바람직합니다.</li>\n</ul>\n<h4>티어드 컴파일(Tiered Compilation)</h4>\n<p>여기서 한 가지 궁금한 게 생길 수 있습니다. 그냥 두개를 섞어서 쓰면 되는 거 아닌가?<br>\n\"JVM이 처음에는 클라이언트 컴파일러를 사용하다가, 코드가 많이 실행되면 서버 컴파일러로 전환할 수는 없을까?\"</p>\n<p><strong>이러한 개념이 바로 티어드 컴파일(Tiered Compilation) 입니다.</strong></p>\n<p>티어드 컴파일을 사용하면 코드가 처음에는 클라이언트 컴파일러(C1)에서 빠르게 컴파일되고, 이후 실행 횟수가 많아지면 서버 컴파일러(C2)로 다시 컴파일됩니다.</p>\n<p><strong>이 과정에서 역최적화(밑에서 설명)</strong> 가 발생하지만, 재컴파일 시간은 성능에 영향을 줄 정도로 크지 않기 때문에 장기적으로는 훨씬 효율적인 실행이 가능합니다.</p>\n<p>티어드 컴파일은 <strong>자바 7부터 도입되었으며, 자바 8에서는 기본적으로 활성화</strong>되어 있습니다.<br>\n즉, 별도로 설정하지 않아도 JVM은 클라이언트 컴파일러와 서버 컴파일러를 적절히 조합하여 사용하게 됩니다.</p>\n<p>결국, 티어드 컴파일을 활용하면 <strong>빠른 실행 속도와 최적화된 성능을 모두 얻을 수 있어, 대부분의 애플리케이션에서 가장 좋은 선택</strong>이 될 수 있습니다.</p>\n<p>티어드 컴파일이 기본적으로 동작하는 방식을 이해했다면, 이제 실제로 이 방식을 적용할 때 어떤 튜닝이 필요한지 살펴보겠습니다.</p>\n<p>티어드 컴파일이 효과적으로 작동하려면, JVM이 <strong>클라이언트 컴파일러(C1)</strong> 와 <strong>서버 컴파일러(C2)</strong> 간의 전환을 원활하게 수행할 수 있도록 <strong>적절한 설정과 최적화가 필요합니다</strong>.</p>\n<h3>티어드 컴파일의 최적화를 위한 주요 고려사항</h3>\n<h4>코드 캐시 최적화</h4>\n<p>티어드 컴파일러는 <strong>초기에 C1(클라이언트 컴파일러)에서 실행된 코드를 C2(서버 컴파일러)로 재컴파일</strong>하며, 이 과정에서 많은 코드가 생성됩니다.</p>\n<p>JVM은 <strong>컴파일된 기계어 코드를 \"코드 캐시\"에 저장</strong>하는데, <strong>이 캐시가 가득 차면 추가적인 코드 컴파일이 불가능해질 수 있습니다.</strong></p>\n<p><strong>문제점</strong></p>\n<p>코드 캐시가 가득 차면 JVM이 더 이상 새로운 코드를 컴파일할 수 없고, <strong>일부 코드가 인터프리터로 실행될 수 있음</strong></p>\n<ul>\n<li>서버 컴파일러(C2)가 작동하지 않게 되면 성능이 저하될 가능성이 높음</li>\n</ul>\n<p><strong>해결 방법</strong></p>\n<p>JVM 실행 시 <strong>-XX:ReservedCodeCacheSize=N</strong> 옵션을 활용하여 코드 캐시 크기를 늘릴 수 있습니다.<br>\n일반적으로 기본값보다 <strong>2배~4배 정도 증가시키는 것이 성능 향상에 도움</strong>이 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">java</span> <span class=\"token parameter variable\">-XX:ReservedCodeCacheSize</span><span class=\"token operator\">=</span>512m <span class=\"token parameter variable\">-XX:+TieredCompilation</span> MyApplication</code></pre></div>\n<h4>컴파일 임계치(Compile Threshold) 조정</h4>\n<p>티어드 컴파일에서 코드가 C1 → C2로 넘어가기까지 얼마나 많은 실행 횟수가 필요한지를 조절하는 설정입니다.</p>\n<p><strong>문제점</strong></p>\n<ul>\n<li>기본적으로 C1에서 C2로 전환하는 기준(임계치)이 높게 설정되어 있어, <strong>실행 초기에 최적화가 늦어질 수 있음</strong></li>\n<li>빠르게 최적화된 코드가 필요하다면, 이 임계치를 낮추는 것이 유리할 수 있음</li>\n</ul>\n<p><strong>해결 방법</strong></p>\n<ul>\n<li><strong>-XX:CompileThreshold=N</strong> 플래그를 사용하여 <strong>C2로 컴파일되는 임계값을 조정</strong></li>\n<li>기본적으로 <strong>클라이언트 컴파일러(C1)에서 1,500번</strong>, <strong>서버 컴파일러(C2)에서 10,000번</strong> 실행되면 컴파일됨</li>\n<li>이 값을 낮추면 <strong>C2로의 전환이 빨라짐</strong>, 그러나 <strong>너무 낮추면 불필요한 컴파일이 많아져 오히려 성능이 저하될 수 있음</strong></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">java</span> <span class=\"token parameter variable\">-XX:CompileThreshold</span><span class=\"token operator\">=</span><span class=\"token number\">5000</span> <span class=\"token parameter variable\">-XX:+TieredCompilation</span> MyApplication</code></pre></div>\n<p>이렇게 하면, 기존 10,000번 실행 후 C2로 넘어가는 것보다 <strong>더 빠르게 최적화된 코드를 사용할 수 있습니다.</strong></p>\n<h4>OSR(On-Stack Replacement) 활용</h4>\n<p>OSR은 <strong>긴 루프가 인터프리터 모드에서 실행되더라도, 루프 도중에 JIT 컴파일된 코드로 교체하는 기법</strong>입니다.<br>\n즉, 루프를 빠져나올 때까지 기다릴 필요 없이, <strong>즉시 컴파일된 코드로 전환 가능</strong>합니다.</p>\n<p><strong>문제점</strong></p>\n<ul>\n<li>기본적으로 JVM은 <strong>루프가 끝날 때까지 컴파일된 코드로 전환하지 않음</strong></li>\n<li>긴 루프가 인터프리터 모드에서 계속 실행될 경우 성능 저하 발생</li>\n</ul>\n<p><strong>해결 방법</strong></p>\n<ul>\n<li>-XX:+TieredCompilation 플래그를 활성화하면 OSR이 자동으로 적용됨</li>\n<li>별도로 -XX:LoopUnrollLimit을 설정하면 <strong>OSR이 더 적극적으로 실행됨</strong></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">java</span> <span class=\"token parameter variable\">-XX:+TieredCompilation</span> <span class=\"token parameter variable\">-XX:LoopUnrollLimit</span><span class=\"token operator\">=</span><span class=\"token number\">50</span> MyApplication</code></pre></div>\n<p>이렇게 하면 <strong>루프 실행 중에도 인터프리터를 사용하지 않고 빠르게 C1 → C2 전환 가능</strong>.</p>\n<h4>컴파일 스레드 최적화</h4>\n<p>JVM은 <strong>컴파일 큐</strong>를 활용하여 메서드가 컴파일될 때까지 대기시킵니다.<br>\n컴파일 큐는 <strong>FIFO(선입선출)</strong> 방식이 아니며, <strong>호출 빈도가 높은 메서드가 우선적으로 컴파일</strong>됩니다.</p>\n<p>기본적으로 <strong>클라이언트 컴파일러(C1)는 1개, 서버 컴파일러(C2)는 2개의 컴파일 스레드</strong>로 시작합니다.<br>\n<strong>티어드 컴파일을 사용하는 경우, CPU 개수에 따라 적절한 개수의 컴파일 스레드를 자동으로 할당</strong>합니다.</p>\n<p><strong>컴파일 스레드 개수 조정 방법</strong></p>\n<ul>\n<li><strong>-XX:CICompilerCount=N</strong> 옵션을 사용하면 <strong>컴파일 스레드 개수를 직접 설정</strong>할 수 있습니다.</li>\n<li>단일 CPU 환경에서는 1개로 제한하는 것이 좋습니다.</li>\n<li>다중 코어 환경에서는 컴파일 스레드 개수를 늘려 <strong>JVM이 빠르게 JIT 컴파일을 수행하도록 조정할 수 있습니다</strong>.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">java</span> <span class=\"token parameter variable\">-XX:CICompilerCount</span><span class=\"token operator\">=</span><span class=\"token number\">4</span> <span class=\"token parameter variable\">-XX:+TieredCompilation</span> MyApplication</code></pre></div>\n<p><strong>주의할 점</strong></p>\n<ul>\n<li>CPU 개수가 적다면 너무 많은 컴파일 스레드를 할당하면 오히려 경쟁이 발생하여 성능이 저하될 수 있습니다.</li>\n<li>초반 <strong>스타트업 속도는 증가할 수 있지만, 장기적으로 CPU 리소스를 과도하게 사용하게 될 수도 있습니다.</strong></li>\n</ul>\n<h4>인라이닝(Inlining) 최적화</h4>\n<p><strong>인라이닝</strong>은 JVM이 <strong>자주 호출되는 메서드를 직접 호출하는 방식으로 변경하여 메서드 호출 오버헤드를 줄이는 최적화 기법</strong>입니다.</p>\n<p><strong>인라이닝의 효과</strong></p>\n<ul>\n<li>메서드 호출 시 발생하는 스택 프레임 생성 비용을 제거</li>\n<li>루프 내에서 반복적으로 호출되는 메서드를 직접 코드에 삽입하여 실행 속도 향상</li>\n</ul>\n<p><strong>인라이닝 설정 방법</strong></p>\n<ul>\n<li><strong>-XX:MaxInlineSize=N</strong> → <strong>바이트 코드 크기가 N 바이트 이하인 메서드는 인라이닝됨</strong></li>\n<li><strong>-XX:MaxFreqInlineSize=N</strong> → <strong>자주 호출되는 메서드는 더 큰 크기라도 인라이닝</strong></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">java</span> <span class=\"token parameter variable\">-XX:MaxInlineSize</span><span class=\"token operator\">=</span><span class=\"token number\">50</span> <span class=\"token parameter variable\">-XX:MaxFreqInlineSize</span><span class=\"token operator\">=</span><span class=\"token number\">400</span> MyApplication</code></pre></div>\n<p><strong>주의할 점</strong></p>\n<ul>\n<li>인라이닝을 과도하게 하면 <strong>JVM의 코드 캐시를 빠르게 소모할 수 있음</strong>.</li>\n<li>너무 많은 메서드가 인라이닝되면 오히려 성능이 저하될 가능성이 있음.</li>\n</ul>\n<h4>탈출 분석(Escape Analysis) 최적화</h4>\n<p><strong>탈출 분석</strong>은 <strong>객체가 특정 스코프를 벗어나지 않는 경우, JVM이 해당 객체를 최적화하는 기법</strong>입니다.</p>\n<p><strong>탈출 분석의 효과</strong></p>\n<ul>\n<li><strong>스레드 동기화 제거:</strong> <strong>동기화(lock)를 사용할 필요가 없는 객체는 자동으로 제거</strong></li>\n<li><strong>스택 할당(Stack Allocation):</strong> <strong>객체를 힙이 아닌 스택에 할당</strong>하여 <strong>GC(가비지 컬렉션) 부담 감소</strong></li>\n<li><strong>레지스터 최적화:</strong> 객체의 값을 <strong>메모리가 아닌 CPU 레지스터에서 관리</strong></li>\n</ul>\n<p><strong>탈출 분석 활성화 방법</strong> 기본적으로 탈출 분석은 활성화되어 있으며, <strong>-XX:+DoEscapeAnalysis</strong> 옵션을 사용하여 명시적으로 활성화할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">java</span> <span class=\"token parameter variable\">-XX:+DoEscapeAnalysis</span> MyApplication</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Factorial</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Factorial</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>n <span class=\"token operator\">=</span> n<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getFactorial</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> n<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token class-name\">Factorial</span> f <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Factorial</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 루프 내에서만 사용됨</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">.</span><span class=\"token function\">getFactorial</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 코드에서 Factorial 객체는 <strong>루프 내에서만 사용</strong>되므로, 탈출 분석을 통해 <strong>힙이 아닌 스택에서 할당</strong>될 수 있습니다.</p>\n<p><strong>주의할 점</strong></p>\n<ul>\n<li>탈출 분석이 항상 최적의 성능을 보장하는 것은 아니며, 특정 환경에서는 성능이 저하될 수도 있음.</li>\n<li>객체가 예상보다 더 큰 범위에서 사용되면, JVM이 탈출 분석을 제대로 수행하지 못할 가능성이 있음.</li>\n</ul>\n<h4>역최적화</h4>\n<p>JVM이 <strong>기존에 컴파일한 코드를 다시 인터프리터 모드로 되돌리는 과정</strong>을 <strong>역최적화</strong>라고 합니다.</p>\n<p><strong>역최적화가 발생하는 주요 원인</strong></p>\n<p><strong>1. 다형성의 변화</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">MemberRepository</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">save</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">String</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> memberId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MemberRepositoryImpl</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">MemberRepository</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">save</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> member<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Saving member: \"</span> <span class=\"token operator\">+</span> member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> memberId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"Member-\"</span> <span class=\"token operator\">+</span> memberId<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">LoggingMemberRepository</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">MemberRepository</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">MemberRepository</span> delegate<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">LoggingMemberRepository</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MemberRepository</span> delegate<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>delegate <span class=\"token operator\">=</span> delegate<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">save</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> member<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"[LOG] Saving member: \"</span> <span class=\"token operator\">+</span> member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        delegate<span class=\"token punctuation\">.</span><span class=\"token function\">save</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> memberId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"[LOG] Finding member: \"</span> <span class=\"token operator\">+</span> memberId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> delegate<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span>memberId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">MemberRepository</span> repository <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MemberRepositoryImpl</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 초기엔 이 클래스로 최적화됨</span>\n\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">1_000_000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            repository<span class=\"token punctuation\">.</span><span class=\"token function\">save</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"User-\"</span> <span class=\"token operator\">+</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            repository<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">// 로그 기능이 추가되면서 기존의 최적화된 코드가 역최적화될 가능성이 높아짐</span>\n        repository <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LoggingMemberRepository</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">MemberRepositoryImpl</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">1_000_000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            repository<span class=\"token punctuation\">.</span><span class=\"token function\">save</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"User-\"</span> <span class=\"token operator\">+</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            repository<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li><strong>초기에는 MemberRepositoryImpl만 사용</strong>되어, <strong>JVM은 이 클래스를 최적화하여 실행 속도를 높임.</strong></li>\n<li>하지만 <strong>새로운 구현체 LoggingMemberRepository가 추가되면서 다형성이 바뀜</strong>.</li>\n<li>기존의 <strong>최적화된 코드가 더 이상 유효하지 않게 되면서 JVM은 역최적화를 수행</strong>함.</li>\n<li><strong>JVM은</strong> 기존의 <strong>최적화된 코드를 폐기하고, 새로운 다형성을 반영한 코드로 다시 컴파일</strong>함.</li>\n</ul>\n<p><strong>2. 티어드 컴파일의 전환 과정</strong></p>\n<ul>\n<li><strong>클라이언트 컴파일러(C1)</strong> 에서 <strong>컴파일된 코드가 서버 컴파일러(C2)</strong> 에서 다시 최적화될 때, 기존 코드는 더 이상 사용되지 않음.</li>\n</ul>\n<p><strong>역최적화의 처리 방식</strong></p>\n<ul>\n<li>기존 컴파일된 코드는 <strong>\"진입 불가\"</strong> 상태가 되며, 이후 새로운 최적화 코드가 생성됨.</li>\n<li>일정 시간이 지나면 **\"좀비 코드\"**로 변환되어 코드 캐시에서 제거됨.</li>\n</ul>\n<p><strong>주의할 점</strong></p>\n<ul>\n<li>역최적화가 자주 발생하면 오히려 <strong>JVM 성능이 불안정해질 수 있음</strong>.</li>\n<li>특정 코드를 너무 자주 최적화하고 폐기하는 경우 <strong>불필요한 오버헤드 발생</strong> 가능.</li>\n</ul>\n<h4>JVM 튜닝 옵션</h4>\n<table>\n<thead>\n<tr>\n<th>튜닝 옵션</th>\n<th>설명</th>\n<th>추천 값</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>-XX:CICompilerCount=N</strong></td>\n<td>컴파일 스레드 개수 조정</td>\n<td>CPU 개수에 맞춰 설정</td>\n</tr>\n<tr>\n<td><strong>-XX:MaxInlineSize=N</strong></td>\n<td>기본 인라이닝 크기 조정</td>\n<td>35~50</td>\n</tr>\n<tr>\n<td><strong>-XX:MaxFreqInlineSize=N</strong></td>\n<td>자주 호출되는 메서드 인라이닝 크기 조정</td>\n<td>325~400</td>\n</tr>\n<tr>\n<td><strong>-XX:+DoEscapeAnalysis</strong></td>\n<td>탈출 분석 활성화</td>\n<td>기본 활성화</td>\n</tr>\n<tr>\n<td><strong>-XX:ReservedCodeCacheSize=N</strong></td>\n<td>코드 캐시 크기 조정</td>\n<td>기본값의 2~4배 (예: 512MB)</td>\n</tr>\n<tr>\n<td><strong>-XX:CompileThreshold=N</strong></td>\n<td>C2로 전환하는 실행 횟수 조정</td>\n<td>기본값(10,000) → 5,000~7,000</td>\n</tr>\n<tr>\n<td><strong>-XX:+TieredCompilation</strong></td>\n<td>티어드 컴파일 활성화</td>\n<td>기본 활성화 (JVM 8 이상)</td>\n</tr>\n<tr>\n<td><strong>-XX:LoopUnrollLimit</strong></td>\n<td>OSR 최적화</td>\n<td>50~100</td>\n</tr>\n</tbody>\n</table>\n<h3>웜업(Warm-up) 과정</h3>\n<p><strong>자바 프로그램이 실행되면 처음에는 인터프리터 방식으로 실행되다가, 일정 시간이 지나야 JIT 컴파일러가 동작하면서 성능이 최적화 된다는 것을 위에서 배웠습니다.</strong></p>\n<p>이 과정에서 발생하는 초기 성능 저하를 <strong>웜업(Warm-up)</strong> 과정이라고 합니다.</p>\n<h4>웜업이 필요한 이유</h4>\n<ol>\n<li>처음에는 <strong>인터프리터 방식으로 실행</strong>하여 빠르게 시작합니다.</li>\n<li>JVM이 <strong>자주 실행되는 메서드를 감지(프로파일링)</strong> 합니다.</li>\n<li>JIT 컴파일러가 <strong>핫스팟 코드</strong>를 찾아 네이티브 코드로 변환합니다.</li>\n<li>실행 속도가 점점 향상됩니다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">WarmUpTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">long</span> startTime<span class=\"token punctuation\">,</span> endTime<span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// 초기 실행 시간 측정</span>\n        startTime <span class=\"token operator\">=</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">nanoTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100_000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">compute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        endTime <span class=\"token operator\">=</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">nanoTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"초기 실행 시간: \"</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>endTime <span class=\"token operator\">-</span> startTime<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">1_000_000.0</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" ms\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// 웜업 진행 (JIT 컴파일러가 최적화할 기회를 줌)</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">1_000_000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">compute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">// 최적화 후 실행 속도 측정</span>\n        startTime <span class=\"token operator\">=</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">nanoTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100_000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">compute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        endTime <span class=\"token operator\">=</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">nanoTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"최적화 후 실행 시간: \"</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>endTime <span class=\"token operator\">-</span> startTime<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">1_000_000.0</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" ms\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">compute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            sum <span class=\"token operator\">+=</span> i<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> sum<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4>실행 결과 예시</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">초기 실행 시간: 50.2 ms\n최적화 후 실행 시간: 12.8 ms</code></pre></div>\n<ul>\n<li>처음 실행할 때는 인터프리터 방식으로 실행되므로 실행 속도가 느립니다.</li>\n<li>일정 시간이 지나면서 JIT 컴파일러가 최적화를 수행하여 실행 속도가 크게 향상됩니다.</li>\n</ul>\n<h3>웜업 시간을 줄이는 방법</h3>\n<p>JIT 컴파일러는 실행 중 성능 최적화를 수행하지만, 초기 웜업 시간이 길어질 경우 성능 저하가 발생할 수 있습니다. 이를 해결하는 방법은 다음과 같습니다.</p>\n<p><strong>티어드 컴파일(Tiered Compilation) 사용</strong></p>\n<ul>\n<li><strong>-XX:+TieredCompilation 옵션</strong>을 사용하면 인터프리터와 JIT 컴파일을 동시에 활용하여 웜업 시간을 줄일 수 있습니다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">java</span> <span class=\"token parameter variable\">-XX:+TieredCompilation</span> WarmUpTest</code></pre></div>\n<p><strong>AOT 컴파일 활용</strong></p>\n<ul>\n<li><strong>jaotc(Java Ahead-Of-Time Compiler)</strong> 를 사용하여 실행 전에 미리 네이티브 코드로 변환할 수 있습니다.</li>\n</ul>\n<p><strong>AOT(Ahead-of-Time) 컴파일</strong>은 <strong>자바 프로그램을 실행하기 전에 미리 기계어 코드로 변환하는 방식의 컴파일 기법</strong>입니다.<br>\n즉, <strong>JIT(Just-In-Time) 컴파일처럼 런타임에서 코드가 컴파일되는 것이 아니라, 애플리케이션 실행 전에 미리 컴파일</strong>하여 성능을 향상시키는 방법입니다.</p>\n<h2>마무리</h2>\n<p>JVM의 JIT 컴파일러는 Java의 성능을 크게 향상시키는 핵심 기술입니다. 특히 티어드 컴파일을 통해 빠른 시작 속도와 높은 최적화 성능을 모두 얻을 수 있습니다.</p>\n<p>효과적인 JVM 튜닝을 위해서는:</p>\n<ol>\n<li>애플리케이션의 특성을 파악하고</li>\n<li>적절한 JIT 컴파일러를 선택하며</li>\n<li>필요한 경우 JVM 옵션을 조정하여 최적화하는 것이 중요합니다.</li>\n</ol>\n<p>이러한 이해를 바탕으로 Java 애플리케이션의 성능을 한 단계 더 향상시킬 수 있을 것입니다.</p>","frontmatter":{"title":"JVM과 JIT 컴파일러: 자바 성능 최적화의 핵심","date":"January 12, 2025","description":"JVM의 JIT 컴파일러 동작 원리와 티어드 컴파일, 최적화 기법들을 심도있게 다룹니다"}},"previous":null,"next":null},"pageContext":{"id":"2082780b-02d4-51da-9cf9-d53183ff2475","previousPostId":null,"nextPostId":null}},"staticQueryHashes":["3257411868","3517523002"],"slicesMap":{}}