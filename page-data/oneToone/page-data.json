{"componentChunkName":"component---src-templates-blog-post-js","path":"/oneToone/","result":{"data":{"site":{"siteMetadata":{"title":"GoToBill"}},"markdownRemark":{"id":"88c8c3ad-07c2-5c35-a23f-b46b8737daab","excerpt":"문제 상황 User와 UserProfile이 양방향 @OneToOne 관계로 매핑되어 있을 때, User를 조회하면 UserProfile에 대한 추가 쿼리가 발생하는 N+1 문제를 겪었습니다. 문제 발생 원인 1. @OneToOne…","html":"<h2>문제 상황</h2>\n<p>User와 UserProfile이 양방향 @OneToOne 관계로 매핑되어 있을 때, User를 조회하면 UserProfile에 대한 추가 쿼리가 발생하는 N+1 문제를 겪었습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// User 엔티티</span>\n<span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">User</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Id</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@OneToOne</span><span class=\"token punctuation\">(</span>mappedBy <span class=\"token operator\">=</span> <span class=\"token string\">\"user\"</span><span class=\"token punctuation\">,</span> fetch <span class=\"token operator\">=</span> <span class=\"token class-name\">FetchType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">LAZY</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">UserProfile</span> userProfile<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// UserProfile 엔티티</span>\n<span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserProfile</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Id</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@OneToOne</span>\n    <span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"user_id\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">User</span> user<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>문제 발생 원인</h2>\n<h3>1. @OneToOne 연관관계 주인이 아닌 쪽의 프록시 생성 불가</h3>\n<blockquote>\n<p><strong>핵심 문제</strong>\nJPA는 @OneToOne 관계에서 연관관계 주인이 아닌 쪽(mappedBy를 사용하는 쪽)은 프록시 객체를 생성할 수 없습니다.</p>\n</blockquote>\n<p>User 엔티티가 로드될 때:</p>\n<ul>\n<li>JPA는 UserProfile이 존재하는지 확인하기 위해 무조건 쿼리를 실행</li>\n<li>FetchType.LAZY를 설정해도 프록시 생성이 불가능하므로 의미가 없음</li>\n<li>존재하면 프록시 객체, 존재하지 않으면 null을 설정해야 하는데 이를 확인하려면 쿼리가 필요</li>\n</ul>\n<h3>2. @Data 어노테이션의 부작용</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Data</span>  <span class=\"token comment\">// 모든 필드에 대한 getter/setter 자동 생성</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">User</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">UserProfile</span> userProfile<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p><strong>주의사항</strong>\n@Data 어노테이션은 모든 필드에 대한 getter를 생성하므로, JSON 직렬화나 toString() 호출 시 의도치 않게 UserProfile에 접근하게 됩니다.</p>\n</blockquote>\n<h2>실제 발생한 쿼리</h2>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 1. CustomerFeedback 조회 (User JOIN FETCH 포함)</span>\n<span class=\"token keyword\">SELECT</span> cf<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> u<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> fi<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> su<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> feedback cf\n<span class=\"token keyword\">LEFT</span> <span class=\"token keyword\">JOIN</span> users u <span class=\"token keyword\">ON</span> cf<span class=\"token punctuation\">.</span>user_id <span class=\"token operator\">=</span> u<span class=\"token punctuation\">.</span>user_id\n<span class=\"token keyword\">LEFT</span> <span class=\"token keyword\">JOIN</span> food_item fi <span class=\"token keyword\">ON</span> cf<span class=\"token punctuation\">.</span>food_id <span class=\"token operator\">=</span> fi<span class=\"token punctuation\">.</span>food_id\n<span class=\"token keyword\">LEFT</span> <span class=\"token keyword\">JOIN</span> store s <span class=\"token keyword\">ON</span> cf<span class=\"token punctuation\">.</span>store_id <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span>store_id\n<span class=\"token keyword\">LEFT</span> <span class=\"token keyword\">JOIN</span> survey su <span class=\"token keyword\">ON</span> cf<span class=\"token punctuation\">.</span>survey_id <span class=\"token operator\">=</span> su<span class=\"token punctuation\">.</span>survey_id\n<span class=\"token keyword\">WHERE</span> cf<span class=\"token punctuation\">.</span>store_id <span class=\"token operator\">=</span> ? <span class=\"token operator\">AND</span> cf<span class=\"token punctuation\">.</span>is_active <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- 2. 각 User마다 UserProfile 조회 (N개)</span>\n<span class=\"token keyword\">SELECT</span> up<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> user_profile up <span class=\"token keyword\">WHERE</span> up<span class=\"token punctuation\">.</span>user_id <span class=\"token operator\">=</span> ?<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">SELECT</span> up<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> user_profile up <span class=\"token keyword\">WHERE</span> up<span class=\"token punctuation\">.</span>user_id <span class=\"token operator\">=</span> ?<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">SELECT</span> up<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> user_profile up <span class=\"token keyword\">WHERE</span> up<span class=\"token punctuation\">.</span>user_id <span class=\"token operator\">=</span> ?<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- ... (N번 반복)</span></code></pre></div>\n<h2>해결 방법</h2>\n<h3>방법 1: Fetch Join에 UserProfile 포함</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Query</span><span class=\"token punctuation\">(</span><span class=\"token triple-quoted-string string\">\"\"\"\n    SELECT cf FROM CustomerFeedback cf\n    LEFT JOIN FETCH cf.user u\n    LEFT JOIN FETCH u.userProfile\n    WHERE cf.store.id = :storeId\n    \"\"\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token class-name\">Page</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">CustomerFeedback</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">findByStoreIdWithDetails</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@Param</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"storeId\"</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">Long</span> storeId<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Pageable</span> pageable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>방법 2: 단방향 관계로 변경</h3>\n<blockquote>\n<p><strong>Best Practice</strong>\n양방향 관계가 꼭 필요하지 않다면 단방향으로 변경하는 것이 가장 깨끗한 해결책입니다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">User</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Id</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// UserProfile 참조 제거</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserProfile</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@OneToOne</span>\n    <span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"user_id\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">User</span> user<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 단방향 관계만 유지</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>방법 3: @JsonIgnore 또는 @ToString.Exclude 사용</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token annotation punctuation\">@Getter</span>\n<span class=\"token annotation punctuation\">@Setter</span>\n<span class=\"token annotation punctuation\">@ToString.Exclude</span>  <span class=\"token comment\">// toString()에서 UserProfile 제외</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">User</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@OneToOne</span><span class=\"token punctuation\">(</span>mappedBy <span class=\"token operator\">=</span> <span class=\"token string\">\"user\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token annotation punctuation\">@JsonIgnore</span>  <span class=\"token comment\">// JSON 직렬화에서 제외</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">UserProfile</span> userProfile<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>방법 4: @OneToOne 대신 @ManyToOne 사용</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserProfile</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@ManyToOne</span>  <span class=\"token comment\">// 실제로는 1:1이지만 ManyToOne으로 매핑</span>\n    <span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"user_id\"</span><span class=\"token punctuation\">,</span> unique <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// unique 제약조건으로 1:1 보장</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">User</span> user<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>성능 비교</h2>\n<table>\n<thead>\n<tr>\n<th>방법</th>\n<th>쿼리 수</th>\n<th>장점</th>\n<th>단점</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Fetch Join</strong></td>\n<td>1</td>\n<td>한 번의 쿼리로 모든 데이터 조회</td>\n<td>페이징 시 메모리에서 처리</td>\n</tr>\n<tr>\n<td><strong>단방향 관계</strong></td>\n<td>1</td>\n<td>N+1 문제 원천 차단</td>\n<td>양방향 탐색 불가</td>\n</tr>\n<tr>\n<td><strong>@JsonIgnore</strong></td>\n<td>N+1</td>\n<td>구현이 간단</td>\n<td>근본적 해결책이 아님</td>\n</tr>\n<tr>\n<td><strong>@ManyToOne</strong></td>\n<td>1</td>\n<td>Lazy Loading 정상 작동</td>\n<td>의미적으로 부정확</td>\n</tr>\n</tbody>\n</table>\n<h2>결론</h2>\n<h3>권장 사항</h3>\n<ol>\n<li><strong>@OneToOne 양방향 관계는 가능한 피하고 단방향으로 설계</strong></li>\n<li><strong>양방향이 필요하다면 Fetch Join 사용</strong></li>\n<li><strong>@Data 어노테이션 대신 필요한 어노테이션만 선택적으로 사용</strong></li>\n<li><strong>DTO 변환 시 필요한 필드만 명시적으로 접근</strong></li>\n</ol>\n<blockquote>\n<p><strong>핵심 정리</strong>\n@OneToOne 양방향 관계는 JPA의 구조적 한계로 인해 N+1 문제가 발생하기 쉽습니다. 설계 단계에서부터 이를 고려하여 단방향 관계로 설계하거나, 불가피한 경우 Fetch Join을 통해 해결하는 것이 좋습니다.</p>\n</blockquote>\n<h3>추가 고려사항</h3>\n<ul>\n<li><strong>캐싱 전략</strong>: 자주 조회되는 UserProfile의 경우 2차 캐시 활용 고려</li>\n<li><strong>배치 페치 사이즈</strong>: <code class=\"language-text\">@BatchSize</code> 어노테이션으로 N+1 쿼리 수 감소</li>\n<li><strong>프로젝션</strong>: 필요한 필드만 조회하는 DTO 프로젝션 활용</li>\n</ul>","wordCount":{"words":278},"frontmatter":{"title":"JPA @OneToOne 양방향 관계에서 발생하는 N+1 문제 해결 방법","date":"September 21, 2025","description":"JPA에서 @OneToOne 양방향 관계 사용 시 발생하는 N+1 문제의 원인과 다양한 해결 방법을 실제 사례와 함께 설명합니다."}},"previous":{"fields":{"slug":"/TCP/"},"frontmatter":{"title":"네트워크 기초 정리"}},"next":{"fields":{"slug":"/async/"},"frontmatter":{"title":"비동기 처리: 메시지 큐부터 CDC까지 5가지 구현 방법"}}},"pageContext":{"id":"88c8c3ad-07c2-5c35-a23f-b46b8737daab","previousPostId":"2d2d4eb1-9394-5be7-b05a-2d63b09febde","nextPostId":"7ebaac03-1a97-518a-8709-97b4c18db099"}},"staticQueryHashes":["3257411868","3517523002"],"slicesMap":{}}