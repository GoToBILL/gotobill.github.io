{"componentChunkName":"component---src-templates-blog-post-js","path":"/mysql-part4/","result":{"data":{"site":{"siteMetadata":{"title":"GoToBill"}},"markdownRemark":{"id":"0f5161ec-2733-56c1-b9de-d2120698a099","excerpt":"MySQL의 전체 구조  MySQL 엔진 커넥션 핸들러 SQL 파서 및 전처리기 옵티마이저 스토리지 엔진 디스크 스토리지에 write, read MySQL 엔진 하나에 여러 스토리지 엔진을 동시에 사용할 수 있음 각 스토리지 엔진은 성능 향상을 위해 키 캐시 (MyISAM…","html":"<h2>MySQL의 전체 구조</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/50162303799fd4577f72c8ca362a1592/ea64c/%EC%A0%84%EC%B2%B4%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 97.46835443037975%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAACoUlEQVR42l2UyWpyQRCFfUTfIbu8QpaCko2PYAgEBFEIghvJIgsRNMY5cc7gFDGawThGY4WvfqqJ/4Wyr9Xdp0+dU7c92+1WVquVBu+bzUZ2u528vb1Jo9GQdrstT09Psl6vdc7i5+dHc/8/ntlsJi8vLwqQzWal1WpJrVaTer0ut7e3Eo/H9b1YLEqv15Nut6trwuGwPD4+yvf39yHgYrFQBtPpVDfncjkpl8uaSyaTEgwGpd/vKxg53u/v7yUQCCggbA8Av76+5OHhQU8eDocHAfPRaKTvg8HA5RhfX18VEHkOAEksl0uBqcV8PldNkQPmaGX5v2vI7/d7F44hC0xsFqELh4zHY2X08fHh5mzEFKqaTCZq5ufn5z9AzHh/f1cAA2ckj26dTkd1Yx5WBMypAC2RBEDWO0AmcBF3MQQQAncJ8tVq1Y24zHypVFJt0ZNDXMmUBn0m6Dt0oxT+s9HmMQGn2YMMAHMgoA7Q6APEAhw/PT2V4+Nj7UMcDYVCcnFxofPNZlP8fr/4fD5ljBxIhtbI4cGA6+trOTs7c+UA6PV65fLyUjdEIhFJJBLKOJ1Oy9HRkZycnKg85OgUKgHYw08mk1E9CPQsFAoud3d3p6woDQC0vrq6klQqJfl8XuUBEHMwzoMWJCmVU9AHVoAwBwPAyGGguU5QkWnvNEQ/yozFYhKNRnUhDM7Pz/VyQEe+Wz5De6yJMYiK0A8izmXE5GSM4QCMoFTkYA629KQB2fj8/KzOA+gam/agpEqlopqxgP/oAxCHcGFQnnWCaXpzc6MtZZ+vAppOMLCbxK4wSuLLQR82AkSekd4zAujovmUWg85mnIIZC2GFhjzMUx5gdACH/tWQjnCA6GT3HCexkbB3RgtKJsxpZIC53ToA/gIja2stG6PlrgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"전체 아키텍처\"\n        title=\"\"\n        src=\"/static/50162303799fd4577f72c8ca362a1592/f058b/%EC%A0%84%EC%B2%B4%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98.png\"\n        srcset=\"/static/50162303799fd4577f72c8ca362a1592/c26ae/%EC%A0%84%EC%B2%B4%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98.png 158w,\n/static/50162303799fd4577f72c8ca362a1592/6bdcf/%EC%A0%84%EC%B2%B4%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98.png 315w,\n/static/50162303799fd4577f72c8ca362a1592/f058b/%EC%A0%84%EC%B2%B4%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98.png 630w,\n/static/50162303799fd4577f72c8ca362a1592/40601/%EC%A0%84%EC%B2%B4%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98.png 945w,\n/static/50162303799fd4577f72c8ca362a1592/ea64c/%EC%A0%84%EC%B2%B4%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98.png 1116w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>MySQL 엔진</h3>\n<ul>\n<li><strong>커넥션 핸들러</strong></li>\n<li><strong>SQL 파서 및 전처리기</strong></li>\n<li><strong>옵티마이저</strong></li>\n</ul>\n<h3>스토리지 엔진</h3>\n<ul>\n<li>디스크 스토리지에 write, read</li>\n<li>MySQL 엔진 하나에 여러 스토리지 엔진을 동시에 사용할 수 있음</li>\n<li>각 스토리지 엔진은 성능 향상을 위해 <strong>키 캐시</strong> (MyISAM 스토리지 엔진)나 <strong>InnoDB 버퍼 풀</strong> (InnoDB 스토리지 엔진)과 같은 기능을 내장</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> test_table <span class=\"token punctuation\">(</span>fd1 <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span> fd2 <span class=\"token keyword\">INT</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">ENGINE</span><span class=\"token operator\">=</span><span class=\"token keyword\">INNODB</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>핸들러 API</h3>\n<ul>\n<li>MySQL 엔진의 쿼리 실행기가 각 스토리지 엔진에 요청을 보낼 때 사용되는 API</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. MySQL 엔진이 쿼리를 파싱하고 최적화합니다\n\n2. 실행 엔진이 최적화된 계획에 따라 각 스토리지 엔진에 핸들러 요청을 보냅니다\n\n3. 스토리지 엔진이 핸들러 API를 통해 실제 데이터 작업을 수행합니다\n\n4. 결과를 다시 MySQL 엔진으로 전달합니다</code></pre></div>\n<blockquote>\n<p>핸들러 API를 통해 얼마나 많은 작업이 있었나?</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">GLOBAL</span> <span class=\"token keyword\">STATUS</span> <span class=\"token operator\">LIKE</span> <span class=\"token string\">'Handler%'</span><span class=\"token punctuation\">;</span></code></pre></div>\n</blockquote>\n<h2>MySQL 스레딩 구조</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/0f218eb4e70f099269af67f2a83d1bc4/9cea8/%EC%8A%A4%EB%A0%88%EB%93%9C%EA%B5%AC%EC%A1%B0.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.65822784810127%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB7ElEQVR42lWTx6pCQRBE7z+7dOWPuBFc6kI34kIUcwZzzlkx59CP0zDiGxjm2t1TXVU9WvKzDoeDbLdb2e12373f778xTjZ1vzXEqPt8PmIZsMfjIePxWJbLpUynUz0nk4kMBgP9JrdYLHQPh0OZzWYam8/nmm+323p+Aa/Xqybp2Gq1pNvt6qVOpyOn00lj/X5f2RCDEft4PMr9ftf8aDQSCwAWlwC4XC56svgGmGa3201/c/Z6PW2MKsDe77fWwdiCqvHPSK3X61pE92g0KslkUtbrtTKkHivK5bIy4k6j0VAblCEFmElHAqzn8ymlUkkqlYr4/X7NI3O1WmmeO7A7n88KziKvDJHBQgqARh7s6J5OpzUGCB5TDzsUAcA3alClgGYor9dLvalWq5LP5yUSiUgqlZJarSbFYvG7YZ7NZiUejysYcokVCgW1xUKOGcBms9Fn4nA4xG63i81mU4YszIcBDb1erzidTgkGgzpMyDSbTZX/jyFsEomEuFwucbvdeikUCikL/MzlchKLxcTn84nH45FAIKDskMvg/r1DBoGHdOJEDhZQTAzmZpI8EYBoZGqoR+UXkIkxOQbBxr9MJqN+McHfOoCIh8NhHQ624R+W/ZMMEAxgwsuHGad5EmzysCJGzvwNUYCff0R1ug1d8XUPAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mysql 스레드 구조\"\n        title=\"\"\n        src=\"/static/0f218eb4e70f099269af67f2a83d1bc4/f058b/%EC%8A%A4%EB%A0%88%EB%93%9C%EA%B5%AC%EC%A1%B0.png\"\n        srcset=\"/static/0f218eb4e70f099269af67f2a83d1bc4/c26ae/%EC%8A%A4%EB%A0%88%EB%93%9C%EA%B5%AC%EC%A1%B0.png 158w,\n/static/0f218eb4e70f099269af67f2a83d1bc4/6bdcf/%EC%8A%A4%EB%A0%88%EB%93%9C%EA%B5%AC%EC%A1%B0.png 315w,\n/static/0f218eb4e70f099269af67f2a83d1bc4/f058b/%EC%8A%A4%EB%A0%88%EB%93%9C%EA%B5%AC%EC%A1%B0.png 630w,\n/static/0f218eb4e70f099269af67f2a83d1bc4/40601/%EC%8A%A4%EB%A0%88%EB%93%9C%EA%B5%AC%EC%A1%B0.png 945w,\n/static/0f218eb4e70f099269af67f2a83d1bc4/78612/%EC%8A%A4%EB%A0%88%EB%93%9C%EA%B5%AC%EC%A1%B0.png 1260w,\n/static/0f218eb4e70f099269af67f2a83d1bc4/9cea8/%EC%8A%A4%EB%A0%88%EB%93%9C%EA%B5%AC%EC%A1%B0.png 1278w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>프로세스가 아닌 <strong>스레드 기반</strong>으로 작동</li>\n<li><strong>포그라운드</strong> (Foreground)와 <strong>백그라운드</strong> (Background)</li>\n</ul>\n<blockquote>\n<p>MySQL에서 실행 중인 스레드의 목록</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> thread_id<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">type</span><span class=\"token punctuation\">,</span> processlist_user<span class=\"token punctuation\">,</span> processlist_host\n<span class=\"token keyword\">FROM</span> performance_shcema<span class=\"token punctuation\">.</span>threads <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> <span class=\"token keyword\">type</span><span class=\"token punctuation\">,</span> thread_id<span class=\"token punctuation\">;</span></code></pre></div>\n</blockquote>\n<h3>포그라운드 스레드(클라이언트 스레드)</h3>\n<ul>\n<li>\n<p><strong>MySQL 서버에 접속한 클라이언트 수만큼 존재</strong></p>\n</li>\n<li>\n<p>각 클라이언트 사용자가 요청하는 쿼리를 처리</p>\n</li>\n<li>\n<p>커넥션을 종료하면 <strong>스레드 캐시</strong> (Thread cache)로 돌아감</p>\n<ul>\n<li>이미 일정 개수의 스레드 캐시가 있다면 종료</li>\n<li>스레드 캐시의 최대 스레드 개수는 <code class=\"language-text\">thread_cache_size</code> 시스템 변수로 설정</li>\n</ul>\n</li>\n<li>\n<p>데이터를 MySQL의 <strong>데이터 버퍼</strong>나 <strong>캐시</strong>로부터 가져오고, 없으면 직접 <strong>디스크</strong>나 <strong>인덱스 파일</strong>로부터 가져옴</p>\n<p><strong>데이터 버퍼</strong>: InnoDB의 버퍼 풀(Buffer Pool), MyISAM의 키 캐시(Key Cache)<br>\n<strong>캐시</strong>: 메모리에 캐싱된 데이터 페이지와 인덱스</p>\n<ul>\n<li>\n<p><strong>MyISAM 테이블은 쓰기 작업까지 포그라운드 스레드가 처리</strong></p>\n<blockquote>\n<p>포그라운드 스레드(클라이언트 스레드)가 <strong>디스크 I/O까지 직접 담당</strong><br>\n테이블 락으로 인해 쓰기 중에는 다른 작업이 대기<br>\n<strong>Table Level Locking</strong>을 사용하여 전체 테이블을 잠금</p>\n</blockquote>\n</li>\n<li>\n<p><strong>InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리</strong></p>\n<blockquote>\n<p>포그라운드 스레드는 <strong>변경사항을 버퍼 풀(메모리)에만 기록하고 즉시 반환</strong>\n실제 디스크 쓰기는 백그라운드 스레드가 나중에 처리 (쓰기 지연)</p>\n<p><strong>MyISAM vs InnoDB 비교</strong></p>\n<ul>\n<li>MyISAM: 디스크까지 직접 처리 → 느림, Table Level Locking</li>\n<li>InnoDB: 메모리까지만 처리 → 빠름, Row Level Locking</li>\n<li>자세한 동작 방식은 아래 백그라운드 스레드 섹션 참고</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h3>백그라운드 스레드</h3>\n<p>백그라운드 스레드는 <strong>청소부</strong>와 같은 역할입니다. 포그라운드 스레드가 급하게 메모장(버퍼 풀)에 메모만 남기고 가면, 백그라운드 스레드가 나중에 그 메모를 정리해서 안전한 금고(디스크)에 보관합니다.</p>\n<h4>주요 백그라운드 스레드 종류</h4>\n<p><strong>로그 스레드</strong> (Log Thread)</p>\n<p>변경 내역(Redo Log, Undo Log)을 디스크에 기록하여 장애 복구와 데이터 일관성을 보장합니다.</p>\n<p>비유: 회사의 <strong>작업 일지</strong>를 기록하는 담당자</p>\n<ul>\n<li>누가, 언제, 무엇을 변경했는지 기록</li>\n<li>문제 발생 시 이 기록을 보고 복구</li>\n</ul>\n<p><strong>쓰기 스레드</strong> (Write Thread)</p>\n<p>버퍼 풀의 더티 페이지(변경된 데이터)를 실제 데이터 파일로 내려씁니다.</p>\n<p>비유: <strong>정리 담당자</strong></p>\n<ul>\n<li>메모장에 적힌 변경사항을 실제 파일 캐비닛(디스크)에 정리</li>\n<li>여러 건을 모아서 한 번에 처리 (배치 처리로 효율성 향상)</li>\n</ul>\n<p>설정 예시:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 일반 디스크: 2~4개, 고성능 SSD: 4개 이상 권장</span>\n<span class=\"token keyword\">SHOW</span> VARIABLES <span class=\"token operator\">LIKE</span> <span class=\"token string\">'innodb_write_io_threads'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">SET</span> <span class=\"token keyword\">GLOBAL</span> innodb_write_io_threads <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>읽기 스레드</strong> (Read Thread)</p>\n<p>데이터를 디스크에서 버퍼 풀로 읽어오는 작업을 <strong>보조</strong>합니다.</p>\n<p><strong>쓰기 vs 읽기 스레드의 결정적 차이</strong></p>\n<p>쓰기 스레드:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">포그라운드 → 메모리에만 기록 → 즉시 \"완료\" 반환 (클라이언트 대기 안 함)\n백그라운드 → 나중에 디스크에 기록</code></pre></div>\n<p>읽기 스레드:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">포그라운드 → 버퍼 풀 확인\n  - 있으면: 즉시 반환\n  - 없으면: 포그라운드가 직접 디스크에서 읽어옴 (클라이언트 대기)\n백그라운드 → 병렬 처리로 속도만 향상 (클라이언트는 여전히 대기)</code></pre></div>\n<p><strong>읽기 스레드는 언제 사용되나?</strong></p>\n<p>단일 행 조회:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> users <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 1개 페이지만 필요</span>\n<span class=\"token comment\">-- 포그라운드 스레드가 직접 디스크에서 읽어옴</span>\n<span class=\"token comment\">-- 백그라운드 스레드 개입 안 함</span></code></pre></div>\n<p>대량 데이터 조회 (테이블 풀 스캔):</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> users<span class=\"token punctuation\">;</span>  <span class=\"token comment\">-- 100만 건</span>\n<span class=\"token comment\">-- 수천 개 페이지 필요</span>\n<span class=\"token comment\">-- 포그라운드 스레드 혼자서는 느림</span>\n\n<span class=\"token comment\">-- 백그라운드 읽기 스레드 4개 활용</span>\n<span class=\"token comment\">-- 포그라운드: 페이지 1~25 담당</span>\n<span class=\"token comment\">-- 백그라운드1: 페이지 26~50 담당</span>\n<span class=\"token comment\">-- 백그라운드2: 페이지 51~75 담당</span>\n<span class=\"token comment\">-- 백그라운드3: 페이지 76~100 담당</span>\n<span class=\"token comment\">-- → 병렬 처리로 더 빠름 (하지만 클라이언트는 대기)</span></code></pre></div>\n<p><strong>핵심 정리</strong></p>\n<p>읽기는 본질적으로 <strong>클라이언트가 지금 당장 필요</strong>하기 때문에 백그라운드로 미룰 수 없습니다. 읽기 스레드는 단지 <strong>병렬 처리로 속도를 높여줄 뿐</strong>입니다.</p>\n<p>설정 예시:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 보통 4개면 충분</span>\n<span class=\"token keyword\">SHOW</span> VARIABLES <span class=\"token operator\">LIKE</span> <span class=\"token string\">'innodb_read_io_threads'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">SET</span> <span class=\"token keyword\">GLOBAL</span> innodb_read_io_threads <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>기타 스레드</strong></p>\n<ul>\n<li><strong>인서트 버퍼 병합 스레드</strong>: 인덱스 삽입 작업을 모아서 일괄 처리</li>\n<li><strong>잠금/데드락 모니터링 스레드</strong>: 교착 상태 감지 및 해결</li>\n</ul>\n<h4>왜 백그라운드 스레드가 중요한가?</h4>\n<p><strong>포그라운드 vs 백그라운드 역할 분담</strong></p>\n<p><code class=\"language-text\">포그라운드 스레드가 디스크 I/O까지 직접 하면:</code></p>\n<ul>\n<li>디스크는 느리기 때문에 클라이언트가 오래 대기</li>\n<li>동시에 많은 요청 처리 불가</li>\n</ul>\n<p><code class=\"language-text\">백그라운드로 분리하면:</code></p>\n<ul>\n<li>포그라운드는 빠르게 메모리 작업만 하고 응답</li>\n<li>느린 디스크 작업은 백그라운드가 알아서 처리</li>\n<li>동시 처리 능력 대폭 향상</li>\n</ul>\n<p><strong>실제 시나리오</strong></p>\n<p>커피숍으로 비유:</p>\n<ol>\n<li>\n<p><strong>포그라운드 스레드 = 주문 받는 직원</strong></p>\n<ul>\n<li>고객 주문을 메모장에 적고 즉시 \"주문 완료!\"</li>\n<li>실제 커피는 안 만듦 (빠른 응답)</li>\n</ul>\n</li>\n<li>\n<p><strong>백그라운드 스레드 = 바리스타</strong></p>\n<ul>\n<li>메모장 보고 실제 커피 제조</li>\n<li>고객은 기다리지 않음</li>\n</ul>\n</li>\n<li>\n<p><strong>MyISAM 방식 = 주문 받는 직원이 커피까지 만듦</strong></p>\n<ul>\n<li>한 고객당 시간 오래 걸림</li>\n<li>뒤 고객들은 계속 대기</li>\n</ul>\n</li>\n</ol>\n<h4>스레드 개수 설정 가이드</h4>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 고성능 스토리지(SSD) 환경</span>\n<span class=\"token keyword\">SET</span> <span class=\"token keyword\">GLOBAL</span> innodb_write_io_threads <span class=\"token operator\">=</span> <span class=\"token number\">8</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">SET</span> <span class=\"token keyword\">GLOBAL</span> innodb_read_io_threads <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- 일반 환경</span>\n<span class=\"token keyword\">SET</span> <span class=\"token keyword\">GLOBAL</span> innodb_write_io_threads <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">SET</span> <span class=\"token keyword\">GLOBAL</span> innodb_read_io_threads <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>핵심 포인트</strong></p>\n<ul>\n<li>읽기 작업은 주로 포그라운드 스레드가 처리 → 읽기 스레드는 많이 필요 없음</li>\n<li>쓰기 작업은 대부분 백그라운드로 처리 → 쓰기 스레드를 충분히 설정해야 병목 방지</li>\n</ul>\n<h4>쓰기 버퍼링 (Write Buffering)</h4>\n<p><strong>핵심 개념</strong></p>\n<ul>\n<li>읽기 작업은 즉시 처리해야 함 (고객이 기다림)</li>\n<li>쓰기 작업은 지연해도 됨 (나중에 처리해도 문제없음)</li>\n</ul>\n<p><strong>MyISAM vs InnoDB</strong></p>\n<ul>\n<li><strong>MyISAM</strong>: 쓰기도 포그라운드 스레드가 즉시 디스크에 기록 → 느림</li>\n<li><strong>InnoDB</strong>: 메모리에 먼저 기록 후, 백그라운드 스레드가 일괄 처리 → 빠름</li>\n</ul>\n<p><strong>InnoDB UPDATE 쿼리 실행 시 전체 과정</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">BEGIN</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">UPDATE</span> users <span class=\"token keyword\">SET</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'John'</span> <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">COMMIT</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>1단계: UPDATE 실행 시점</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">① 포그라운드 스레드가 버퍼 풀에서 해당 페이지 찾기\n② 버퍼 풀의 데이터 수정 (더티 페이지로 표시)\n③ 리두 로그 버퍼에 물리적 변경사항 기록\n   예: \"페이지 100, 오프셋 50에 'John' 기록\"\n④ 바이너리 로그 캐시에 SQL 기록\n   예: \"UPDATE users SET name = 'John' WHERE id = 1\"</code></pre></div>\n<p><strong>2단계: COMMIT 시점 (중요!) - 포그라운드 스레드가 직접 처리</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">① 리두 로그 버퍼 → 리두 로그 파일(디스크)에 기록 \n   (WAL - Write Ahead Log 원칙)\n   → 포그라운드 스레드가 직접 기록 (동기적)\n\n② 바이너리 로그 캐시 → 바이너리 로그 파일(디스크)에 기록\n   → 포그라운드 스레드가 직접 기록 (동기적)\n\n③ 트랜잭션 커밋 완료\n④ 클라이언트에게 \"OK\" 응답</code></pre></div>\n<p><strong>3단계: 이후 백그라운드 처리 - 백그라운드 스레드가 처리</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">백그라운드 쓰기 스레드가 적절한 시점에\n버퍼 풀의 더티 페이지 → 실제 데이터 파일(디스크)에 기록 (비동기적)</code></pre></div>\n<p><strong>누가 무엇을 기록하나?</strong></p>\n<p><strong>포그라운드 스레드가 디스크에 기록 (COMMIT 시):</strong></p>\n<ul>\n<li>리두 로그 파일</li>\n<li>바이너리 로그 파일</li>\n<li>이유: 데이터 영속성 보장이 필요한 시점 (클라이언트가 대기)</li>\n</ul>\n<p><strong>백그라운드 스레드가 디스크에 기록 (나중에):</strong></p>\n<ul>\n<li>실제 데이터 파일</li>\n<li>이유: 리두 로그가 있으면 복구 가능하므로 굳이 기다릴 필요 없음</li>\n</ul>\n<p><strong>왜 이렇게 설계되었나?</strong></p>\n<p>COMMIT은 데이터 영속성 보장이 필수:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">만약 백그라운드가 로그 기록을 한다면?\n\n포그라운드: \"OK\" 응답 → 클라이언트는 성공으로 인식\n백그라운드: 아직 로그 기록 중...\n서버 다운! → 데이터 손실! (복구 불가능)</code></pre></div>\n<p>포그라운드가 로그를 디스크에 확실히 기록한 후 응답:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">포그라운드: 리두 로그 기록 완료 → 바이너리 로그 기록 완료 → \"OK\" 응답\n서버 다운해도 → 리두 로그로 복구 가능!</code></pre></div>\n<p><strong>핵심 정리</strong></p>\n<p>리두 로그가 먼저 디스크에 기록되는 이유:</p>\n<ul>\n<li>장애 발생 시 리두 로그만 있으면 복구 가능</li>\n<li>실제 데이터 파일은 나중에 써도 안전함</li>\n<li>이를 <strong>WAL</strong> (Write Ahead Log) 원칙이라고 함</li>\n</ul>\n<p>실제 데이터 파일 기록은 왜 백그라운드로?</p>\n<ul>\n<li>여러 변경사항을 모아서 한 번에 쓰면 효율적</li>\n<li>디스크 I/O 횟수 최소화</li>\n<li>클라이언트는 로그 기록만 기다리면 되므로 빠르게 응답 받음</li>\n</ul>\n<h2>메모리 할당 및 사용 구조</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1b34bfa50432dd088aceac929b66d335/dc333/%EB%A9%94%EB%AA%A8%EB%A6%AC%ED%95%A0%EB%8B%B9.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 58.86075949367089%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAABl0lEQVR42nWT544CMQyE9/3fih/0vvSOECABu0vvZU6fUTjujotkJXHs8YyTeKfTSev1WpvNxuy/9SfjfLlc2hyGoc7nszwch8NBu91Ox+NRFGB2hp9z1vv9/nVO8mKxUKlUUq/XUy6X03w+lwcyRvB4PFa73Va/39dwODQjeTabmY+4VqtlAKPRSN1uV41Gw/y+72s6ncqjyna7FQMZQRAoiiKbV6uV+dlT6H6/mw9VgDi5DJhOJpMnILIul4tVzOfzRj+ZTKpYLBoYibCiMMDlclnZbNZYsb9er6pUKt+AyL3dbiarUCgYEEm1Ws0YYRQjjsRUKqVqtWpxxMD8ByAMAaQfBDvQTCZjDH8Dwt4pqdfrlvuRIdXS6fQrmLXrpZOMTPwUI4acP5JdD5vNpjGEQTwetyQAXQ+5ABgBlEgkrDB7cl+AvB0AqTIYDOy2CEYyLQAMhjSf8Xg89D7cnp7bs4EBQPQIJ1W5QWYM1gDTV94lse/GRfImY7HYkyG/oNPpWCIsMPYYa/w8ZgoiD/B349wZSr8A9dBuj/684ysAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"메모리 할당\"\n        title=\"\"\n        src=\"/static/1b34bfa50432dd088aceac929b66d335/f058b/%EB%A9%94%EB%AA%A8%EB%A6%AC%ED%95%A0%EB%8B%B9.png\"\n        srcset=\"/static/1b34bfa50432dd088aceac929b66d335/c26ae/%EB%A9%94%EB%AA%A8%EB%A6%AC%ED%95%A0%EB%8B%B9.png 158w,\n/static/1b34bfa50432dd088aceac929b66d335/6bdcf/%EB%A9%94%EB%AA%A8%EB%A6%AC%ED%95%A0%EB%8B%B9.png 315w,\n/static/1b34bfa50432dd088aceac929b66d335/f058b/%EB%A9%94%EB%AA%A8%EB%A6%AC%ED%95%A0%EB%8B%B9.png 630w,\n/static/1b34bfa50432dd088aceac929b66d335/dc333/%EB%A9%94%EB%AA%A8%EB%A6%AC%ED%95%A0%EB%8B%B9.png 938w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>MySQL의 메모리는 크게 <strong>글로벌 메모리 영역</strong> (모든 스레드 공유)과 <strong>로컬 메모리 영역</strong> (각 클라이언트 전용)으로 나뉩니다.</p>\n<h3>어떤 메모리가 더 중요할까?</h3>\n<p>많은 사람들이 \"성능을 위해 글로벌 메모리(특히 InnoDB 버퍼 풀)가 중요하다\"고 말합니다. 맞는 말입니다. 하지만 <strong>운영 관점에서는 로컬 메모리가 훨씬 더 위험하고 중요합니다.</strong></p>\n<p><strong>왜 로컬 메모리가 더 중요한가?</strong></p>\n<p><strong>글로벌 메모리: 예측 가능하고 안전</strong></p>\n<ul>\n<li>서버 시작 시 한 번만 할당</li>\n<li>크기가 고정됨 (예: 버퍼 풀 8GB → 항상 8GB)</li>\n<li>모니터링과 관리가 쉬움</li>\n</ul>\n<p><strong>로컬 메모리: 예측 불가능하고 위험</strong></p>\n<ul>\n<li>클라이언트가 접속할 때마다 동적으로 할당</li>\n<li>총 메모리 = <code class=\"language-text\">클라이언트 수 × 버퍼 크기</code></li>\n<li>트래픽 급증 시 메모리 폭증 → 서버 다운 위험</li>\n</ul>\n<p><strong>실제 장애 시나리오</strong></p>\n<p>설정:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SET</span> <span class=\"token keyword\">GLOBAL</span> sort_buffer_size <span class=\"token operator\">=</span> <span class=\"token number\">10485760</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">-- 10MB로 설정</span></code></pre></div>\n<p>정상 상황:</p>\n<ul>\n<li>클라이언트 100개 접속</li>\n<li>메모리 사용: 100 × 10MB = 1GB (괜찮음)</li>\n</ul>\n<p>장애 상황:</p>\n<ul>\n<li>갑자기 이벤트로 트래픽 급증</li>\n<li>클라이언트 1000개 동시 접속</li>\n<li>메모리 사용: 1000 × 10MB = <strong>10GB 폭증!</strong></li>\n<li>서버 메모리 부족 → <strong>OOM (Out of Memory) 에러</strong></li>\n<li>MySQL 서버 다운 → 서비스 장애</li>\n</ul>\n<h3>글로벌 메모리 영역</h3>\n<p><strong>특징</strong></p>\n<ul>\n<li>모든 클라이언트 스레드가 공유</li>\n<li>MySQL 서버 시작 시 한 번만 할당</li>\n<li>클라이언트 수와 무관하게 고정 크기</li>\n</ul>\n<h4>주요 메모리 영역</h4>\n<p><strong>InnoDB 버퍼 풀</strong></p>\n<p>데이터와 인덱스를 메모리에 캐싱하여 디스크 I/O 최소화</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 전체 메모리의 50~80% 할당 권장</span>\n<span class=\"token keyword\">SHOW</span> VARIABLES <span class=\"token operator\">LIKE</span> <span class=\"token string\">'innodb_buffer_pool_size'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>InnoDB 리두 로그 버퍼</strong></p>\n<p>트랜잭션 로그를 임시 보관 (장애 복구용)</p>\n<p><strong>InnoDB 어댑티브 해시 인덱스</strong></p>\n<p>자주 사용되는 데이터의 인덱스를 자동 생성</p>\n<p><strong>테이블 캐시</strong></p>\n<p>테이블 메타데이터(구조 정보) 캐싱</p>\n<h3>로컬 메모리 영역 (주의 필요!)</h3>\n<p><strong>특징</strong></p>\n<ul>\n<li>각 클라이언트 스레드마다 독립적으로 할당</li>\n<li>쿼리 실행에 필요한 경우에만 동적 할당</li>\n<li>쿼리 종료 시 해제</li>\n</ul>\n<p><strong>주의사항</strong></p>\n<p>로컬 메모리는 <strong>클라이언트 수에 비례</strong>하므로 신중하게 설정해야 합니다.</p>\n<h4>주요 메모리 영역</h4>\n<p><strong>정렬 버퍼</strong> (Sort Buffer)</p>\n<p><code class=\"language-text\">ORDER BY</code>, <code class=\"language-text\">GROUP BY</code> 시 사용</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 기본값: 256KB (적절함)</span>\n<span class=\"token keyword\">SHOW</span> VARIABLES <span class=\"token operator\">LIKE</span> <span class=\"token string\">'sort_buffer_size'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- 잘못된 설정 (위험!)</span>\n<span class=\"token keyword\">SET</span> <span class=\"token keyword\">GLOBAL</span> sort_buffer_size <span class=\"token operator\">=</span> <span class=\"token number\">10485760</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">-- 10MB</span>\n<span class=\"token comment\">-- 클라이언트 1000개 시 = 10GB 메모리 사용!</span></code></pre></div>\n<p><strong>조인 버퍼</strong> (Join Buffer)</p>\n<p>테이블 조인 시 사용</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SHOW</span> VARIABLES <span class=\"token operator\">LIKE</span> <span class=\"token string\">'join_buffer_size'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>바이너리 로그 캐시</strong></p>\n<p>트랜잭션의 변경 내역을 메모리에 임시 저장하는 공간</p>\n<p><strong>왜 로컬 메모리인가?</strong></p>\n<p>각 트랜잭션마다 독립적으로 할당해야 하기 때문입니다.</p>\n<p>트랜잭션 격리:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 세션 1</span>\n<span class=\"token keyword\">BEGIN</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">UPDATE</span> users <span class=\"token keyword\">SET</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'John'</span> <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 커밋 전 → 바이너리 로그 캐시에만 있음</span>\n\n<span class=\"token comment\">-- 세션 2</span>\n<span class=\"token keyword\">BEGIN</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">UPDATE</span> users <span class=\"token keyword\">SET</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Jane'</span> <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 각 세션은 독립적인 캐시 사용</span>\n\n<span class=\"token keyword\">COMMIT</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">-- 이때 캐시 → 디스크 바이너리 로그 파일로 기록</span></code></pre></div>\n<p><strong>리두 로그 vs 바이너리 로그 차이</strong></p>\n<p>둘 다 변경사항을 기록하지만 용도가 다릅니다.</p>\n<p><strong>리두 로그</strong> (Redo Log)</p>\n<ul>\n<li>목적: 장애 복구 (Crash Recovery)</li>\n<li>대상: InnoDB 전용</li>\n<li>내용: 물리적 변경 (어떤 페이지의 어떤 위치를)</li>\n<li>형식: 바이너리 형식 (사람이 못 읽음)</li>\n<li>위치: 글로벌 메모리 (InnoDB 리두 로그 버퍼)</li>\n<li>예시: <code class=\"language-text\">페이지 100, 오프셋 50에 값 0x1234 기록</code></li>\n</ul>\n<p><strong>바이너리 로그</strong> (Binary Log)</p>\n<ul>\n<li>목적: 복제(Replication), 백업/복구</li>\n<li>대상: MySQL 전체 (모든 스토리지 엔진)</li>\n<li>내용: 논리적 변경 (어떤 SQL을 실행했는지)</li>\n<li>형식: SQL 문장 또는 Row 변경 내역</li>\n<li>위치: 로컬 메모리 (각 트랜잭션마다)</li>\n<li>예시: <code class=\"language-text\">UPDATE users SET name = 'John' WHERE id = 1</code></li>\n</ul>\n<p><strong>왜 둘 다 필요한가?</strong></p>\n<ul>\n<li>리두 로그: MySQL 재시작 시 빠른 복구</li>\n<li>바이너리 로그: Slave 서버 동기화, 특정 시점 복구</li>\n</ul>\n<p><strong>왜 리두 로그로 복제가 안 되나?</strong></p>\n<p>리두 로그는 물리적 구조에 의존하기 때문에 복제에 사용할 수 없습니다.</p>\n<p>물리적 vs 논리적 차이:</p>\n<p>리두 로그 (물리적):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">페이지 100, 오프셋 50에 0x1234 기록\n페이지 200, 오프셋 30에 0x5678 기록</code></pre></div>\n<p>→ Master의 페이지 100 ≠ Slave의 페이지 100 (구조가 다를 수 있음)</p>\n<p>바이너리 로그 (논리적):</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">UPDATE</span> users <span class=\"token keyword\">SET</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'John'</span> <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>→ 어떤 서버에서든 실행 가능 (구조 독립적)</p>\n<p>실제 복제 시나리오:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- Master에서 실행</span>\n<span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">FROM</span> users <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">UPDATE</span> users <span class=\"token keyword\">SET</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'John'</span> <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- 리두 로그 방식 (불가능)</span>\n페이지 <span class=\"token number\">100</span>에서 행 삭제  ← Slave는 페이지 번호가 다를 수 있음\n페이지 <span class=\"token number\">50</span>에서 값 변경   ← 적용 불가능\n\n<span class=\"token comment\">-- 바이너리 로그 방식 (가능)</span>\n<span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">FROM</span> users <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>  ← Slave에서 <span class=\"token keyword\">SQL</span> 실행\n<span class=\"token keyword\">UPDATE</span> users <span class=\"token keyword\">SET</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'John'</span> <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>  ← Slave의 구조에 맞게 자동 적용</code></pre></div>\n<p>스토리지 엔진 독립성:</p>\n<ul>\n<li>Master: InnoDB, Slave: MyISAM 조합 가능</li>\n<li>리두 로그: InnoDB 전용 → MyISAM Slave에 적용 불가</li>\n<li>바이너리 로그: SQL이므로 모든 엔진에서 실행 가능</li>\n</ul>\n<p><strong>핵심 정리</strong></p>\n<ul>\n<li>리두 로그: 같은 서버 내에서 빠른 복구 (물리적, InnoDB 전용)</li>\n<li>바이너리 로그: 다른 서버로 복제 (논리적, 모든 엔진 지원)</li>\n</ul>\n<p>설정:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SHOW</span> VARIABLES <span class=\"token operator\">LIKE</span> <span class=\"token string\">'binlog_cache_size'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 기본값: 32KB (트랜잭션당)</span>\n<span class=\"token comment\">-- 클라이언트 1000개 × 32KB = 32MB</span></code></pre></div>\n<p><strong>네트워크 버퍼</strong></p>\n<p>클라이언트와의 통신용 버퍼</p>\n<h4>메모리 설정 가이드라인</h4>\n<p><strong>글로벌 메모리</strong></p>\n<ul>\n<li>크게 설정해도 안전 (고정 크기)</li>\n<li>성능 향상에 직접적인 효과</li>\n<li>전체 메모리의 50~80%를 버퍼 풀에 할당</li>\n</ul>\n<p><strong>로컬 메모리</strong></p>\n<ul>\n<li>보수적으로 설정 (작게 시작)</li>\n<li>기본값(256KB~1MB)이 대부분 적절</li>\n<li>특별한 이유 없이 크게 설정하지 말 것</li>\n</ul>\n<p><strong>안전한 설정 예시</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 글로벌: 크게 설정 (16GB 서버 기준)</span>\n<span class=\"token keyword\">SET</span> <span class=\"token keyword\">GLOBAL</span> innodb_buffer_pool_size <span class=\"token operator\">=</span> <span class=\"token number\">10737418240</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">-- 10GB</span>\n\n<span class=\"token comment\">-- 로컬: 작게 유지</span>\n<span class=\"token keyword\">SET</span> <span class=\"token keyword\">GLOBAL</span> sort_buffer_size <span class=\"token operator\">=</span> <span class=\"token number\">262144</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\">-- 256KB (기본값)</span>\n<span class=\"token keyword\">SET</span> <span class=\"token keyword\">GLOBAL</span> join_buffer_size <span class=\"token operator\">=</span> <span class=\"token number\">262144</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\">-- 256KB (기본값)</span>\n\n<span class=\"token comment\">-- 최대 동시 접속자 1000명이라도</span>\n<span class=\"token comment\">-- 로컬 메모리: 1000 × 256KB = 256MB (안전)</span></code></pre></div>\n<p><strong>핵심 포인트</strong></p>\n<p>성능은 글로벌 메모리로 높이되, 안정성은 로컬 메모리 관리에 달려있습니다. 특히 트래픽이 많은 서비스라면 로컬 메모리 설정을 더욱 신중하게 해야 합니다.</p>\n<h2>플러그인 스토리지 엔진 모델</h2>\n<ul>\n<li>스토리지 엔진 뿐만 아니라 다양한 플러그인이 가능\n<ul>\n<li>검색어 파서</li>\n<li>Native Authentication</li>\n<li>Caching SHA-2 Authentication</li>\n</ul>\n</li>\n<li>스토리지 엔진은 쿼리의 실행 과정 중 <strong>데이터의 읽기/쓰기</strong> 작업만 담당\n<ol>\n<li>SQL 파서</li>\n<li>SQL 옵티마이저</li>\n<li>SQL 실행기</li>\n<li>데이터 읽기/쓰기</li>\n</ol>\n</li>\n<li>스토리지 엔진 확인\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">ENGINE</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>Support 칼럼\n<ul>\n<li>YES: 사용 가능</li>\n<li>DEFAULT: 필수 스토리지 엔진</li>\n<li>NO: 포함되지 않음</li>\n<li>DISABLED: 포함됐지만 파라미터에 의해 비활성화</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>플러그인 확인\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SHOW</span> PLUGINS<span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ul>\n<h2>컴포넌트</h2>\n<ul>\n<li>플러그인 아키텍처의 단점을 보완하기 위해 등장\n<ul>\n<li>오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신할 수 없음</li>\n<li>MySQL 서버의 변수나 함수를 직접 호출 → 캡슐화가 되지 않아 안전하지 않음</li>\n<li>상호 의존 관계를 설정할 수 없어 초기화가 어려움</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">INSTALL COMPONENT <span class=\"token string\">'file://component_validate_password'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> mysql<span class=\"token punctuation\">.</span>component<span class=\"token punctuation\">;</span></code></pre></div>\n<h2>쿼리 실행 구조</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f4c9b2549ad1fe08dfa34a20b272270e/0f246/%EC%BF%BC%EB%A6%AC%EC%8B%A4%ED%96%89%EA%B5%AC%EC%A1%B0.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 65.82278481012659%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAABtUlEQVR42nWTR47CQBBFff/TsIAFC1gDIieRc845Q43eHzWCkcdSqbvtqte/gj3zeS6Xi+33ezscDlrd3p3dutvtbLlc2nq9ttVqZY/Hw7zX62UYj1s3m42dTifZ9XrVBe58u910Zj0ej1atVq3dblu5XBbc+1TmgPP53LbbrVQMBgMZsOl0qv35fJbPZDKx8XgsZQA5e7PZzBaLhQJwJh2cMVLhXbfbVUrD4dD6/b78R6ORlHEmJpvN/gKR3Gg07Pl86gMp8gFIr9ezYrEo63Q61mq1BGWPFQoFq9fr8s9kMsrAA3C/379SphYoJx1SKZVKb0UAuYh9Pp8XENAbCAx1f4GkDJBA1LJHFTDglKLZbOqMfy6X+x9IjagZ3UYdKmkS6iqVii6p1WqWTqfVZeBvhbTfTyHFJiAYDFogELB4PC4IKp0I/OkwD3VWU/wUoo7AaDRqoVDIwuGwRSIRqSV95/8Z8waiECgjwgv21M81hQmg8K6GpOsgn0AuE5DbgDKsjA1ANzY4JZNJi8ViUkAtec8fgj/G/JI2NeRS3z+FlBlUasiKEQAcMGsqlfqyRCKhxv0AMpvLs+gKN1YAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"쿼리실행구조\"\n        title=\"\"\n        src=\"/static/f4c9b2549ad1fe08dfa34a20b272270e/f058b/%EC%BF%BC%EB%A6%AC%EC%8B%A4%ED%96%89%EA%B5%AC%EC%A1%B0.png\"\n        srcset=\"/static/f4c9b2549ad1fe08dfa34a20b272270e/c26ae/%EC%BF%BC%EB%A6%AC%EC%8B%A4%ED%96%89%EA%B5%AC%EC%A1%B0.png 158w,\n/static/f4c9b2549ad1fe08dfa34a20b272270e/6bdcf/%EC%BF%BC%EB%A6%AC%EC%8B%A4%ED%96%89%EA%B5%AC%EC%A1%B0.png 315w,\n/static/f4c9b2549ad1fe08dfa34a20b272270e/f058b/%EC%BF%BC%EB%A6%AC%EC%8B%A4%ED%96%89%EA%B5%AC%EC%A1%B0.png 630w,\n/static/f4c9b2549ad1fe08dfa34a20b272270e/40601/%EC%BF%BC%EB%A6%AC%EC%8B%A4%ED%96%89%EA%B5%AC%EC%A1%B0.png 945w,\n/static/f4c9b2549ad1fe08dfa34a20b272270e/0f246/%EC%BF%BC%EB%A6%AC%EC%8B%A4%ED%96%89%EA%B5%AC%EC%A1%B0.png 1118w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>쿼리 파서</h3>\n<ul>\n<li>사용자 요청으로 들어온 쿼리 문장은 토큰으로 분리\n<ul>\n<li>토큰: MySQL이 인식할 수 있는 최소 단위의 어휘나 기호</li>\n</ul>\n</li>\n<li>토큰을 트리 형태의 구조로 만드는 작업</li>\n<li>쿼리 문장의 기본 문법 오류를 발견</li>\n</ul>\n<h3>전처리기</h3>\n<ul>\n<li>파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인</li>\n<li>각 토큰을 테이블 이름이나 칼럼 이름, 또는 내장 함수와 같은 개체와 매핑</li>\n<li>객체의 존재 여부와 객체의 접근 권한 등을 확인</li>\n</ul>\n<h3>옵티마이저</h3>\n<ul>\n<li>요청으로 들어온 쿼리 문장을 가장 빠르게 처리하는 방법을 결정</li>\n</ul>\n<h3>실행 엔진</h3>\n<ul>\n<li>만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러의 요청의 입력으로 연결하는 역할</li>\n</ul>\n<h3>핸들러</h3>\n<ul>\n<li>MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 읽어오는 역할</li>\n<li>결국 스토리지 엔진을 의미\n<ul>\n<li>MyISAM 테이블을 조작하는 경우 핸들러가 MyISAM 스토리지 엔진</li>\n<li>InnoDB 테이블을 조작하는 경우 핸들러가 InnoDB 스토리지 엔진</li>\n</ul>\n</li>\n</ul>\n<h2>쿼리 캐시</h2>\n<ul>\n<li>SQL의 <strong>실행 결과를 메모리에 캐시</strong></li>\n<li>동일 SQL 쿼리가 실행되면 테이블을 읽지 않고 즉시 결과를 반환</li>\n<li>테이블의 데이터가 변경되면 캐시에 저장된 결과 중 이와 관련된 것들을 모두 삭제(Invalidate)해야 함\n<ul>\n<li>심각한 동시 처리 성능 저하 → <strong>MySQL8.0에서 제거</strong></li>\n</ul>\n</li>\n</ul>\n<h2>스레드 풀</h2>\n<ul>\n<li>사용자의 요청을 처리하는 스레드 개수를 줄여서 서버의 자원 소모를 줄이는 것이 목표</li>\n<li>스케줄링 과정에서 CPU 시간을 제대로 확보하지 못하면 더 느려질 수 있음</li>\n</ul>\n<h3>Percona Server</h3>\n<ul>\n<li>MySQL 서버 엔터프라이즈 에디션은 스레드 풀 기능을 제공</li>\n<li>MySQL 커뮤니티 에디션을 지원하지 않아서 <strong>Percona Server의 스레드 풀 플러그인</strong>을 사용</li>\n</ul>\n<h3>스레드 개수</h3>\n<ul>\n<li>Percona Server의 스레드 풀은 기본적으로 <strong>CPU 코어의 개수만큼</strong> 스레드 그룹을 생성\n<ul>\n<li><code class=\"language-text\">thread_pool_size</code> 시스템 변수로 조정 가능</li>\n<li>일반적으로 CPU 코어의 개수와 맞추는 것이 CPU 프로세서 친화도를 높이는 데 좋음</li>\n</ul>\n</li>\n</ul>\n<h3>스레드 추가</h3>\n<ul>\n<li>스레드 풀에 이미 처리중인 작업이 있는 경우에는 <code class=\"language-text\">thread_pool_oversubscribe</code>에 설정된 개수만큼 추가로 처리\n<ul>\n<li>기본값 3</li>\n</ul>\n</li>\n<li>모든 스레드가 작업중이라면\n<ul>\n<li>새로운 작업 스레드를 추가할지, 기존 스레드가 작업을 완료할 때까지 기다릴지 판단</li>\n<li>스레드 풀의 <strong>타이머 스레드</strong>가 주기적으로 스레드 그룹의 상태를 체크</li>\n<li><code class=\"language-text\">thread_pool_stall_limit</code> 시스템 변수만큼 스레드가 작업을 끝내지 못하면 새로 스레드를 추가</li>\n<li>모든 스레드가 작업중이라면 <code class=\"language-text\">thread_pool_stall_limit</code> 이후에 새 요청을 처리할 수 있음</li>\n</ul>\n</li>\n</ul>\n<p><strong>중요한 제한 조건</strong></p>\n<p>스레드는 무한정 추가될 수 없습니다:</p>\n<ul>\n<li><code class=\"language-text\">thread_pool_max_threads</code> 시스템 변수로 최대 스레드 개수 제한</li>\n<li>이 값을 초과하면 더 이상 스레드를 추가할 수 없음</li>\n<li>초과 시 기존 스레드가 작업을 완료할 때까지 대기</li>\n</ul>\n<h3>선순위 큐 &#x26; 후순위 큐</h3>\n<ul>\n<li>먼저 시작된 트랜잭션 내에 속한 SQL을 빨리 처리</li>\n<li>해당 트랜잭션이 가지고 있던 잠금을 빨리 해제 → 경합 감소 → 처리 성능 향상</li>\n</ul>\n<h2>트랜잭션 지원 메타데이터</h2>\n<h3>메타데이터</h3>\n<ul>\n<li>테이블의 구조 정보</li>\n<li>스토어드 프로그램</li>\n<li>기존에는 FRM 등 <strong>파일 기반</strong>으로 관리\n→ 트랜잭션을 지원하지 않아 테이블 생성 도중 비정상 종료시 일관성이 깨짐</li>\n</ul>\n<h3>InnoDB</h3>\n<ul>\n<li>테이블의 구조 정보나 스토어드 프로그램과 관련된 정보를 InnoDB에 저장하도록 개선</li>\n</ul>\n<h4>시스템 테이블</h4>\n<ul>\n<li>MySQL 서버가 작동하는 데 기본적으로 필요한 테이블들</li>\n<li>사용자의 인증과 권한 관리 등</li>\n<li>mysql DB에 저장됨\n<ul>\n<li>통째로 <code class=\"language-text\">mysql.ibd</code> 테이블스페이스에 저장</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>시스템 테이블에 접근\n보안을 위해 <code class=\"language-text\">information_schema</code>를 통해 조회</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> INFORMATION_SCHEMA<span class=\"token punctuation\">.</span><span class=\"token keyword\">TABLES</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>직접 접근 시 ‘테이블 없음’ 에러가 아닌 ‘접근 거절’</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> mysql<span class=\"token punctuation\">.</span><span class=\"token keyword\">tables</span> <span class=\"token keyword\">LIMIT</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></code></pre></div>\n</blockquote>\n<h3>SDI(Serialized Dictionary Information)</h3>\n<ul>\n<li>InnoDB 스토리지 엔진을 사용하는 테이블은 메타데이터를 InnoDB 테이블 기반의 딕셔너리에 저장</li>\n<li>MyISAM이나 CSV 등과 같은 스토리지 엔진의 메타데이터는 여전히 저장할 공간이 필요</li>\n<li><code class=\"language-text\">*.sdi</code> 파일이 기존의 <code class=\"language-text\">*.FRM</code>과 동일한 역할을 수행</li>\n<li>InnoDB 테이블들의 구조도 SDI 파일로 변환 가능\n<ul>\n<li><code class=\"language-text\">idb2sdi</code> 유틸리티 이용</li>\n</ul>\n</li>\n</ul>\n<h1>InnoDB 스토리지 엔진 아키텍처</h1>\n<ul>\n<li><strong>레코드 기반의 잠금</strong>을 제공</li>\n<li><strong>높은 동시성 처리</strong>가 가능</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f1205540704124e45963f5e440dc313c/33d1d/%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80%EC%97%94%EC%A7%84%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 87.34177215189874%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAACoUlEQVR42mWUSUsrURSE/b0uXejGEYMGhKxURHCRXdy4Ety4CBkdo0biFGfjPMUhamK0Hl/BzcvjXTjc7tunq+rUOd0dX19furu70/39vd7f3/X29uY9XLcHZx8fH75+fHzU09OT9+fnZ/3+/orV8fr66sOHhwedn58Lgs/PT3EegMM1OTc3Nzo7O9PBwYHK5bL29/dVLBadY0ASm82mGo2GLi8v/WK1WlW9XvcOAASoubi40PHxsa6vr3V0dORzFK+vr7tCA3K4u7vruLq60u3trVmxIZFIaHx8XPPz85qcnNTU1JQmJiY0OztrQPKpam1tzeoNCAPSSahUKgbc29tzwvT0tDo7OzUzM6NIJKLu7m719PRoYGBAW1tbfmd7e1urq6u2reUhICgC8PDwUJlMxmXADtnS0pKGhobU19fnGBkZMSBeQl4oFLxjkxVSP6AAYHY2m3USCugoyf39/Qbr7e01IIQA8HxjY8Ni6LQ9hA3pqAMwnU67c/F4XLFYTHNzcxoeHm4BRqNRbW5uusTv728D/tMUukaH6SBqUqmUCQDs6uqyh2NjY/ZucHBQo6OjriAAco1lBqzVaiIYF0BhQmmpVHLiwsKCTV9ZWVEymVQul9Pi4qJJGSNieXn5b5cB+vn5MRM+MNgQUDJl4RFN4tnLy4sbdHJyYlLGi2BsWl1uB0QhTQIUL5lNhj4owHT8CmpYnFEJBOB0oCB8Kcinc7Dt7OwY8PT01EpRwogxRnw9kEJOANhqCuXRFKY+fFKUS2kow7N8Pu/gjAngPAR2MGYIMyCSkcqOSlSEe1gZXhSxKJXmYA2LPKYET5lhl6y2BSCKw+K3hPLADgEeQgJh+GVBgOf/AdIYAFDElxPmEnbswEfMJ/CWHIJ7/kyU/Ae5G8PnO96ETAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"스토리지 엔진 아키텍처\"\n        title=\"\"\n        src=\"/static/f1205540704124e45963f5e440dc313c/f058b/%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80%EC%97%94%EC%A7%84%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98.png\"\n        srcset=\"/static/f1205540704124e45963f5e440dc313c/c26ae/%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80%EC%97%94%EC%A7%84%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98.png 158w,\n/static/f1205540704124e45963f5e440dc313c/6bdcf/%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80%EC%97%94%EC%A7%84%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98.png 315w,\n/static/f1205540704124e45963f5e440dc313c/f058b/%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80%EC%97%94%EC%A7%84%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98.png 630w,\n/static/f1205540704124e45963f5e440dc313c/40601/%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80%EC%97%94%EC%A7%84%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98.png 945w,\n/static/f1205540704124e45963f5e440dc313c/33d1d/%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80%EC%97%94%EC%A7%84%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98.png 1150w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>프라이머리 키에 의한 클러스터링</h2>\n<ul>\n<li>InnoDB의 모든 테이블은 <strong>프라이머리 키를 기준으로 클러스터링되어 저장</strong>\n→ <strong>프라이머리 키 값의 순서대로 디스크에 저장</strong>\n→ 모든 세컨더리 인덱스는 레코드의 주소 대신 <strong>프라이머리 키의 값을 논리적인 주소로 사용</strong></li>\n<li>MyISAM 스토리지 엔진에서는 클러스터링 키를 지원하지 않음\n<ul>\n<li>프라이머리 키는 유니크 제약을 가진 세컨더리 인덱스와 동일하게 동작</li>\n</ul>\n</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e52a5b4ef155db3b26f80a80ec08f7a9/064b2/cluster.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.32911392405063%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABy0lEQVR42n2Qa1faQBCG+f9/pqdVe/q51lqoihUihEsaQhKSAGZzJ/EkT4eg9lixH56d2XffmZ3djrFp+B+zdc39ImRkZ23+nm++bliEDZ2BU3NnH+eX0JtEnN+YnGshvVn2vndZM/ZraegeCl/TcGsjppIbI+VCL7icFlyb5RHvgf5zQ00aDmXKwRNDp0GzS3TTR1sk9BeVTBdzqaf0zR0D++D5l4EMMfHlySNZ7n1e0DwYOQW6naA5FVf7CUeK7iTh2sgYygDaqnnD0G2Yyj92PHuFay5wLUdY4v2eE6x8/ByCrMFP6xe8pG61V6R/83UuDZfSxDItTMNg5Qds0xK1q1ElRBVv4nOujmlCp4h18u0VsfuNneqzS+6FEdnmJ/HqB0XYp1BDimhAGvSIva5ot+RKE/8did9ttX1tknp0VLQiimzBFRzUHuUQJx5JviYtNhK3ErckWSBF/kErtoeYrVvSzCfOEzqBaxHYc3xrhmdND/nSIIxCokQRqgdUuJVLHtq9SlOiWLX79mzvi0NUVhDun1za36nmn8lGH8nGn6hmZ1TWV4rlBdX0tNVT7QOFfiK+M3K7S2V8IR8/6ZNTHmcn8h064SP8AQIZM9AH22LVAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"클러스터링 인덱스\"\n        title=\"\"\n        src=\"/static/e52a5b4ef155db3b26f80a80ec08f7a9/f058b/cluster.png\"\n        srcset=\"/static/e52a5b4ef155db3b26f80a80ec08f7a9/c26ae/cluster.png 158w,\n/static/e52a5b4ef155db3b26f80a80ec08f7a9/6bdcf/cluster.png 315w,\n/static/e52a5b4ef155db3b26f80a80ec08f7a9/f058b/cluster.png 630w,\n/static/e52a5b4ef155db3b26f80a80ec08f7a9/40601/cluster.png 945w,\n/static/e52a5b4ef155db3b26f80a80ec08f7a9/78612/cluster.png 1260w,\n/static/e52a5b4ef155db3b26f80a80ec08f7a9/064b2/cluster.png 1874w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>외래 키 지원</h2>\n<ul>\n<li>InnoDB 스토리지 엔진 레벨에서 지원\n<ul>\n<li>MyISAM이나 MEMORY에서는 사용 불가</li>\n</ul>\n</li>\n<li><strong>잠금이 여러 테이블로 전파되며 데드락이 발생</strong>할 수 있음\n<ul>\n<li>외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요</li>\n<li>변경 시 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요</li>\n</ul>\n</li>\n<li><code class=\"language-text\">foreign_key_checks</code> 시스템 변수를 <code class=\"language-text\">OFF</code>로 설정하여 일시적으로 외래 키 관계 체크 작업을 비활성화\n<ul>\n<li>비활성화된 동안 <code class=\"language-text\">ON DELETE CASCADE</code>와 <code class=\"language-text\">ON UPDATE CASCADE</code> 옵션도 무시</li>\n<li>대량 레코드 적재 및 삭제 작업을 빠르게 진행할 수 있음</li>\n<li>일관성을 맞춰준 후 다시 활성화해줘야 함</li>\n</ul>\n</li>\n</ul>\n<h2>MVCC(Multi Version Concurrency Control)</h2>\n<ul>\n<li>일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능</li>\n<li><strong>잠금을 사용하지 않는 일관된 읽기를 제공</strong>하는 것이 가장 큰 목적</li>\n<li>InnoDB는 <strong>언두 로그</strong> (Undo log)를 이용해 구현</li>\n<li>멀티 버전: <strong>하나에 레코드에 대해 여러 개의 버전</strong>이 동시에 관리됨을 의미</li>\n</ul>\n<h3>격리 수준(Isolation level)</h3>\n<ul>\n<li><code class=\"language-text\">INSERT</code> 이후 InnoDB 버퍼 풀과 데이터 파일에 새로운 값이 추가됨</li>\n<li><code class=\"language-text\">UPDATE</code>를 하면\n<ul>\n<li>커밋 실행 여부와 관계없이 InnoDB의 <strong>버퍼 풀을 새로운 값으로</strong> 업데이트됨</li>\n<li><strong>변경 전 값을 언두로그</strong>에 기록</li>\n<li>데이터 파일은 백그라운드 스레드에 의해 기록되기 때문에 시점에 따라 업데이트 여부가 다름</li>\n</ul>\n</li>\n<li>아직 <code class=\"language-text\">COMMIT</code>이나 <code class=\"language-text\">ROLLBACK</code>되지 않은 상태에서 다른 사용자가 해당 레코드를 조회하면\n<ul>\n<li><code class=\"language-text\">transaction_isolation</code>에 설정된 <strong>격리 수준</strong>에 따라 결과가 다름</li>\n<li><strong><code class=\"language-text\">READ_UNCOMMITTED</code></strong>\n<ul>\n<li><strong>버퍼 풀이 가지고 있는 데이터를 반환</strong></li>\n</ul>\n</li>\n<li><strong><code class=\"language-text\">READ_COMMITTED</code></strong>, <code class=\"language-text\">REPEATABLE_READ</code>, <code class=\"language-text\">SERIALIZABLE</code>\n<ul>\n<li>버퍼 풀이나 데이터 파일에 있는 내용 대신 변경되기 이전의 내용인 <strong>언두 영역의 데이터를 반환</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3>트랜잭션 종료</h3>\n<ul>\n<li><code class=\"language-text\">COMMIT</code>\n<ul>\n<li>더 이상의 변경 작업 없이 지금의 상태를 영구적인 데이터로 만들어버림</li>\n<li>언두 영역의 백업 데이터를 바로 삭제하지 않고, 이를 필요로하는 트랜잭션이 더 없을 때 삭제</li>\n</ul>\n</li>\n<li><code class=\"language-text\">ROLLBACK</code>\n<ul>\n<li>언두 영역에 있는 백업된 데이터를 버퍼 풀로 다시 복구하고, 언두 영역의 내용을 삭제</li>\n</ul>\n</li>\n</ul>\n<h2>잠금 없는 일관된 읽기</h2>\n<ul>\n<li>MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행\n<ul>\n<li><code class=\"language-text\">SERIALIZABLE</code> 제외</li>\n</ul>\n</li>\n<li>특정 사용자가 레코드를 변경하고 아직 커밋하지 않았다 하더라도 언두 로그의 데이터를 읽음</li>\n</ul>\n<blockquote>\n<p>오랜 시간 동안 트래잭션이 활성 상태이면\n언두 로그를 삭제하지 못하고 계속 유지해야 함\nMySQL 서버가 느려지거나 문제가 발생할 수 있음</p>\n</blockquote>\n<h2>자동 데드락 감지</h2>\n<ul>\n<li>잠금 대기 목록을 <strong>그래프</strong> (Wait-for List) 형태로 관리</li>\n<li>데드락 감지 스레드가 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션들 중 하나를 강제 종료\n<ul>\n<li><strong>언두 로그를 더 적게 가진 트랜잭션</strong>이 일반적으로 롤백의 대상이 됨\n→ 롤백을 해도 언두 처리를 해야 할 내용이 적기 때문</li>\n</ul>\n</li>\n<li>MySQL 엔진에서 관리되는 테이블 잠금(<code class=\"language-text\">LOCK TABLES</code> 명령)은 볼 수 없어서 데드락 감지가 불확실\n<ul>\n<li><strong><code class=\"language-text\">innodb_table_locks</code></strong> 시스템 변수를 활성화하면 테이블 레벨의 잠금까지 감지 가능</li>\n</ul>\n</li>\n</ul>\n<h3>데드락 감지 부하</h3>\n<ul>\n<li>데드락 스레드가 잠금 목록을 검사하기 위해 <strong>잠금 목록이 저장된 리스트(잠금 테이블)에 새로운 잠금</strong>을 걸음</li>\n<li>동시 처리 스레드가 많아지거나, 각 트랜잭션의 잠금 개수가 증가하면 데드락 감지 스레드가 느려짐</li>\n<li><code class=\"language-text\">innodb_deadlock_detect</code> 시스템 변수를 <code class=\"language-text\">OFF</code>로 설정하면 감지 안함\n→ <strong>데드락 발생 시 무한정 대기</strong></li>\n<li><code class=\"language-text\">innodb_lock_wait_timeout</code> 시스템 변수를 활성화\n→ <strong>데드락 상황에서 자동으로 요청이 실패</strong>하고 에러 메시지를 반환</li>\n</ul>\n<h2>자동화된 장애 복구</h2>\n<ul>\n<li>InnoDB 데이터 파일은 기본적으로 MySQL 서버가 시작될 때 자동으로 복구를 수행\n<ul>\n<li>복구될 수 없는 손상이 있다면 종료</li>\n</ul>\n</li>\n<li><code class=\"language-text\">innodb_force_recovery</code> 시스템 변수로 <strong>파일의 손상 여부를 선별적으로 진행</strong>\n<ul>\n<li>1부터 6까지, 높을수록 심각한 상황</li>\n</ul>\n</li>\n<li><code class=\"language-text\">mysqldump</code>를 이용해 데이터를 가능한 만큼 백업한 뒤 새로 DB와 테이블을 생성하는 것이 좋음</li>\n</ul>\n<h3><code class=\"language-text\">innodb_force_recovery</code> 옵션</h3>\n<ul>\n<li>1(<code class=\"language-text\">SRV_FORCE_IGNORE_CORRUPT</code>)\n<ul>\n<li>데이터나 인덱스 페이지에서 손상된 부분이 발견돼도 무시하고 시작하는 모드</li>\n</ul>\n</li>\n<li>2(<code class=\"language-text\">SRV_FORCE_NO_BACKGROUND</code>)\n<ul>\n<li>불필요한 언두 데이터는 메인 스레드가 주기적으로 삭제(Undo purge)</li>\n<li>메인 스레드를 시작하지 않고 서버를 시작하여 언두 데이터로 인한 장애를 무시하는 모드</li>\n</ul>\n</li>\n<li>3(<code class=\"language-text\">SRV_FORCE_NO_TRX_UNDO</code>)\n<ul>\n<li>일반적으로 서버가 다시 시작하면서 언두 영역의 데이터를 데이터 파일의 적용하고, 리두 파일의 내용을 덮어써서 장애 시점의 데이터 상태를 만들어 냄</li>\n<li>커밋되지 않은 트랜잭션의 작업을 롤백하지 않고 그대로 두는 모드</li>\n</ul>\n</li>\n<li>4(<code class=\"language-text\">SRV_FORCE_NO_IBUF_MERGE</code>)\n<ul>\n<li>데이터 변경으로 인한 인덱스 변경 작업은 인서트 버퍼에 저장해두고 나중에 처리될 수 있음</li>\n<li>인서트 버퍼의 내용을 무시하고 시작하는 모드</li>\n</ul>\n</li>\n<li>5(<code class=\"language-text\">SRV_FORCE_NO_UNDO_LOG_SCAN</code>)\n<ul>\n<li>언두 로그를 모두 무시하고 시작하는 모드</li>\n<li>커밋되지 않은 트랜잭션을 모두 커밋된 것처럼 처리</li>\n</ul>\n</li>\n<li>6(<code class=\"language-text\">SRV_FORCE_NO_LOG_REDO</code>)\n<ul>\n<li>리두 로그를 무시한 채로 시작</li>\n<li>커밋이 되어도 리두 로그에만 기록되였다면 무시됨 → 마지막 체크포인트 시점의 데이터만 남음</li>\n</ul>\n</li>\n</ul>\n<h2>InnoDB 버퍼 풀</h2>\n<ul>\n<li>디스크의 데이터 파일이나 인덱스 정보를 <strong>메모리에 캐시</strong>해두는 공간</li>\n<li>쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 <strong>버퍼 역할</strong>\n→ 랜덤한 디스크 작업의 횟수를 줄임</li>\n</ul>\n<h3>버퍼 풀의 크기 설정</h3>\n<ul>\n<li><strong>레코드 버퍼</strong>: 각 클라이언트 세션에서 테이블의 레코드를 읽고 쓸 때 버퍼로 사용하는 공간\n<ul>\n<li>별도로 설정할 수 없고, 전체 커넥션 개수와 각 커넥션이 다루는 테이블 개수에 따라 결정됨</li>\n<li>동적으로 해제되기도 해서 정확한 필요 메모리 계산이 불가능</li>\n</ul>\n</li>\n<li>버퍼 풀의 크기를 적절히 <strong>작은 값으로 설정한 뒤 조금씩 증가</strong>시키는 방법이 최적</li>\n<li><code class=\"language-text\">innodb_buffer_pool_size</code> 시스템 변수로 크기를 설정\n<ul>\n<li>동적으로 버퍼 풀의 크기를 확장할 수 있음</li>\n<li><strong>크기를 줄이는 작업</strong>은 크리티컬하므로 주의</li>\n<li>버퍼 풀 크기의 단위는 128MB</li>\n</ul>\n</li>\n</ul>\n<h4>버퍼 풀 인스턴스</h4>\n<p><strong>문제: 단일 버퍼 풀의 경합</strong></p>\n<p>버퍼 풀은 여러 클라이언트 스레드가 동시에 접근하는 공유 자원입니다.</p>\n<p>단일 버퍼 풀 사용 시:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">클라이언트 1000개가 동시에 버퍼 풀 접근\n→ 하나의 버퍼 풀을 잠금(세마포어)으로 보호\n→ 한 번에 하나의 스레드만 접근 가능\n→ 나머지 999개는 대기 (심각한 경합)</code></pre></div>\n<p><strong>해결: 버퍼 풀을 여러 개로 분할</strong></p>\n<p>비유: 은행 창구 1개 vs 창구 8개</p>\n<p>창구 1개:</p>\n<ul>\n<li>1000명이 한 줄로 대기</li>\n<li>대기 시간 매우 길음</li>\n</ul>\n<p>창구 8개:</p>\n<ul>\n<li>1000명을 8개 줄로 분산 (각 줄당 125명)</li>\n<li>대기 시간 대폭 감소</li>\n</ul>\n<p>버퍼 풀도 마찬가지:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 버퍼 풀 8GB를 8개 인스턴스로 분할</span>\n<span class=\"token keyword\">SET</span> <span class=\"token keyword\">GLOBAL</span> innodb_buffer_pool_size <span class=\"token operator\">=</span> <span class=\"token number\">8589934592</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">-- 8GB</span>\n<span class=\"token keyword\">SET</span> <span class=\"token keyword\">GLOBAL</span> innodb_buffer_pool_instances <span class=\"token operator\">=</span> <span class=\"token number\">8</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">-- 8개로 분할</span>\n\n<span class=\"token comment\">-- 각 인스턴스: 1GB씩 담당</span>\n<span class=\"token comment\">-- 경합: 1/8로 감소</span></code></pre></div>\n<p><strong>동작 방식</strong></p>\n<p>버퍼 풀 인스턴스 8개로 분할:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">인스턴스 1: 페이지 1, 9, 17, 25...\n인스턴스 2: 페이지 2, 10, 18, 26...\n인스턴스 3: 페이지 3, 11, 19, 27...\n...\n인스턴스 8: 페이지 8, 16, 24, 32...</code></pre></div>\n<p>스레드 A가 페이지 1 요청 → 인스턴스 1만 잠금\n스레드 B가 페이지 2 요청 → 인스턴스 2만 잠금 (동시 처리 가능!)</p>\n<h3>버퍼 풀의 구조</h3>\n<ul>\n<li>버퍼 풀을 페이지 크기의 조각으로 쪼개어 InnoDB 스토리지 엔진이 데이터를 필요로 할 때, 해당 데이터 페이지를 읽어와 각 조각에 저장</li>\n<li><strong>LRU</strong> (Least Recently Used) 리스트, <strong>플러시</strong> (Flush) 리스트, <strong>프리</strong> (Free) 리스트</li>\n</ul>\n<h4>프리(Free) 리스트</h4>\n<p><strong>프리 리스트는 InnoDB 버퍼 풀이 처음 시작될 때 존재하는 빈 페이지들의 목록</strong>입니다.</p>\n<p><strong>버퍼 풀 초기화 시</strong></p>\n<p>MySQL이 시작되면 버퍼 풀(예: 10GB)이 할당되지만, 처음에는 모든 페이지가 비어있습니다. 이 빈 페이지들이 프리 리스트에 들어갑니다.</p>\n<p><strong>데이터 적재 과정</strong></p>\n<ol>\n<li>쿼리가 실행되면 디스크에서 데이터를 읽어와야 함</li>\n<li>프리 리스트에서 빈 페이지를 하나 가져옴</li>\n<li>디스크에서 읽은 데이터로 해당 페이지를 채움</li>\n<li>채워진 페이지는 LRU 리스트로 이동</li>\n</ol>\n<p><strong>프리 리스트가 고갈되면?</strong></p>\n<p>프리 리스트가 비면 LRU 리스트의 꼬리(Tail)에서 가장 오래 사용되지 않은 페이지를 제거하여 공간을 확보합니다:</p>\n<ul>\n<li>깨끗한 페이지: 바로 제거하고 재사용</li>\n<li>더티 페이지: 디스크에 먼저 기록한 후 재사용</li>\n</ul>\n<p>따라서 프리 리스트는 \"아직 한 번도 사용되지 않은 빈 공간\"이고, LRU 리스트는 \"실제 데이터가 들어있는 공간\"입니다.</p>\n<h4>LRU(Least Recentrly Used)</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/74fa368ef7163bf451f741ffb95235e7/764be/LRU.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 84.81012658227847%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAACbUlEQVR42oWU6UsqYRTG+5dFpA+KWKiJSy4ofvaDpPQ5IhAX1NxSc99FS02JXEFz68RzLjPIbbp34PDOvO+c33nOMnNGEtfxeKTxeEzD4ZBGoxHfv729ic/Cir3dbkeHw4E+Pz/Z90wKuN1u6enpiR4eHigYDFK5XGZLp9MUj8cplUrR8/MzPw8GA1osFtTtdhksCUTUXC5H+XyerV6vU7PZ5L37+3t6fHykSqVChUKB9wCE4v1+Lw2EfChC1E6nQ+12m2q1GitLJBKsDDCoRDAAW63W7wqRcrFY5JcajQavcAQkFouxKkFhNpul2WzGqf8XCGWAwaAQzplMhpWVSiVeAV0ul9woMeWvry/RBCAcToFQCEA4HOaGQSHqW61WabVascJfa3gKRDOEGgIkNAsZIABqjRpihMSU0QREWa/XtNlseIUDYKghDEqSySTd3d1RNBrlVAGGUvgCKCrs9XocGR0ECIdI8+Xlhfr9Pq/oOKDoNCA4hzpkghqCwUB8FVAFm8/nvDmZTMjv95PP52O7vb3lZ6/XS263mzweD93c3PAZgPB7fX39k7LQCKE5uJCyyWQimUxG5+fnpNPpSK/Xk1qtJrlcTkqlki4uLshsNnPqHx8fnMWPsRGAUOt0OsloNLKTxWKh6+trMhgMDEMAnDkcDm4M5hAKf3T5FOhyuRhktVrZoFir1TLs6uqKV5vNJjYFtf4nELWCKjjZ7XaG/q0QWSBl1PD9/Z3/UpJA1BAOGo2GLi8v2XAPmEKhIJVKxfdQjJFClwHG/EoONoqLEQqFQhSJRPjrwBoIBETDbw3ziOC4ptMp/6W+AcjYquhwO0S1AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"lru 구조\"\n        title=\"\"\n        src=\"/static/74fa368ef7163bf451f741ffb95235e7/f058b/LRU.png\"\n        srcset=\"/static/74fa368ef7163bf451f741ffb95235e7/c26ae/LRU.png 158w,\n/static/74fa368ef7163bf451f741ffb95235e7/6bdcf/LRU.png 315w,\n/static/74fa368ef7163bf451f741ffb95235e7/f058b/LRU.png 630w,\n/static/74fa368ef7163bf451f741ffb95235e7/764be/LRU.png 806w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>엄밀하게는 LRU와 MRU(Most Recently Used) 리스트가 결합된 형태</li>\n</ul>\n<ol>\n<li>필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사\n<ul>\n<li>InnoDB 어댑티브 해시 인덱스로 페이지 검색</li>\n<li>해당 테이블의 인덱스(B-Tree)를 이용해 버퍼 풀에서 페이지를 검색</li>\n<li>버퍼 풀에 이미 데이터가 있었다면 해당 페이지의 포인터를 <strong>MRU 방향으로 승급</strong></li>\n</ul>\n</li>\n<li>디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재</li>\n<li>적재된 페이지에 대한 포인터를 <strong>LRU 헤더 부분에 추가</strong></li>\n<li>적재된 페이지가 실제로 읽히면 <strong>MRU 헤더 부분으로 이동</strong>\n<ul>\n<li>대량 읽기의 경우 버퍼 풀에 적재되고 실제 쿼리에서 사용되지 않을 수 있기 때문</li>\n</ul>\n</li>\n<li>버퍼 풀에서 오랫동안 사용되지 않으면 Aging되어 버퍼 풀에서 제거되고, 사용되면 나이가 초기화되고 <strong>MRU의 헤더 부분으로 이동</strong></li>\n<li>자주 접근됐다면 해당 페이지의 인덱스 키를 <strong>어댑티브 해시 인덱스에 추가</strong></li>\n</ol>\n<h4>플러시 리스트</h4>\n<p><strong>더티 페이지</strong> (Dirty Page)란 버퍼 풀에서 변경되었지만 아직 디스크에 기록되지 않은 데이터 페이지를 의미합니다.</p>\n<p>플러시 리스트는 이러한 더티 페이지들을 변경 시점 순서대로 관리하는 자료구조입니다.</p>\n<p><strong>UPDATE 쿼리 실행 시 데이터 흐름</strong></p>\n<ol>\n<li>사용자가 <code class=\"language-text\">UPDATE users SET age = 30 WHERE id = 1</code> 실행</li>\n<li>InnoDB는 다음 두 곳에 변경사항을 기록:\n<ul>\n<li><strong>리두 로그 버퍼</strong>에 변경 내역 기록 (WAL 원칙)</li>\n<li><strong>버퍼 풀의 데이터 페이지</strong>를 직접 수정 (이때 해당 페이지는 더티 페이지가 됨)</li>\n</ul>\n</li>\n<li>더티 페이지는 <strong>플러시 리스트에 추가</strong>되어 관리</li>\n<li><strong>COMMIT 시점</strong>에 리두 로그 버퍼 내용이 디스크의 리두 로그 파일에 기록 (fsync)</li>\n<li>하지만 <strong>데이터 페이지 자체는 아직 디스크에 기록되지 않음</strong></li>\n</ol>\n<p>리두 로그가 디스크에 기록되었다고 해서 실제 데이터 페이지가 디스크에 기록된 것은 아닙니다.</p>\n<p>데이터 페이지는 플러시 리스트에서 관리되다가 다음 시점에 디스크로 기록됩니다:</p>\n<ul>\n<li><strong>체크포인트 이벤트</strong> 발생 시</li>\n<li><strong>버퍼 풀 공간 부족</strong> 시 (LRU 알고리즘에 의해 오래된 더티 페이지 방출)</li>\n<li><strong>백그라운드 페이지 클리너 스레드</strong>가 주기적으로 처리</li>\n</ul>\n<p>이러한 구조 덕분에 MySQL은 커밋 성능을 유지하면서도 크래시 복구가 가능합니다.</p>\n<p>크래시 발생 시 리두 로그를 재생하여 디스크에 기록되지 않은 더티 페이지를 복구할 수 있기 때문입니다.</p>\n<h3>버퍼 풀과 리두 로그</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9a0f92b050926d19c0c18bafed7b45ac/31198/%EB%B2%84%ED%8D%BC%ED%92%80_%EB%A6%AC%EB%91%90%EB%A1%9C%EA%B7%B8.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 72.15189873417721%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAACJklEQVR42n2UyU5qURBF/SR+gz9haJw6Y8KIkWHkFyiE0IUmIn0PSqs0CoSeAMpYIdbLqpd7H8Tkkezcc8+p2qdq77pc/Pz8yHq9luVyKavV6gyLxULm8/kZiDNwGvfx8SH8Lr6+vuTp6UleXl6k0+koWq2WtNttyeVyEgqFJBwO6zMYDEqhUJButyuvr68aS97z87Pum4QcjEYjBUTFYlFJ8/m83N/fa4JxEQTJZFIikYj0ej0Zj8d6Qblc/kcIydvbmwyHQ6lWq5JOp2U6nUoikZCrqytNoMXJZKLyeL1eubm5kWazqYRc8ovw/f1dSamkXq9rEq2WSiWxWq1yfX2tOqFjrVZTQERX/yWkLarx+/0Sj8e1osvLS3E6nbLb7ZRgMBhotcT+Ivz+/jZbJpD1drs1EyH//PzUyjabjcxmM5UDZ2kZmejqrELDFA4RmptpGz1pjXeMYRqAMQUUYZiCkUp4PB5VJ4xgTADu8p7JZOTx8VFHAmASiaxPY9nnciU8HA4alEqlJBaLSTQa1ZHw+XwKzGEGA4GAuN1uBeeAWHIAlZstM6S0gUbohUEej0ccDoe4XC7V6u7uTmw2m1gsFun3+7Lf7/UrwXlyzZYhxCWAFgRD8PDwoENNhZVKRSu6vb0Vu90ujUZDDaMQ4tGbGJPQmCmEBpgEOZWiJXKgJfu4zPM0lnaz2exfQv4cIEPUUycBFxlOUwFrnqfn5DAyTAeEfwAQY8QSUbyojgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"버퍼풀과 리두 로그\"\n        title=\"\"\n        src=\"/static/9a0f92b050926d19c0c18bafed7b45ac/f058b/%EB%B2%84%ED%8D%BC%ED%92%80_%EB%A6%AC%EB%91%90%EB%A1%9C%EA%B7%B8.png\"\n        srcset=\"/static/9a0f92b050926d19c0c18bafed7b45ac/c26ae/%EB%B2%84%ED%8D%BC%ED%92%80_%EB%A6%AC%EB%91%90%EB%A1%9C%EA%B7%B8.png 158w,\n/static/9a0f92b050926d19c0c18bafed7b45ac/6bdcf/%EB%B2%84%ED%8D%BC%ED%92%80_%EB%A6%AC%EB%91%90%EB%A1%9C%EA%B7%B8.png 315w,\n/static/9a0f92b050926d19c0c18bafed7b45ac/f058b/%EB%B2%84%ED%8D%BC%ED%92%80_%EB%A6%AC%EB%91%90%EB%A1%9C%EA%B7%B8.png 630w,\n/static/9a0f92b050926d19c0c18bafed7b45ac/31198/%EB%B2%84%ED%8D%BC%ED%92%80_%EB%A6%AC%EB%91%90%EB%A1%9C%EA%B7%B8.png 694w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>버퍼 풀의 크기는 서버의 메모리가 허용하는 한 <strong>클수록 쿼리의 성능이 향상</strong>\n<ul>\n<li>캐시 기능만 향상시키는 것</li>\n</ul>\n</li>\n</ul>\n<h4>활성 리두 로그(Active Redo Log)</h4>\n<p>리두 로그는 고정된 크기의 파일들을 <strong>원형 큐처럼 순환</strong>하면서 사용합니다. 마치 카세트테이프처럼 끝까지 가면 다시 처음으로 돌아와서 기존 내용을 덮어쓰는 구조입니다.</p>\n<p><strong>예시: 리두 로그 파일이 3개 (각 1GB)인 경우</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[ib_logfile0: 1GB] → [ib_logfile1: 1GB] → [ib_logfile2: 1GB] → (다시 처음으로)</code></pre></div>\n<p><strong>동작 과정</strong></p>\n<ol>\n<li>처음에는 <code class=\"language-text\">ib_logfile0</code>부터 차례로 기록</li>\n<li><code class=\"language-text\">ib_logfile2</code>까지 가득 차면 다시 <code class=\"language-text\">ib_logfile0</code>의 처음부터 덮어쓰기 시작</li>\n<li><strong>문제</strong>: 아직 디스크에 기록되지 않은 더티 페이지의 로그를 덮어쓰면 크래시 복구 불가능</li>\n</ol>\n<p><strong>활성 리두 로그 = 재사용 불가능한 영역</strong></p>\n<p>리두 로그의 일부 영역은 아직 디스크에 반영되지 않은 더티 페이지와 연결되어 있어서 덮어쓸 수 없습니다. 이 영역을 <strong>활성 리두 로그</strong> (Active Redo Log)라고 합니다.</p>\n<h4>LSN(Log Sequence Number)</h4>\n<p>LSN은 리두 로그의 <strong>논리적 위치</strong>를 나타내는 단조 증가하는 숫자입니다.</p>\n<p><strong>물리적으로는 리두 로그 파일이 순환하지만, LSN은 절대 감소하지 않고 계속 증가합니다.</strong></p>\n<p><strong>주요 개념</strong></p>\n<ul>\n<li>리두 로그 파일은 물리적으로 <strong>순환</strong>하지만, LSN은 논리적으로 <strong>계속 증가</strong></li>\n<li>InnoDB는 주기적으로 <strong>체크포인트 이벤트</strong>를 발생시켜 더티 페이지를 디스크에 동기화</li>\n<li>체크포인트가 발생하면 체크포인트 LSN보다 작은 리두 로그 엔트리와 연결된 더티 페이지가 디스크로 기록됨</li>\n<li><strong>체크포인트 에이지</strong> (Checkpoint Age) = 현재 LSN - 마지막 체크포인트 LSN\n<ul>\n<li>이 값이 활성 리두 로그의 크기를 나타냄</li>\n<li>이 값이 전체 리두 로그 크기에 가까워지면 <strong>쓰기 작업이 지연</strong>될 수 있음</li>\n</ul>\n</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/abea2e538dd97be2f92769a095ae142e/ac25d/%EB%B2%84%ED%8D%BC%ED%92%80_%EB%A6%AC%EB%91%90_%EA%B7%B8%EB%9E%98%ED%94%84.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 59.49367088607595%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAABzklEQVR42o2Su24TURCG9zl4Dx4DuaGJFOUNeAUkTAEVEkKiIbRAFQIUoaDgIiUoQlRQgIghgC8kttf27vrcz8ecs1EaHORidkZnZr6dfzSFsY5Vpo0FB4f1gEc7Lzm58wT97SsGMNpyUV+x6lElWIDd/icuvb7N/Vc7NLfuMe1coXn77gxq1gNqa3HOU2nF5Td3eXz8McMTpNnbY7a52cKkxhi7BlCKvDRP+kNeXL+JUgrV+476PcCUJfOtLdRRr51yHWAqsjGyGC/4fPUa1eEHZAHZlvsHzDY20HWD8WFNYLIkSQDzp7uUnQ719kOqB9s5bp49//8OtWllrpw0T7XP4kaXRbfL8uD9hVLPgVaW60PAugT+d59JfoYkS/FFsLP3oqprhqORPGiiNMWYv2SXouAk9kTvW5+zOXEe5x6xECKFkqkWjZXbC/QGlnoZkV7KoaMugxTJfYv28pecSSUQJ/laoX/2CY2WpKg7naB/HMs/AsVSQDMFo4nmy9GY4Z8lMjTVHOqpoxlMUP0pdX9OdaIwM7nTmcZOanzZEOcNdlyihyOi0hRedheD7NFbmca1PrbyQnQEp/HJgpFhJJ9qRW4Sn32MrYl05z1/AcKKkinlBsGTAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"LSN 체크\"\n        title=\"\"\n        src=\"/static/abea2e538dd97be2f92769a095ae142e/f058b/%EB%B2%84%ED%8D%BC%ED%92%80_%EB%A6%AC%EB%91%90_%EA%B7%B8%EB%9E%98%ED%94%84.png\"\n        srcset=\"/static/abea2e538dd97be2f92769a095ae142e/c26ae/%EB%B2%84%ED%8D%BC%ED%92%80_%EB%A6%AC%EB%91%90_%EA%B7%B8%EB%9E%98%ED%94%84.png 158w,\n/static/abea2e538dd97be2f92769a095ae142e/6bdcf/%EB%B2%84%ED%8D%BC%ED%92%80_%EB%A6%AC%EB%91%90_%EA%B7%B8%EB%9E%98%ED%94%84.png 315w,\n/static/abea2e538dd97be2f92769a095ae142e/f058b/%EB%B2%84%ED%8D%BC%ED%92%80_%EB%A6%AC%EB%91%90_%EA%B7%B8%EB%9E%98%ED%94%84.png 630w,\n/static/abea2e538dd97be2f92769a095ae142e/40601/%EB%B2%84%ED%8D%BC%ED%92%80_%EB%A6%AC%EB%91%90_%EA%B7%B8%EB%9E%98%ED%94%84.png 945w,\n/static/abea2e538dd97be2f92769a095ae142e/78612/%EB%B2%84%ED%8D%BC%ED%92%80_%EB%A6%AC%EB%91%90_%EA%B7%B8%EB%9E%98%ED%94%84.png 1260w,\n/static/abea2e538dd97be2f92769a095ae142e/ac25d/%EB%B2%84%ED%8D%BC%ED%92%80_%EB%A6%AC%EB%91%90_%EA%B7%B8%EB%9E%98%ED%94%84.png 2342w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>버퍼 풀 vs 리두 로그: 왜 리두 로그가 훨씬 작아도 되는가?</strong></p>\n<p>예시로 이해해봅시다:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">UPDATE</span> users <span class=\"token keyword\">SET</span> age <span class=\"token operator\">=</span> <span class=\"token number\">31</span> <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>버퍼 풀에 저장되는 것</strong></p>\n<ul>\n<li>전체 데이터 페이지 (16KB)</li>\n<li>해당 페이지에는 여러 행의 데이터가 포함됨</li>\n<li>예: <code class=\"language-text\">id=1</code>부터 <code class=\"language-text\">id=100</code>까지의 사용자 정보 모두</li>\n</ul>\n<p><strong>리두 로그에 저장되는 것</strong></p>\n<ul>\n<li>변경된 부분만 (수십 바이트)</li>\n<li>예: \"users 테이블, id=1, age 컬럼을 30에서 31로 변경\"</li>\n</ul>\n<p>따라서 버퍼 풀이 10GB라도 리두 로그는 1~2GB 정도면 충분합니다. 리두 로그는 <strong>변경 이력</strong>만 기록하기 때문입니다.</p>\n<h3>버퍼 풀 플러시(Buffer Pool Flush)</h3>\n<ul>\n<li>더티 페이지를 성능상의 악영향 없이 디스크에 동기화하기 위해 2개의 플러시 기능을 백그라운드로 실행</li>\n</ul>\n<h4>플러시 리스트 플러시</h4>\n<ul>\n<li>\n<p>오래된 리두 로그 공간이 지워지려면 반드시 InnoDB 버퍼 풀의 <strong>더티 페이지가 먼저 디스크와 동기화</strong>돼야함</p>\n</li>\n<li>\n<p>주기적으로 <strong>플러시 리스트</strong> (Flush_list) 플러시 함수를 호출</p>\n<ul>\n<li>오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">innodb_page_cleaners</code></p>\n<ul>\n<li><strong>클리너 스레드</strong> (더티 페이지를 디스크로 동기화하는 스레드)의 개수를 조정</li>\n<li>하나의 클리너 스레드가 하나의 버퍼 풀 인스턴스를 처리\n<ul>\n<li>버퍼 풀 인스턴스보다 많은 클리너 스레드가 설정되어도 버퍼 풀 인스턴스의 개수에 맞춰짐</li>\n<li>버퍼 풀 인스턴스보다 적을 때에는 하나의 클리너 스레드가 여러 버퍼 풀 인스턴스를 처리</li>\n<li><strong>되도록 동일한 값으로 설정</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">innodb_max_dirty_pages_pct</code></p>\n<ul>\n<li><strong>더티 페이지의 비율</strong>을 조정</li>\n<li>더티 페이지의 비율이 클수록 디스크 쓰기 작업을 줄이는 효과가 극대화 → <strong>가능한 기본값 유지</strong></li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">innodb_io_capacity</code>, <code class=\"language-text\">innodb_io_capacity_max</code></p>\n<ul>\n<li><strong>디스크 IO Burst 문제</strong>: 더티 페이지가 계속 쌓이다가 한계에 도달하면 갑자기 대량의 디스크 쓰기가 발생</li>\n<li>예시: 평소에는 초당 100MB 쓰기 → 갑자기 초당 5GB 쓰기 발생 → 쿼리 응답 시간 폭증</li>\n<li><code class=\"language-text\">innodb_io_capacity</code>: InnoDB가 평상시에 초당 디스크에 쓸 수 있는 IOPS (기본값: 200)</li>\n<li><code class=\"language-text\">innodb_io_capacity_max</code>: 급한 상황에서 사용할 수 있는 최대 IOPS</li>\n<li>주의: 디스크의 최대 성능을 그대로 설정하면 안 됨 (사용자 쿼리 처리에도 디스크 IO 필요)</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">innodb_max_dirty_pages_pct_lwm</code></p>\n<ul>\n<li>디스크로 기록되는 더티 페이지보다 더 많은 더티 페이지가 발생하면 디스크 폭발 가능</li>\n<li><strong>일정 수준 이상의 더티 페이지</strong>가 발생하면 조금씩 디스크로 동기화</li>\n<li>더티 페이지의 비율이 너무 낮은 값으로 유지된다면, 높게 조정</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">innodb_adaptive_flushing</code></p>\n<ul>\n<li>다른 시스템 변수를 무시하고, <strong>리두 로그의 증가 속도를 분석해서 적절한 수준의 더티 페이지가 버퍼 풀에 유지될 수 있도록</strong> 디스크 쓰기를 실행</li>\n<li><code class=\"language-text\">innodb_adaptive_flushing_lwm</code>\n<ul>\n<li>이 값보다 활성 리두 공간의 비율이 낮으면 어댑티브 플러시가 작동 안함</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">innodb_flush_neighbors</code></p>\n<ul>\n<li><strong>이웃 페이지 함께 쓰기 기능</strong>: 더티 페이지를 디스크에 기록할 때, 물리적으로 인접한 페이지 중 더티 페이지가 있으면 같이 기록</li>\n</ul>\n<p><strong>예시로 이해하기</strong></p>\n<p>디스크에 페이지가 다음과 같이 저장되어 있다고 가정:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[페이지100] [페이지101] [페이지102] [페이지103] [페이지104]\n   더티       깨끗한       더티       더티       깨끗한</code></pre></div>\n<ul>\n<li>\n<p><code class=\"language-text\">innodb_flush_neighbors = 0</code> (비활성화)</p>\n<ul>\n<li>페이지100만 디스크에 쓰기 (1번의 디스크 IO)</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">innodb_flush_neighbors = 1</code> (활성화)</p>\n<ul>\n<li>페이지100, 102, 103을 한 번에 쓰기 (1번의 디스크 IO로 3개 처리)</li>\n<li>HDD는 헤드가 움직이는 비용이 크므로 한 번에 여러 페이지를 쓰는 게 효율적</li>\n</ul>\n</li>\n</ul>\n<p><strong>디스크 타입별 권장 설정</strong></p>\n<ul>\n<li><strong>HDD</strong>: <code class=\"language-text\">innodb_flush_neighbors = 1</code> 권장\n<ul>\n<li>디스크 헤드 이동 비용이 크므로 인접 페이지를 함께 쓰면 IO 횟수 감소</li>\n</ul>\n</li>\n<li><strong>SSD</strong>: <code class=\"language-text\">innodb_flush_neighbors = 0</code> 권장 (기본값)\n<ul>\n<li>랜덤 쓰기 성능이 좋아서 인접 페이지를 찾는 오버헤드가 더 비효율적</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4>LRU 리스트 플러시</h4>\n<ul>\n<li>LRU 리스트에서 사용 빈도가 낮은 데이터 페이지를 제거할 때 <strong>LRU 리스트</strong> (LRU_list) 플러시 함수를 사용</li>\n<li>LRU 리스트의 끝에서 최대 <code class=\"language-text\">innodb_lru_scan_depth</code>만큼 페이지를 스캔</li>\n<li>클린 페이지는 즉시 프리 리스트로, 더티 페이지는 디스크에 동기화</li>\n<li>버퍼 풀 인스턴스마다 스캔하기 때문에 스캔은 <code class=\"language-text\">innodb_buffer_pool_instances * innodb_lru_scan_depth</code> 수만큼 수행</li>\n</ul>\n<h3>버퍼 풀 상태 백업 및 복구</h3>\n<ul>\n<li>버퍼 풀에 쿼리들이 사용할 데이터가 이미 준비되어 있어야 성능이 좋음\n<ul>\n<li><strong>워밍업</strong> (Warming Up): 버퍼 풀에 데이터가 적재되어있는 상태</li>\n<li>몇십 배의 쿼리 처리 속도를 보임</li>\n</ul>\n</li>\n<li><code class=\"language-text\">innodb_buffer_pool_dump_now</code>, <code class=\"language-text\">innodb_buffer_pool_load_now</code>\n<ul>\n<li>서버를 재시작 하는 과정에서 버퍼 풀의 상태를 백업한 뒤 복구</li>\n</ul>\n</li>\n</ul>\n<h4>백업</h4>\n<ul>\n<li>데이터 디렉토리의 <code class=\"language-text\">ib_buffer_pool</code> 파일에 저장</li>\n<li>LRU 리스트에 적재된 데이터 페이지의 메타 정보만 저장\n→ 버퍼 풀의 크기에 비해 작은 용량만 차지</li>\n</ul>\n<h4>복구</h4>\n<ul>\n<li>백업된 메타 정보를 바탕으로 디스크에서 데이터 페이지를 읽어와야 하기 때문에 상당한 시간이 소요됨</li>\n<li><code class=\"language-text\">innodb_buffer_pool_load_abort</code>\n<ul>\n<li>복구가 완료되지 않은 상태에서 서버를 재개할 수 있도록 함</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><code class=\"language-text\">ib_buffer_pool</code> 파일의 데이터 페이지가 실제로 존재하지 않는 페이지는 무시\n<br>\n셧다운 직전의 파일을 사용하지 않더라도 정상적으로 서버를 시작할 수 있음</p>\n</blockquote>\n<h4>자동화</h4>\n<ul>\n<li><code class=\"language-text\">innodb_buffer_pool_dump_at_shutdown</code>, <code class=\"language-text\">innodb_buffer_pool_load_at_startup</code></li>\n</ul>\n<h3>버퍼 풀의 적재 내용 확인</h3>\n<ul>\n<li><code class=\"language-text\">information_schema</code>의 <code class=\"language-text\">innodb_cached_indexes</code> 테이블\n<ul>\n<li>인덱스별로 데이터 페이지가 얼마나 InnoDB 버퍼 풀에 적재되어 있는지 확인</li>\n</ul>\n</li>\n</ul>\n<h2>Double Write Buffer</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/88badb8b75b0c381d4965350ea5e6dd6/36c33/doublewrite.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 81.0126582278481%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAACYUlEQVR42oWUW0tqURSF+3G+90f8DT304KtvvgSBIJoPauIFNTW1vGSplamVpqWlBIJQSqjoPHzzsEQ553A2zL3muo01xlhz7731ei2z2Uym0+lObI+Rm/7397eGyReLhWw/ewzUajW5vb3dxP39vRSLRTk7O5NkMimhUEjS6bSuazQacnd3p1Eul6XdbisQxDaAj4+P8vLyIt1uV56enuTy8lIGg4F4vV5JpVIyGo10vl6v6xigb29v2j4/P/8J2Gw29aROp6M5gLBhs91ul3A4LJPJROfcbrcq6PV6esB/AWHLyR6PR1qtlhweHorVapXxeKwAZg2MHx4edO8/AQkk0yJpOBxKv9+Xj48Pzd/f3zVYgz3mgM/PT/n6+toFhLqJQqEg19fXanylUpGrqyvtk9PCDJa0AOM3Fuxcyuvrqw4iBcnksEQ2Y9VqVYLBoCQSCQkEAnJ+fq6VACDsYaqAaIcBJcKNxmIxiUajks1mJR6Pa9lcXFzoPIDMU0bM0ccOGHKwAi6XS5VG/SEJJtQXADc3N7rRyCTwjRYVzBuvUaGA8/lcTeYkv9+vpVIqlcThcOghMKVlDSAwwXMCIlhDkCvgarWSfD6vfuCNy+VSCzKZjPpKTWLF0dGRHBwcqAVOp1MsFov2uXU+y5+fn9+AvACiYAHggjAeacfHxzqOFcZTZHLIycmJRCIRZc0DsY2HbAaIkmEBkgHZ398Xm82mkpgz/hF4xs3+9UthIR5Rf0ilJADFF26VHNY+n0/VnJ6e6k3ncjklsgPIC6mGJYHxJmBBmL8QrfnbkPONbwP+AlTpXxNl2M+nAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"더블라이트\"\n        title=\"\"\n        src=\"/static/88badb8b75b0c381d4965350ea5e6dd6/f058b/doublewrite.png\"\n        srcset=\"/static/88badb8b75b0c381d4965350ea5e6dd6/c26ae/doublewrite.png 158w,\n/static/88badb8b75b0c381d4965350ea5e6dd6/6bdcf/doublewrite.png 315w,\n/static/88badb8b75b0c381d4965350ea5e6dd6/f058b/doublewrite.png 630w,\n/static/88badb8b75b0c381d4965350ea5e6dd6/40601/doublewrite.png 945w,\n/static/88badb8b75b0c381d4965350ea5e6dd6/36c33/doublewrite.png 946w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>왜 리두 로그만으로는 부족한가?</strong></p>\n<p>리두 로그는 <strong>변경된 내용</strong>(delta)만 기록합니다. 예를 들어:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">리두 로그: \"13번 페이지의 100번째 바이트를 'A'에서 'B'로 변경\"</code></pre></div>\n<p>이는 <strong>원본 페이지가 온전하다는 전제</strong> 하에서만 복구가 가능합니다.</p>\n<p><strong>부분 페이지 손상(Partial Page) 문제</strong></p>\n<p>16KB 페이지를 디스크에 쓰는 도중 전원이 나가면:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">정상 페이지: [16KB 완전한 데이터]\n손상 페이지: [8KB 새로운 데이터] [8KB 쓰레기 데이터]</code></pre></div>\n<p>이 상태에서 리두 로그를 재생하면:</p>\n<ul>\n<li>리두 로그: \"13번 페이지의 100번째 바이트를 'A'에서 'B'로 변경\"</li>\n<li>문제: <strong>13번 페이지가 이미 손상되어 있어서 적용 불가능</strong></li>\n</ul>\n<p><strong>Double Write Buffer의 역할</strong></p>\n<ol>\n<li>\n<p>더티 페이지를 디스크에 쓰기 전에:</p>\n<ul>\n<li>더티 페이지 → DoubleWrite 버퍼에 먼저 기록 (완전한 페이지 백업)</li>\n</ul>\n</li>\n<li>\n<p>DoubleWrite 버퍼 기록 완료 후:</p>\n<ul>\n<li>더티 페이지 → 실제 데이터 파일에 기록</li>\n</ul>\n</li>\n<li>\n<p>크래시 복구 시:</p>\n<ul>\n<li>데이터 파일 페이지가 손상되었나? → DoubleWrite 버퍼에서 복사</li>\n<li>데이터 파일 페이지가 정상인가? → 리두 로그로 복구</li>\n</ul>\n</li>\n</ol>\n<h2>언두 로그</h2>\n<ul>\n<li>DML(<code class=\"language-text\">INSERT</code>, <code class=\"language-text\">UPDATE</code>, <code class=\"language-text\">DELETE</code>)로 <strong>변경되기 이전의 데이터를 백업</strong></li>\n<li><strong>트랜잭션 보장</strong>\n<ul>\n<li>트랜잭션 롤백 시 언두 로그의 데이터를 이용해 복구</li>\n</ul>\n</li>\n<li><strong>격리 수준 보장</strong>\n<ul>\n<li>데이터 변경 도중 다른 커넥션에서 데이터를 조회하면, 격리 수준에 따라 언두 로그의 데이터를 반환</li>\n</ul>\n</li>\n</ul>\n<h3>언두 로그 레코드 모니터링</h3>\n<ul>\n<li><strong>대용량의 데이터를 처리</strong>하는 경우, <strong>트랜잭션이 오래 실행</strong>되는 경우에 언두 로그의 양이 급격히 증가\n<ul>\n<li>여러 트랜잭션이 동일한 데이터를 다루는 경우, 남아있는 트랜잭션이 있으면 모든 리두 로그를 보관</li>\n</ul>\n</li>\n<li>이전에는 한 번 늘어난 언두 로그 사용 공간을 줄일 수 없었음\n<ul>\n<li>언두 로그를 순환하며 순차적으로 사용해 디스크 공간 절약</li>\n<li>MySQL 서버가 필요한 시점에 사용 공간을 자동으로 줄임</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>언두 로그 레코드 건수 확인</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">ENGINE</span> <span class=\"token keyword\">INNODB</span> <span class=\"token keyword\">STATUS</span> \\G</code></pre></div>\n</blockquote>\n<h3>언두 테이블스페이스 관리</h3>\n<ul>\n<li><strong>언두 테이블스페이스</strong> (Undo Tablespace): 언두 로그가 저장되는 공간</li>\n<li>시스템 테이블스페이스 외부의 별도 로그 파일에 기록되도록 개선됨</li>\n</ul>\n<h4>언두 테이블스페이스 구조</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/497a021fcf60b8cacc96d777175615ff/e5715/undospace.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 82.27848101265823%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB7UlEQVR42pWUV6siQRBG/f9/RMUXQVAx54A555yzog+iYt09teiy9w6sO1DTPd1Vp76u7h6T/HpOp5PsdjvZ7/dqh8Ph3X63lw/+x+NRvj+m+/0uuVxOCoXC2zwej3i9XrHb7eJwOLT1+XwSDAbfvsViUX0ajYZcr1eFPZ9PMd1uN6nX69Lv92U4HEo+n5dMJiPlcln7AGq1ms53Oh3p9Xpq+MZiMQkEAprsfD7/VgiwWq2qc7vdFrfbLX6/X7OjFHgqlZJQKPROjF+325VIJKJQp9Mpi8XibyBZCahUKtpnDFutVgpotVqqmGQvMMBoNKoi8PsBpB7UhrZUKqnNZjP9RkGz2VQw/h8ByUy9BoOBBqJss9loOZbLpbbj8fhd04+AqALGpmDz+VzHXysgmZFCEhoCsdFopOqw7XarcyyZjZhMJoYKDYEoyGazqpLdpU8gSgH9N/ClkDqhjrHL5aJjBACijh8tGUcUcjS4CShEKeqAr9drBaKSMZKFw2HjTQHEyScrRSeI8wg8nU4rnIONz2tTaDnUPxQ+Hg8NisfjGvgy6pdMJvWWMI/xnUgktM+V5DYxD5DToEBe/D3IZLVaxWKxvI1vI2PObDaLzWbTa+dyuWQ6nf4B8qCUGvFHAU7B/2XUkJbVsHkAvwBep2Ou50bydAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"언두테이블스페이스\"\n        title=\"\"\n        src=\"/static/497a021fcf60b8cacc96d777175615ff/f058b/undospace.png\"\n        srcset=\"/static/497a021fcf60b8cacc96d777175615ff/c26ae/undospace.png 158w,\n/static/497a021fcf60b8cacc96d777175615ff/6bdcf/undospace.png 315w,\n/static/497a021fcf60b8cacc96d777175615ff/f058b/undospace.png 630w,\n/static/497a021fcf60b8cacc96d777175615ff/e5715/undospace.png 768w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>하나의 언두 테이블 스페이스는 1 ~ 128 개의 <strong>롤백 세그먼트</strong>를 가짐</li>\n<li>롤백 세그먼트는 1개 이상의 <strong>언두 슬롯</strong> (Undo Slot)을 가짐\n<ul>\n<li>InnoDB의 페이지 크기를 16바이트로 나눈 값 만큼</li>\n<li>예: 16KB 페이지 = 16 * 1024 / 16 = 1024개의 슬롯</li>\n<li>언두 로그 슬롯이 부족한 경우에는 트랜잭션을 시작할 수 없음</li>\n</ul>\n</li>\n<li>하나의 트랜잭션이 필요로 하는 언두 슬롯의 개수는 <strong>최대 4개</strong>\n<ul>\n<li>일반적으로는 <strong>2개</strong> 사용 (INSERT용 1개 + UPDATE/DELETE용 1개)</li>\n</ul>\n</li>\n</ul>\n<p><strong>최대 동시 처리 가능한 트랜잭션 개수 계산</strong></p>\n<p>공식:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(InnoDB 페이지 크기) / 16 * (롤백 세그먼트 개수) * (언두 테이블스페이스 개수) / (트랜잭션당 평균 슬롯)</code></pre></div>\n<p>기본 설정 기준 계산:</p>\n<ul>\n<li>페이지 크기: 16KB</li>\n<li>롤백 세그먼트: 128개 (<code class=\"language-text\">innodb_rollback_segments=128</code>)</li>\n<li>언두 테이블스페이스: 2개 (<code class=\"language-text\">innodb_undo_tablespaces=2</code>)</li>\n<li>트랜잭션당 평균 슬롯: 2개</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">16 * 1024 / 16 * 128 * 2 / 2 = 131,072개</code></pre></div>\n<p>약 <strong>13만 개의 트랜잭션을 동시에 처리</strong>할 수 있습니다.</p>\n<p><strong>권장 사항</strong></p>\n<ul>\n<li>일반적인 서비스에서 13만 개의 동시 트랜잭션이 필요한 경우는 거의 없음</li>\n<li>기본값으로 충분하므로 <strong>가능하면 기본값을 유지</strong></li>\n<li>언두 로그 공간이 남는 것은 문제없지만, <strong>슬롯이 부족하면 트랜잭션을 시작할 수 없는 심각한 문제</strong> 발생</li>\n</ul>\n<h4>Undo tablespace truncate</h4>\n<ul>\n<li>언두 테이블스페이스 공간을 필요한 만큼만 남기고 <strong>과도하게 할당된 공간을 운영체제로 반납</strong>하는 것</li>\n<li>자동 모드\n<ul>\n<li>InnoDB 스토리지 엔진의 <strong>퍼지 스레드</strong> (Purge Thread)가 주기적으로 불필요한 언두로그를 제거\n<ul>\n<li>완료된 트랜잭션이 생성한 언두 로그들</li>\n</ul>\n</li>\n<li><code class=\"language-text\">innodb_undo_log_tuncate</code>을 설정해 퍼지 스레드가 언두 로그 파일의 사용되지 않는 부분을 반납</li>\n<li><code class=\"language-text\">innodb_purge_rseg_truncate_frequency</code>로 작업의 빈도를 조절</li>\n</ul>\n</li>\n<li>수동 모드\n<ul>\n<li>언두 테이블 스페이스를 비활성화</li>\n<li>퍼지 스레드가 비활성 상태의 언두 테이블의 불필요한 공간을 반납</li>\n<li>언두 테이블 스페이스가 최소 3개 이상 되어야 작동할 수 있음</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>언두 테이블스페이스 비활성화</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">ALTER</span> UNDO <span class=\"token keyword\">TABLESPACE</span> tablespace_name <span class=\"token keyword\">SET</span> INACTIVE<span class=\"token punctuation\">;</span></code></pre></div>\n</blockquote>\n<h2>체인지 버퍼</h2>\n<p><strong>버퍼 풀에는 데이터 페이지와 인덱스 페이지가 모두 캐시됩니다.</strong></p>\n<p>InnoDB는 데이터와 인덱스를 모두 16KB 페이지 단위로 관리하며, 이 페이지들이 버퍼 풀에 캐시됩니다:</p>\n<ul>\n<li><strong>데이터 페이지</strong>: 실제 테이블 행(row) 데이터</li>\n<li><strong>인덱스 페이지</strong>: B-Tree 인덱스 노드</li>\n</ul>\n<p><strong>체인지 버퍼가 필요한 이유</strong></p>\n<p>레코드를 <code class=\"language-text\">INSERT</code>하거나 <code class=\"language-text\">UPDATE</code>할 때:</p>\n<ol>\n<li>\n<p><strong>데이터 페이지 수정</strong></p>\n<ul>\n<li>테이블의 실제 데이터를 저장하는 페이지 수정</li>\n</ul>\n</li>\n<li>\n<p><strong>인덱스 페이지 수정</strong> (여러 개일 수 있음)</p>\n<ul>\n<li>해당 테이블의 모든 인덱스 업데이트 필요</li>\n<li>예: <code class=\"language-text\">users</code> 테이블에 <code class=\"language-text\">email</code>, <code class=\"language-text\">created_at</code> 인덱스가 있다면 둘 다 업데이트</li>\n</ul>\n</li>\n</ol>\n<p><strong>문제</strong>: 인덱스 페이지가 버퍼 풀에 없으면?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">시나리오: INSERT INTO users (id, email) VALUES (1000, 'test@example.com')\n\n필요한 작업:\n1. users 테이블 데이터 페이지 수정 (버퍼 풀에 있음 - 즉시 수정)\n2. email 인덱스 페이지 수정 (버퍼 풀에 없음 - 디스크에서 읽어야 함)\n   → 랜덤 디스크 IO 발생 (느림)</code></pre></div>\n<p><strong>체인지 버퍼의 해결책</strong></p>\n<ul>\n<li>인덱스 페이지가 버퍼 풀에 <strong>있으면</strong>: 즉시 업데이트</li>\n<li>인덱스 페이지가 버퍼 풀에 <strong>없으면</strong>:\n<ol>\n<li>디스크에서 읽지 않고</li>\n<li><strong>체인지 버퍼</strong>에 \"나중에 이 인덱스를 업데이트하라\"는 메모 저장</li>\n<li>나중에 해당 인덱스 페이지가 버퍼 풀에 로드되면 그때 병합</li>\n</ol>\n</li>\n</ul>\n<p><strong>버퍼 머지 스레드</strong> (Merge Thread)</p>\n<ul>\n<li>체인지 버퍼에 저장된 인덱스 변경 사항을 실제 인덱스 페이지에 병합하는 백그라운드 스레드</li>\n</ul>\n<p><strong>유니크 인덱스는 체인지 버퍼 사용 불가</strong></p>\n<p>유니크 인덱스는 중복 체크를 위해 <strong>즉시</strong> 인덱스 페이지를 읽어야 하므로 체인지 버퍼를 사용할 수 없습니다.</p>\n<ul>\n<li><code class=\"language-text\">innodb_change_buffering</code>: 작업의 종류별로 체인지 버퍼를 활성화\n<ul>\n<li><code class=\"language-text\">all</code>: 모든 인덱스 관련 작업(<code class=\"language-text\">inserts</code> + <code class=\"language-text\">deletes</code> + <code class=\"language-text\">purges</code>)</li>\n<li><code class=\"language-text\">none</code>: 버퍼링 안함</li>\n<li><code class=\"language-text\">inserts</code>: 인덱스에 새로운 아이템을 추가하는 작업만 버퍼링</li>\n<li><code class=\"language-text\">deletes</code>: 인덱스에서 기존 아이템을 삭제하는 작업(삭제됐다는 마킹 작업)만 버퍼링</li>\n<li><code class=\"language-text\">changes</code>: 인덱스에 추가하고 삭제하는 작업(<code class=\"language-text\">inserts</code> + <code class=\"language-text\">deletes</code>)만 버퍼링</li>\n<li><code class=\"language-text\">purges</code>: 인덱스 아이템을 영구적으로 삭제하는 작업만 버퍼링(백그라운드 작업)</li>\n</ul>\n</li>\n<li>기본적으로 버퍼 풀의 25%, 최대 50%까지 사용 가능\n<ul>\n<li><code class=\"language-text\">innodb_change_buffer_max_size</code>로 설정</li>\n</ul>\n</li>\n</ul>\n<h2>리두 로그 및 로그 버퍼</h2>\n<ul>\n<li>데이터베이스는 <strong>데이터 변경을 로그에 먼저 기록</strong></li>\n<li>읽기보다 쓰기가 더 느리기 때문에, <strong>쓰기 성능이 좋은 자료구조의 리두 로그를 관리</strong></li>\n<li>비정상 종료가 발생하면 리두 로그의 내용으로 데이터 파일을 서버가 종료되기 전으로 복구</li>\n<li>서버가 비정상 종료된 경우\n<ul>\n<li>커밋됐지만 데이터 파일에 기록되지 않은 데이터 → 리두 로그에 저장된 데이터를 데이터 파일에 복사</li>\n<li>롤백됐지만 데이터 파일에 이미 기록된 데이터 → 언두 로그에 저장된 데이터를 데이터 파일에 복사</li>\n<li>상황 판단을 위해서 우선 리두 로그가 필요</li>\n</ul>\n</li>\n</ul>\n<p><strong><code class=\"language-text\">innodb_flush_log_at_trx_commit</code> - 리두 로그 디스크 동기화 설정</strong></p>\n<p>리두 로그를 <strong>리두 로그 파일</strong> (디스크 파일)에 기록하는 방식을 결정하는 가장 중요한 설정입니다.</p>\n<p><strong>중요</strong>: 리두 로그 파일도 결국 디스크의 파일입니다. 하지만 디스크 파일에 쓸 때 OS의 페이지 캐시(메모리 버퍼)를 거칩니다.</p>\n<p><strong>파일 쓰기의 2단계</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[MySQL 메모리 영역]\n리두 로그 버퍼 (innodb_log_buffer_size)\n     ↓ write() 시스템 콜\n\n[OS 메모리 영역]\nOS 페이지 캐시 (ib_logfile0, ib_logfile1의 메모리 캐시)\n     ↓ fsync() 시스템 콜\n\n[디스크]\n리두 로그 파일 (ib_logfile0, ib_logfile1 실제 디스크 파일)</code></pre></div>\n<ul>\n<li><strong>write()</strong>: 리두 로그 버퍼 → OS 페이지 캐시 (메모리 to 메모리, 빠름)</li>\n<li><strong>fsync()</strong>: OS 페이지 캐시 → 디스크의 리두 로그 파일 (메모리 to 디스크, 느림, 안전함)</li>\n</ul>\n<p><strong>왜 OS 페이지 캐시를 거치나요?</strong></p>\n<p>모든 파일 쓰기는 성능을 위해 OS가 메모리에 먼저 캐싱합니다. <code class=\"language-text\">fsync()</code>를 명시적으로 호출해야만 실제 디스크로 강제 쓰기됩니다.</p>\n<p><strong>설정값별 동작 방식</strong></p>\n<p><strong><code class=\"language-text\">0</code> - 가장 빠르지만 가장 위험</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">동작: 1초마다 write + fsync\n\n트랜잭션 커밋 → 아무것도 안 함 (리두 로그 버퍼에만 존재)\n1초 후 → 리두 로그 버퍼 → OS 페이지 캐시 (write) → ib_logfile (fsync)\n\n위험: MySQL이나 서버 장애 시 최대 1초치 데이터 손실</code></pre></div>\n<p><strong><code class=\"language-text\">1</code></strong> - 가장 안전하지만 가장 느림 (기본값, 권장)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">동작: 커밋마다 write + fsync\n\n트랜잭션 커밋 → 리두 로그 버퍼 → OS 페이지 캐시 (write) → ib_logfile (fsync)\n\n안전: 커밋된 트랜잭션은 절대 손실 안 됨 (ACID 보장)\n단점: fsync 호출이 많아서 성능이 떨어짐</code></pre></div>\n<p><strong><code class=\"language-text\">2</code> - 절충안</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">동작: 커밋마다 write, 1초마다 fsync\n\n트랜잭션 커밋 → 리두 로그 버퍼 → OS 페이지 캐시 (write)\n1초 후 → OS 페이지 캐시 → ib_logfile (fsync)\n\n위험: OS 장애(커널 패닉, 전원 차단) 시 최대 1초치 데이터 손실\n      MySQL만 죽으면 데이터 안전 (OS 페이지 캐시에 있음)\n장점: fsync를 1초마다만 하므로 성능이 1번보다 훨씬 좋음</code></pre></div>\n<p><strong>추가 설정</strong></p>\n<ul>\n<li><code class=\"language-text\">innodb_flush_log_at_timeout</code>: fsync 주기 조절 (기본값 1초 권장)</li>\n</ul>\n<blockquote>\n<p>ACID\nAtomic - 원자성\nConsistent - 일관성\nIsolated - 격리성\nDurable - 지속성</p>\n</blockquote>\n<h3>리두 로그 아카이빙</h3>\n<ul>\n<li>백업을 위해 데이터를 복사하는 동안, 리두 로그도 복사해줘야함\n<ul>\n<li>리두 로그가 매우 빠르게 증가하면 리두 로그를 복사하기 전에 <strong>새 리두 로그에 의해 덮어씌워질 수 있음</strong></li>\n</ul>\n</li>\n<li>리두 로그 아카이빙을 통해 리두 로그가 덮어쓰인다고 해도 <strong>백업이 실패하지 않도록</strong> 함</li>\n<li><code class=\"language-text\">innodb_redo_log_archive_dirs</code>로 아카이빙된 리두 로그가 저장될 디렉토리를 설정</li>\n<li><code class=\"language-text\">innodb_redo_log_archive_start</code>\n<ul>\n<li><strong>UDF</strong> (User Defined Function)</li>\n<li>첫 번째 파라미터는 리두 로그를 아카이빙할 디렉토리</li>\n<li>두 번째 파라미터는 서브디렉토리 (<code class=\"language-text\">innodb_redo_log_archive_dirs</code>)</li>\n<li><code class=\"language-text\">DO innodb_redo_log_archive_start('backup', '20251003');</code></li>\n<li><code class=\"language-text\">innodb_redo_log_archive_stop</code>으로 종료</li>\n</ul>\n</li>\n<li>로그 파일이 로테이션될 때가 아니라 리두 로그 파일에 로그 엔트리가 추가될 때 함께 기록</li>\n<li>아카이빙 중 세션이 종료되는 등 문제가 발생하면 <strong>아카이빙 파일도 자동으로 삭제</strong></li>\n</ul>\n<h3>리두 로그 활성화 및 비활성화</h3>\n<ul>\n<li>트랜잭션이 커밋돼도 데이터 파일은 즉시 디스크로 동기화되지 않지만, 리두 로그는 항상 디스크로 기록</li>\n<li><strong>데이터 복구나 대용량 데이터를 한 번에 적재하는 경우</strong> 리두 로그를 비활성화 가능\n<ul>\n<li><code class=\"language-text\">ALTER INSTANCE DISABLE INNODB REDO_LOG;</code></li>\n<li><code class=\"language-text\">ALTER INSTANCE ENABLE INNODB REDO_LOG;</code></li>\n</ul>\n</li>\n<li>리두 로그가 비활성화된 상태에서 서버가 비정상적으로 종료된 경우\n<ul>\n<li>데이터 파일의 각 부분이 마지막 체크포인트 이후의 여러 시점의 데이터를 갖게 됨</li>\n<li>데이터가 중요하지 않더라도 리두 로그를 활성화해서 일관성을 유지</li>\n</ul>\n</li>\n</ul>\n<h2>어댑티브 해시 인덱스</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7c6d5b52b09bcfc44c405a8f602638e7/fe83d/adaptive.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.0253164556962%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAABsElEQVR42qWSbYvTQBCA8/9/kd9VsIKceOJJ7yxe22vaJmnzspt938dJWw88PCqY4WGWYZmd3TxFeUysm8iuTSgLzRDpxnxaDxdcSBgVaB4dXRkIGqKDYP9kqhXrNrOoMw/7JGS+rjzzbeR+lyWfa52JWDlodaPY/FTM1zvaMtNveKZ7AlVJw72CVQuPTWYteT/ApoPlYSLzJDVtE855quMgN9A0o2LQDqX9M4PyGBMonGzQdUu0DiubvHG4S/69jj7goufoWsZkSBLhLxElCt91uLommFGaGsKo8S+w1uKkaZK3jD4SZP0ahTKWQVDa0Mu0dpomxDP+jL8wNb1G0dQH9tuaumqoZdKUEv/zFUq0qcqIEm2sywyTMiPI0Ng+MR4zRkwIRrTwVwjSsBQHZ/eaShrOl5YP30c+PQSWotH2zrN451jOovw48OKfU68gdngZpDBDYjgETC/vZDNZbpyjzC45+UnYLMLmU+1fKJpqZDM37BdeHFPc6Dmz7huf7Q+OqUczorJmuEKfFTobikNtWd0ayjt3kvZ9f8ub3Ufedl9oYseQRvqkr9IlhUqGX5R4ok8YbbXoAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"adaptive\"\n        title=\"\"\n        src=\"/static/7c6d5b52b09bcfc44c405a8f602638e7/f058b/adaptive.png\"\n        srcset=\"/static/7c6d5b52b09bcfc44c405a8f602638e7/c26ae/adaptive.png 158w,\n/static/7c6d5b52b09bcfc44c405a8f602638e7/6bdcf/adaptive.png 315w,\n/static/7c6d5b52b09bcfc44c405a8f602638e7/f058b/adaptive.png 630w,\n/static/7c6d5b52b09bcfc44c405a8f602638e7/40601/adaptive.png 945w,\n/static/7c6d5b52b09bcfc44c405a8f602638e7/78612/adaptive.png 1260w,\n/static/7c6d5b52b09bcfc44c405a8f602638e7/fe83d/adaptive.png 2262w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>B-Tree 인덱스 vs 어댑티브 해시 인덱스</strong></p>\n<ul>\n<li>일반적인 인덱스는 테이블에 사용자가 생성한 <strong>B-Tree 인덱스</strong>를 의미\n<ul>\n<li>루트 노드 → 브랜치 노드 → 리프 노드 (3단계 탐색 필요)</li>\n</ul>\n</li>\n<li>어댑티브 해시 인덱스는 <strong>사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스</strong>\n<ul>\n<li><code class=\"language-text\">innodb_adaptive_hash_index</code> 시스템 변수로 활성화 여부 결정</li>\n</ul>\n</li>\n<li>자주 읽히는 데이터 페이지의 키 값을 이용해 <strong>해시 인덱스</strong>를 구성\n<ul>\n<li>필요할 때마다 어댑티브 해시 인덱스를 검색해서 레코드가 저장된 데이터 페이지에 <strong>바로 1단계 접근</strong></li>\n</ul>\n</li>\n</ul>\n<p><strong>해시 인덱스 키와 값</strong></p>\n<ul>\n<li><strong>인덱스 키</strong>: B-Tree 인덱스의 고유번호(Id) + B-Tree 인덱스의 실제 키 값 조합\n<ul>\n<li>예: <code class=\"language-text\">(idx_001, \"user@example.com\")</code> → <code class=\"language-text\">hash_key_12345</code></li>\n</ul>\n</li>\n<li><strong>인덱스 값</strong>: InnoDB 버퍼 풀에 로딩된 페이지의 메모리 주소\n<ul>\n<li>예: <code class=\"language-text\">0x7f8a4c002000</code></li>\n</ul>\n</li>\n</ul>\n<p><strong>파티션 구조</strong></p>\n<ul>\n<li><code class=\"language-text\">innodb_adaptive_hash_index_parts</code>: 어댑티브 해시 인덱스의 파티션 개수 설정</li>\n<li>하나의 메모리 객체로 관리하면 내부 잠금(세마포어) 경합 발생</li>\n<li>파티션을 나누면 여러 스레드가 병렬로 접근 가능</li>\n</ul>\n<h3>어댑티브 해시 인덱스 효과가 없는 경우</h3>\n<p><strong>1. 디스크 읽기가 많은 경우</strong></p>\n<p>어댑티브 해시 인덱스는 <strong>버퍼 풀의 메모리 주소</strong>를 저장합니다. 데이터가 버퍼 풀에 없으면 소용이 없습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">시나리오: 100GB 데이터, 10GB 버퍼 풀\n\n대부분의 쿼리가 디스크에서 데이터를 읽어야 함\n→ 어댑티브 해시 인덱스 생성해도 버퍼 풀에 없어서 사용 불가\n→ 해시 인덱스 관리 오버헤드만 발생</code></pre></div>\n<p><strong>2. 조인이나 LIKE 패턴 검색이 많은 경우</strong></p>\n<p>해시 인덱스는 <strong>동등 비교</strong> (=)만 가능합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 효과 있음</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> users <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> users <span class=\"token keyword\">WHERE</span> email <span class=\"token operator\">IN</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'a@test.com'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b@test.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- 효과 없음</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> users <span class=\"token keyword\">WHERE</span> name <span class=\"token operator\">LIKE</span> <span class=\"token string\">'%kim%'</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">-- 범위 검색</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> orders o <span class=\"token keyword\">JOIN</span> users u <span class=\"token keyword\">ON</span> o<span class=\"token punctuation\">.</span>user_id <span class=\"token operator\">=</span> u<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">;</span>  <span class=\"token comment\">-- 조인</span></code></pre></div>\n<p><strong>3. 데이터 접근이 골고루 분산된 경우</strong></p>\n<p>어댑티브 해시 인덱스는 <strong>자주 접근하는 데이터</strong> (핫 데이터)에만 생성됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">시나리오: 1억 건 중 매번 다른 데이터 조회\n\nid=1, id=5000, id=9999, id=12345... (매번 다름)\n→ 같은 키를 100번 이상 연속 접근하지 않음\n→ 해시 인덱스 생성 안 됨</code></pre></div>\n<h3>어댑티브 해시 인덱스가 효과적인 경우</h3>\n<p><strong>1. 워킹셋이 버퍼 풀에 들어가는 경우</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">시나리오: 20GB 데이터, 32GB 버퍼 풀\n\n자주 사용하는 데이터(워킹셋)가 모두 버퍼 풀에 상주\n→ 해시 인덱스로 빠르게 접근 가능</code></pre></div>\n<p><strong>2. 동등 조건 검색이 많은 경우</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- PK 조회</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> users <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- 유니크 키 조회</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> users <span class=\"token keyword\">WHERE</span> email <span class=\"token operator\">=</span> <span class=\"token string\">'test@example.com'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- IN 절</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> products <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">IN</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>3. 핫 데이터 집중 패턴</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">시나리오: 최근 1주일 주문 데이터만 반복 조회\n\n전체 데이터: 1억 건\n자주 조회: 최근 100만 건 (1%)\n→ 100만 건에 대해 해시 인덱스 생성\n→ 해당 데이터 조회 시 B-Tree 탐색 생략</code></pre></div>\n<h3>테이블 변경 시 주의사항</h3>\n<p><strong>DROP TABLE이나 ALTER TABLE 실행 시 문제</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">테이블 삭제/변경 시:\n1. 해당 테이블의 모든 해시 인덱스 엔트리를 찾아서 제거해야 함\n2. 해시 테이블 전체를 스캔해야 함 (시간 소요)\n3. 스캔 중 다른 쿼리들이 해시 인덱스에 접근하지 못함 (세마포어 잠금)\n\n큰 테이블의 경우:\n- 수백만 개의 해시 인덱스 엔트리\n- 제거하는데 수 초 ~ 수십 초 소요\n- 그동안 CPU 사용률 급증</code></pre></div>\n<p><strong>권장 사항</strong></p>\n<ul>\n<li>테이블 구조 변경이 빈번한 환경: 어댑티브 해시 인덱스 비활성화 고려</li>\n<li>대부분의 운영 환경: 기본값(ON) 유지 권장</li>\n</ul>\n<h2>InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교</h2>\n<h3>MyISAM</h3>\n<ul>\n<li>기존에는 MyISAM이 기본 스토리지 엔진</li>\n<li>공간 좌표 검색, 전문 검색 기능 등 모두 InnoDB 스토리지 엔진을 지원하도록 개션</li>\n<li><strong>MySQL 서버의 모든 기능을 InnoDB 스토리지 엔진만으로 구현</strong>할 수 있어서 없어질 것</li>\n</ul>\n<h3>MEMORY</h3>\n<ul>\n<li>메모리 기반이라 하나의 스레드에서만 데이터를 읽고 쓴다면 InnoDB보다 빠를 수 있음</li>\n<li>온라인 트랜잭션 처리에서는 <strong>동시 처리 성능</strong>이 매우 중요\n<ul>\n<li>MEMORY 스토리지 엔진은 테이블 수준의 잠금으로 성능이 부족함</li>\n</ul>\n</li>\n<li>사용자의 쿼리를 처리하기 위한 임시 테이블도 MEMORY에서 TempTable 스토리지 엔진으로 대체</li>\n<li>향후 버전에서 제거될 것</li>\n</ul>\n<h2>에러 로그 파일</h2>\n<ul>\n<li>MySQL이 실행되는 도중 발생하는 <strong>에러나 경고 메시지가 출력</strong>되는 로그 파일</li>\n<li>MySQL 설정 파일(<code class=\"language-text\">my.cnf</code>)에서 <code class=\"language-text\">log_error</code> 파라미터로 정의된 경로에 생성\n<ul>\n<li>별도로 정의되지 않으면 <code class=\"language-text\">datadir</code> 파라미터로 정의된 경로에 <code class=\"language-text\">.err</code> 확장자로 생성</li>\n</ul>\n</li>\n</ul>\n<h3>MySQL이 시작하는 과정과 관련된 정보성 및 에러 메시지</h3>\n<ul>\n<li>MySQL 서버의 정상적인 기동 확인 (<code class=\"language-text\">mysqld: ready for connections</code>)</li>\n<li>새로 변경하거나 추가한 파라미터가 정상적으로 적용되었는지 확인하는 용도</li>\n</ul>\n<h3>마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB의 트랜잭션 복구 메시지</h3>\n<ul>\n<li>비정상으로 종료된 경우 다시 시작하면서 <strong>재처리 작업</strong>을 수행\n<ol>\n<li>완료되지 못한 트랜잭션 정리</li>\n<li>디스크에 기록되지 못한 데이터를 다시 기록</li>\n</ol>\n</li>\n</ul>\n<h3>쿼리 처리 도중 발생하는 문제에 대한 에러 메시지</h3>\n<ul>\n<li>사전 예방이 어려움\n<ul>\n<li>주기적으로 에러 로그 파일을 검토하며 발견</li>\n</ul>\n</li>\n</ul>\n<h3>비정상적으로 종료된 커넥션 메시지(Aborted connection)</h3>\n<ul>\n<li>클라이언트 애플리케이션에서 정상적으로 접속 종료를 하지 못하고 프로그램이 종료된 경우</li>\n<li>네트워크 문제일 수 있지만, <strong>애플리케이션의 커넥션 종료 로직을 검토</strong></li>\n<li><code class=\"language-text\">max_connect_errors</code>\n<ul>\n<li>클라이언트 호스트에서 발생한 에러의 횟수가 이 시스템 변수를 넘어가는지 확인</li>\n<li>넘어가면 <code class=\"language-text\">Host ‘host_name’ is blocked</code> 에러 발생</li>\n</ul>\n</li>\n</ul>\n<h3>InnoDB의 모니터링 또는 상태 조회 명령의 결과 메시지</h3>\n<ul>\n<li>테이블 모니터링, 락 모니터링, 엔진 상태 조회 명령은 상대적으로 <strong>큰 메시지를 에러 로그 파일에 기록</strong></li>\n<li>InnoDB의 모니터링을 활성화 상태로 유지하는 경우, 에러 로그 파일이 매우 커질 수 있음</li>\n</ul>\n<h3>MySQL의 종료 메시지</h3>\n<ul>\n<li><strong>왜 MySQL이 종료됐는지 확인하는 유일한 방법</strong></li>\n<li><code class=\"language-text\">Received SHUTDOWN from user ...</code>: 누군가 MySQL 서버를 종료시킨 경우</li>\n<li>종료 메시지가 없거나 스택 트레이스가 출력되는 경우 <strong>세그멘테이션 폴트</strong> (Segmentation fault)</li>\n</ul>\n<h2>제너럴 쿼리 로그 파일</h2>\n<ul>\n<li>MySQL 서버에서 실행되는 <strong>쿼리의 전체 목록 검토 목적</strong></li>\n<li>쿼리 로그 활성화 → 쿼리 로그 파일 기록</li>\n<li>슬로우 쿼리 로그와 달리 제너럴 쿼리 로그는 실행되기 전에 MySQL이 <strong>요청을 받으면 바로 기록</strong>\n<ul>\n<li>쿼리 실행 중 에러가 발생해도 일단 로그 파일에 기록됨</li>\n</ul>\n</li>\n<li><code class=\"language-text\">general_log_file</code>: 쿼리 로그 파일의 경로</li>\n<li><code class=\"language-text\">log_output</code>: 파일이 아닌 테이블에 저장하도록 설정할 수 있음</li>\n</ul>\n<h2>슬로우 쿼리 로그</h2>\n<ul>\n<li><strong>쿼리 튜닝</strong> 목적으로 어떤 쿼리가 문제의 쿼리인지 판단하기 위함</li>\n<li><code class=\"language-text\">long_query_time</code> 시스템 변수보다 오래 걸린 쿼리를 기록</li>\n<li>쿼리가 <strong>정상적으로 실행이 완료되어야</strong> 슬로우 쿼리에 기록될 수 있음</li>\n<li><code class=\"language-text\">log_output</code>: 쿼리를 파일로 기록할지 테이블로 기록할지 선택\n<ul>\n<li><code class=\"language-text\">TABLE</code>로 설정하면 <code class=\"language-text\">general_log</code>와 <code class=\"language-text\">slow_log</code> 테이블에 저장</li>\n</ul>\n</li>\n<li>InnoDB 테이블에만 접근하는 쿼리 문장의 슬로우 쿼리 로그에서 <code class=\"language-text\">Lock_time</code> 값은 도움안됨\n<ul>\n<li>InnoDB는 MySQL의 <strong>엔진 레벨 잠금</strong>과 <strong>스토리지 엔진 자체의 잠금</strong>을 갖고있음</li>\n</ul>\n</li>\n<li>Percona Toolkit의 <code class=\"language-text\">pt-query-digest</code> 스크립트를 이용하여 <strong>빈도나 처리 성능별 쿼리 정렬</strong>이 가능</li>\n</ul>\n<h3>슬로우 쿼리 통계</h3>\n<ul>\n<li>모든 쿼리를 대상으로 슬로우 쿼리 로그의 <strong>실행 시간</strong> (<code class=\"language-text\">Exec time</code>), <strong>잠금 대기 시간</strong> (<code class=\"language-text\">Lock time</code>)에 평균 및 최소/최대를 표시</li>\n</ul>\n<h3>실행 빈도 및 누적 실행 시간순 랭킹</h3>\n<ul>\n<li>각 쿼리별 응답 시간과 실행 횟수</li>\n<li><code class=\"language-text\">Query ID</code>는 쿼리 문장을 정규화해서 만들어진 해시 값을 의미\n<ul>\n<li>같은 모양의 쿼리라면 동일한 <code class=\"language-text\">Query ID</code>를 가짐</li>\n</ul>\n</li>\n</ul>\n<h3>쿼리별 실행 횟수 및 누적 실행 시간 상세 정보</h3>\n<ul>\n<li><code class=\"language-text\">Query ID</code>별 쿼리를 쿼리 랭킹에 표시된 순서대로 자세한 내용을 표시</li>\n<li>쿼리가 얼마나 실행됐는지, 쿼리에 응답 시간에 대한 히스토그램</li>\n</ul>","wordCount":{"words":5450},"frontmatter":{"title":"MySQL 엔진 아키텍처","date":"October 05, 2025","description":"MySQL과 InnoDB의 내부 아키텍처를 심층 분석합니다. 스레드 구조, 메모리 할당, 버퍼 풀, 리두 로그, MVCC, Change Buffer, Adaptive Hash Index 등 핵심 개념을 시각화와 함께 상세히 설명합니다."}},"previous":{"fields":{"slug":"/cache-part2/"},"frontmatter":{"title":"Facebook Memcached 아키텍처 (2탄) - 대규모 확장과 성능 최적화"}},"next":{"fields":{"slug":"/mysql-part5/"},"frontmatter":{"title":"InnoDB 잠금 메커니즘"}}},"pageContext":{"id":"0f5161ec-2733-56c1-b9de-d2120698a099","previousPostId":"c562831f-2840-545a-9e1c-fdd33dc31eeb","nextPostId":"fc8dd2a7-221d-5fd5-8e50-688bc7c7a494"}},"staticQueryHashes":["3257411868","3517523002"],"slicesMap":{}}