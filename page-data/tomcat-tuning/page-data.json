{"componentChunkName":"component---src-templates-blog-post-js","path":"/tomcat-tuning/","result":{"data":{"site":{"siteMetadata":{"title":"GoToBill"}},"markdownRemark":{"id":"ae0daa87-98e0-5dd4-b5c1-bd4dc589775c","excerpt":"Thread Pool 튜닝 Context Switching 이해하기 스레드 수를 무작정 늘리면 성능이 좋아질까요? 아닙니다. Context Switching…","html":"<h2>Thread Pool 튜닝</h2>\n<h3>Context Switching 이해하기</h3>\n<p>스레드 수를 무작정 늘리면 성능이 좋아질까요? 아닙니다.</p>\n<p><strong>Context Switching</strong> 오버헤드 때문입니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/83ce3a98fd4d79a3a488111e8a6fed2e/098d4/context.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 25.316455696202528%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA/0lEQVR42kVQy3KDMBDjHwADfgC2ibEhpEk6k0477aX//0+qbA49aOzVerWyKiEspmnH7fYN5+8QwqHvFwxDwLZ/QumErgvkApy747j9wNo39iOxcuaB5/svZnJSbqja1vIScBwvjGMqgl13Cl73F3sr6wt6QquE5+MDxiT0FOv7lWau5L6g9X4K5uG2dWibmWKegwtE4RY0tUVHZ1ImSLVRJKLjm+x4GBIUBbLT7D7XxhyommZCXRtiOtGMGNUIO82EQ1giFr8hxR3hksh5+Nlj1LYYyT8SZYkrEVS5yN/+bzJDNrUKJQKtV2gTuZ2njiVvw1oOZ66nu7VEJOWOP6JniJ0Yg0EPAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Context Switching 오버헤드\"\n        title=\"\"\n        src=\"/static/83ce3a98fd4d79a3a488111e8a6fed2e/f058b/context.png\"\n        srcset=\"/static/83ce3a98fd4d79a3a488111e8a6fed2e/c26ae/context.png 158w,\n/static/83ce3a98fd4d79a3a488111e8a6fed2e/6bdcf/context.png 315w,\n/static/83ce3a98fd4d79a3a488111e8a6fed2e/f058b/context.png 630w,\n/static/83ce3a98fd4d79a3a488111e8a6fed2e/40601/context.png 945w,\n/static/83ce3a98fd4d79a3a488111e8a6fed2e/78612/context.png 1260w,\n/static/83ce3a98fd4d79a3a488111e8a6fed2e/098d4/context.png 2142w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>위 수치는 일반적인 참고값입니다. 실제 비용은 환경마다 다르므로 상대적인 크기 비교로만 활용하세요.</p>\n<p><strong>Context Switching이란?</strong></p>\n<p>CPU가 실행 중인 스레드를 다른 스레드로 전환할 때 발생하는 작업입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Thread A 실행 중\n    ↓\n[Context Switch 발생]\n    1. Thread A의 레지스터 값을 메모리에 저장\n    2. Thread A의 스택 포인터 저장\n    3. Thread B의 레지스터 값 복원\n    4. Thread B의 스택 포인터 복원\n    ↓\nThread B 실행 시작</code></pre></div>\n<h3>기본 원칙</h3>\n<p><strong>CPU 집약적 작업</strong>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">최적 스레드 수 = CPU 코어 수 + 1</code></pre></div>\n<p><strong>I/O 집약적 작업</strong> (웹 애플리케이션 대부분):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">최적 스레드 수 = CPU 코어 수 × (1 + 대기시간 / 처리시간)\n\n예: 8코어, 처리시간 10ms, DB 대기 90ms\n   = 8 × (1 + 90/10) = 8 × 10 = 80</code></pre></div>\n<p><strong>실전 공식</strong>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">maxThreads = 목표 TPS × 평균 응답 시간(초)\n\n예: 목표 1000 TPS, 평균 응답 시간 200ms\n   = 1000 × 0.2 = 200</code></pre></div>\n<h3>규모별 설정 예시</h3>\n<p><strong>소규모 서비스</strong> (트래픽 &#x3C; 100 TPS):</p>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Connector</span> <span class=\"token attr-name\">port</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>8080<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">protocol</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>HTTP/1.1<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">maxThreads</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>50<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">minSpareThreads</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>10<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">maxConnections</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>2000<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">acceptCount</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>100<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span></code></pre></div>\n<p><strong>중규모 서비스</strong> (트래픽 100-1000 TPS):</p>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Connector</span> <span class=\"token attr-name\">port</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>8080<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">protocol</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>HTTP/1.1<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">maxThreads</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>200<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">minSpareThreads</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>25<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">maxConnections</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>10000<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">acceptCount</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>500<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span></code></pre></div>\n<p><strong>대규모 서비스</strong> (트래픽 1000+ TPS):</p>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Connector</span> <span class=\"token attr-name\">port</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>8080<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">protocol</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>HTTP/1.1<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">maxThreads</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>500<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">minSpareThreads</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>50<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">maxConnections</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>20000<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">acceptCount</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>1000<span class=\"token punctuation\">\"</span></span>\n\n           <span class=\"token attr-name\">&lt;!--</span> <span class=\"token attr-name\">추가</span> <span class=\"token attr-name\">최적화</span> <span class=\"token attr-name\">--</span><span class=\"token punctuation\">></span></span>\n           processorCache=\"500\"\n           socket.directBuffer=\"true\"\n           socket.appReadBufSize=\"8192\"\n           socket.appWriteBufSize=\"8192\" /></code></pre></div>\n<h2>OS 레벨 튜닝</h2>\n<h3>파일 디스크립터 제한</h3>\n<p><strong>왜 네트워크 연결이 파일 디스크립터(FD)인가?</strong></p>\n<p>Unix 철학 <strong>\"Everything is a file\"</strong> 때문입니다. 소켓이든 파일이든 동일한 시스템 콜로 처리할 수 있도록 통일된 인터페이스를 제공합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// 파일 읽기</span>\n<span class=\"token keyword\">int</span> fd <span class=\"token operator\">=</span> <span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/tmp/file.txt\"</span><span class=\"token punctuation\">,</span> O_RDONLY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">read</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">,</span> buffer<span class=\"token punctuation\">,</span> size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">close</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 소켓 읽기 - 동일한 read/close 사용</span>\n<span class=\"token keyword\">int</span> fd <span class=\"token operator\">=</span> <span class=\"token function\">socket</span><span class=\"token punctuation\">(</span>AF_INET<span class=\"token punctuation\">,</span> SOCK_STREAM<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">connect</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">read</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">,</span> buffer<span class=\"token punctuation\">,</span> size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 같은 함수</span>\n<span class=\"token function\">close</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>               <span class=\"token comment\">// 같은 함수</span></code></pre></div>\n<p>커널 입장에서 소켓도 \"열린 자원\"이니까 FD 테이블에서 관리하는 게 자연스럽습니다.</p>\n<p><strong>문제</strong>:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 기본값 확인</span>\n<span class=\"token builtin class-name\">ulimit</span> <span class=\"token parameter variable\">-n</span>\n<span class=\"token comment\"># 1024 (너무 작음!)</span>\n\n<span class=\"token comment\"># maxConnections=10000인데 ulimit=1024이면 1024개만 연결 가능</span></code></pre></div>\n<p><strong>해결</strong>:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 현재 세션만</span>\n<span class=\"token builtin class-name\">ulimit</span> <span class=\"token parameter variable\">-n</span> <span class=\"token number\">65535</span>\n\n<span class=\"token comment\"># 영구 설정 (/etc/security/limits.conf)</span>\ntomcat soft nofile <span class=\"token number\">65535</span>\ntomcat hard nofile <span class=\"token number\">65535</span>\n\n<span class=\"token comment\"># 시스템 전체 (/etc/sysctl.conf)</span>\nfs.file-max <span class=\"token operator\">=</span> <span class=\"token number\">2097152</span></code></pre></div>\n<h3>TCP Backlog vs TCP 버퍼</h3>\n<p>두 개념은 완전히 다릅니다.</p>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>TCP Backlog</th>\n<th>TCP 버퍼</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>용도</strong></td>\n<td>연결 대기열</td>\n<td>데이터 전송 버퍼</td>\n</tr>\n<tr>\n<td><strong>언제</strong></td>\n<td>3-way handshake 완료 후, accept() 전</td>\n<td>데이터 송수신 중</td>\n</tr>\n<tr>\n<td><strong>내용물</strong></td>\n<td>연결 요청 (소켓 메타데이터)</td>\n<td>실제 패킷 데이터</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[TCP Backlog]\nClient → SYN → Server\nClient ← SYN+ACK ← Server\nClient → ACK → Server\n                ↓\n         Backlog 큐에 대기  ← somaxconn, tcp_max_syn_backlog\n                ↓\n         accept() 호출 시 꺼냄\n\n[TCP 버퍼]\n연결 수립 후 데이터 전송 시:\nClient → \"GET /api/users\" → [수신 버퍼] → Server 애플리케이션\n                                ↑\n                        tcp_rmem (receive buffer)</code></pre></div>\n<ul>\n<li><strong>somaxconn</strong>: accept() 대기 중인 연결 개수 제한</li>\n<li><strong>tcp_rmem/wmem</strong>: 한 연결당 송수신 데이터 버퍼 크기</li>\n</ul>\n<h3>SYN Queue vs Accept Queue</h3>\n<p><code class=\"language-text\">somaxconn</code>과 <code class=\"language-text\">tcp_max_syn_backlog</code> 둘 다 \"대기열\"인데, <strong>3-way handshake 완료 전/후</strong>가 다릅니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Client → SYN → Server\n                ↓\n         [SYN Queue]  ← tcp_max_syn_backlog (반쯤 연결된 상태)\n                ↓\nClient ← SYN+ACK ← Server\n                ↓\nClient → ACK → Server\n                ↓\n         [Accept Queue]  ← somaxconn (완전히 연결된 상태)\n                ↓\n         accept() 호출</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>설정</th>\n<th>큐 이름</th>\n<th>상태</th>\n<th>내용물</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>tcp_max_syn_backlog</strong></td>\n<td>SYN Queue</td>\n<td>반쯤 연결 (SYN 받음, ACK 대기)</td>\n<td>handshake 진행 중</td>\n</tr>\n<tr>\n<td><strong>somaxconn</strong></td>\n<td>Accept Queue</td>\n<td>완전 연결 (handshake 완료)</td>\n<td>accept() 대기 중</td>\n</tr>\n</tbody>\n</table>\n<p>SYN Flood 공격은 SYN만 보내고 ACK를 안 보내서 SYN Queue를 가득 채우는 공격입니다.</p>\n<h3>TIME_WAIT와 tcp_tw_reuse</h3>\n<p><strong>TIME_WAIT 상태란?</strong></p>\n<p>연결 종료 후 소켓이 바로 사라지지 않고 2분(기본값) 동안 남아있는 상태입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Client: \"연결 끊자\" (FIN)\nServer: \"ㅇㅋ\" (ACK)\nServer: \"나도 끊는다\" (FIN)\nClient: \"ㅇㅋ\" (ACK)\n        ↓\n   TIME_WAIT (2분간 대기)\n        ↓\n   소켓 완전 제거</code></pre></div>\n<p><strong>왜 2분이나 기다리나?</strong></p>\n<p>네트워크에서 지연된 패킷이 뒤늦게 도착할 수 있어서입니다. 바로 소켓을 재사용하면 이전 연결의 패킷과 섞일 수 있습니다.</p>\n<p><strong>문제 상황:</strong></p>\n<p>고트래픽 서버에서 연결이 계속 생겼다 끊기면 TIME_WAIT 소켓이 수만 개 쌓입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">netstat</span> <span class=\"token parameter variable\">-an</span> <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> TIME_WAIT <span class=\"token operator\">|</span> <span class=\"token function\">wc</span> <span class=\"token parameter variable\">-l</span>\n<span class=\"token number\">45000</span>   ← TIME_WAIT 상태 소켓 <span class=\"token number\">45000</span>개</code></pre></div>\n<p>각 소켓이 로컬 포트를 점유하니까 포트가 고갈될 수 있습니다.</p>\n<p><strong>tcp_tw_reuse=1 효과:</strong></p>\n<p>TIME_WAIT 상태인 소켓의 포트를 <strong>새 연결에 재사용</strong>할 수 있게 해줍니다. 2분 기다릴 필요 없이 바로 재활용합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">tcp_tw_reuse=0: TIME_WAIT 2분 대기 → 포트 고갈 위험\ntcp_tw_reuse=1: TIME_WAIT 소켓 포트 즉시 재사용 → 포트 고갈 방지</code></pre></div>\n<h3>TCP 파라미터</h3>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># /etc/sysctl.conf</span>\n\n<span class=\"token comment\"># TCP backlog 크기 (연결 대기열)</span>\nnet.core.somaxconn <span class=\"token operator\">=</span> <span class=\"token number\">4096</span>\nnet.ipv4.tcp_max_syn_backlog <span class=\"token operator\">=</span> <span class=\"token number\">8192</span>\n\n<span class=\"token comment\"># TIME_WAIT 소켓 재사용 (Keep-Alive 효율 향상)</span>\nnet.ipv4.tcp_tw_reuse <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n\n<span class=\"token comment\"># TIME_WAIT 타임아웃 (기본 60초 → 30초)</span>\nnet.ipv4.tcp_fin_timeout <span class=\"token operator\">=</span> <span class=\"token number\">30</span>\n\n<span class=\"token comment\"># TCP 버퍼 크기 (데이터 송수신)</span>\nnet.core.rmem_max <span class=\"token operator\">=</span> <span class=\"token number\">16777216</span>\nnet.core.wmem_max <span class=\"token operator\">=</span> <span class=\"token number\">16777216</span>\nnet.ipv4.tcp_rmem <span class=\"token operator\">=</span> <span class=\"token number\">4096</span> <span class=\"token number\">87380</span> <span class=\"token number\">16777216</span>\nnet.ipv4.tcp_wmem <span class=\"token operator\">=</span> <span class=\"token number\">4096</span> <span class=\"token number\">65536</span> <span class=\"token number\">16777216</span>\n\n<span class=\"token comment\"># 적용</span>\n<span class=\"token function\">sudo</span> <span class=\"token function\">sysctl</span> <span class=\"token parameter variable\">-p</span></code></pre></div>\n<h3>Port Range</h3>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 로컬 포트 범위 확대</span>\nnet.ipv4.ip_local_port_range <span class=\"token operator\">=</span> <span class=\"token number\">10000</span> <span class=\"token number\">65535</span>\n\n<span class=\"token comment\"># 이유: 많은 외부 연결 시 (DB, Redis, 외부 API) 로컬 포트 고갈 방지</span></code></pre></div>\n<h2>응답 압축</h2>\n<p>Tomcat에서 <code class=\"language-text\">compression</code> 설정은 <strong>응답</strong>을 압축합니다. 요청이 아닙니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. 브라우저 → 서버\n   GET /api/users\n   Accept-Encoding: gzip, deflate, br   ← \"나 이런 압축 풀 수 있어\"\n\n2. 서버 → 브라우저\n   HTTP/1.1 200 OK\n   Content-Encoding: gzip               ← \"gzip으로 압축했어\"\n   [압축된 데이터]\n\n3. 브라우저\n   Content-Encoding 헤더 보고 자동으로 gzip 해제\n   → JavaScript에는 이미 압축 풀린 JSON이 전달됨</code></pre></div>\n<p>브라우저가 알아서 압축을 해제하므로 개발자가 별도로 압축 해제 코드를 작성할 필요 없습니다. <code class=\"language-text\">fetch()</code>나 <code class=\"language-text\">axios</code>로 받으면 이미 풀려있습니다.</p>\n<p><strong>브라우저 지원 압축</strong>:</p>\n<ul>\n<li><strong>gzip</strong>: 가장 보편적</li>\n<li><strong>deflate</strong>: 거의 안 씀</li>\n<li><strong>br</strong> (Brotli): gzip보다 20-30% 더 작음, 최신 브라우저 지원</li>\n</ul>\n<p><strong>설정</strong>:</p>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Connector</span> <span class=\"token attr-name\">port</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>8080<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">compression</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>on<span class=\"token punctuation\">\"</span></span>           <span class=\"token attr-name\">&lt;!--</span> <span class=\"token attr-name\"><span class=\"token namespace\">기본값:</span></span> <span class=\"token attr-name\">off</span> <span class=\"token attr-name\">(CPU</span> <span class=\"token attr-name\">사용하므로</span> <span class=\"token attr-name\">명시적으로</span> <span class=\"token attr-name\">켜야</span> <span class=\"token attr-name\">함)</span> <span class=\"token attr-name\">--</span><span class=\"token punctuation\">></span></span>\n           compressionMinSize=\"2048\"  <span class=\"token comment\">&lt;!-- 2KB 이상만 압축 (작은 응답은 압축 오버헤드가 더 큼) --></span>\n           compressibleMimeType=\"text/html,text/xml,application/json\" /></code></pre></div>\n<h2>고트래픽 Connector 설정</h2>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"language-xml\"><code class=\"language-xml\"><span class=\"token comment\">&lt;!-- server.xml --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Connector</span> <span class=\"token attr-name\">port</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>8080<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">protocol</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>HTTP/1.1<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">maxThreads</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>1000<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">minSpareThreads</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>100<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">maxConnections</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>50000<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">acceptCount</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>2000<span class=\"token punctuation\">\"</span></span>\n\n           <span class=\"token attr-name\">connectionTimeout</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>5000<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">keepAliveTimeout</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>30000<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">maxKeepAliveRequests</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>1000<span class=\"token punctuation\">\"</span></span>\n\n           <span class=\"token attr-name\">compression</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>on<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">compressionMinSize</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>2048<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">compressibleMimeType</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>text/html,text/xml,application/json<span class=\"token punctuation\">\"</span></span>\n\n           <span class=\"token attr-name\">processorCache</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>1000<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">socket.directBuffer</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>true<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">socket.appReadBufSize</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>16384<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\">socket.appWriteBufSize</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>16384<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span></code></pre></div>","wordCount":{"words":354},"frontmatter":{"title":"Tomcat 성능 튜닝","date":"December 14, 2025","description":"Thread Pool과 OS 레벨에서 Tomcat 성능을 최적화하는 방법을 상세히 알아봅니다."}},"previous":{"fields":{"slug":"/tomcat-request-flow/"},"frontmatter":{"title":"Tomcat 요청 처리 흐름과 Thread 모델"}},"next":{"fields":{"slug":"/opensource/"},"frontmatter":{"title":"2025년 회고"}}},"pageContext":{"id":"ae0daa87-98e0-5dd4-b5c1-bd4dc589775c","previousPostId":"47a23bca-623c-5770-90cf-f7843bed9763","nextPostId":"fef1be99-601a-5c64-b4d9-9cb137148904"}},"staticQueryHashes":["3257411868","3517523002"],"slicesMap":{}}