{"componentChunkName":"component---src-templates-blog-post-js","path":"/non-blocking/","result":{"data":{"site":{"siteMetadata":{"title":"GoToBill"}},"markdownRemark":{"id":"05152dfc-1fc7-52d3-bbc8-33b7c98519ad","excerpt":"이 글은 주니어 백엔드 개발자가 반드시 알아야 할 핵심 지식을 기반으로 작성되었습니다. I/O 병목, 어떻게 해결할까? 서버는 네트워크 기반으로 동작합니다. DB, 외부 API, 레디스 등 대부분의 통신이 네트워크를 통해 이뤄집니다.  네트워크 I/O…","html":"<blockquote>\n<p><strong>이 글은 주니어 백엔드 개발자가 반드시 알아야 할 핵심 지식을 기반으로 작성되었습니다.</strong></p>\n</blockquote>\n<h2>I/O 병목, 어떻게 해결할까?</h2>\n<p>서버는 <strong>네트워크 기반</strong>으로 동작합니다. DB, 외부 API, 레디스 등 대부분의 통신이 네트워크를 통해 이뤄집니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 411px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/555f83330e8aeb3301ec6d97a00198b6/2a432/1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.34177215189873%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAyElEQVR42oWR2QqEMAxF+//f6IsgIlrRLu5LhpMh89gJhKZp7jFc3XVdEkKUvu9lGLzM8yzrusp93xJj1DqlpPWyLL83m0sp6/u+75ruPE/puk6qqpK6rhWMENE4jpJzFu+99hFy37ZN7wCZIYGhc8/zCFAAJDU9gvM4DhUCoaaH+H1fPZknreekEAwQJrIeYuBsZMlHsa8ItO1DCOqhbc/Ztq2CsQnLgGFHEfj9YUGaplERtW1qAKxgO/P9L5DNMH2aJgXSK8UH9/Ih5gePnMAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"서버는 다양한 구성요소와 네트워크로 데이터를 주고받습니다\"\n        title=\"\"\n        src=\"/static/555f83330e8aeb3301ec6d97a00198b6/2a432/1.png\"\n        srcset=\"/static/555f83330e8aeb3301ec6d97a00198b6/c26ae/1.png 158w,\n/static/555f83330e8aeb3301ec6d97a00198b6/6bdcf/1.png 315w,\n/static/555f83330e8aeb3301ec6d97a00198b6/2a432/1.png 411w\"\n        sizes=\"(max-width: 411px) 100vw, 411px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>네트워크 I/O 과정에서 스레드는 데이터 전송이 완료될 때까지 <strong>대기</strong>합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">outputStream<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 출력 스트림으로 데이터 보내기</span>\ninputStream<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 완료될 때까지 대기</span></code></pre></div>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 249px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/90cbe4b350e82531d400f0629f9246b1/6a5fb/2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 134.81012658227846%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAAACXBIWXMAAAsTAAALEwEAmpwYAAACLklEQVR42qVV2Y7CMAzs//8VL4hDQghxtaV3S0/uo9xexmxWLQuFQiQraUIm9nhsJHowLpcLbTYbiqKI0jSlMkO6B8IAmKIo1Gw2KQiC3FkpwOzF9XrNwGWHlAWCnc9n/ka4sDLeFXro+z65rvtv/9UDDLharWg0GtF8PqfhcMiGkLG/3W7Lc4hLYRgyiKZpNB6PaTqdUpzEvLfb7Rh8v98zrzgT1LwdsqXZZCo2g/f7fer1epQkCT+I9eFweC8pl/MNMHRi8vXw6n2aOy+dFPq9E9ghjTWfQwQQwkWYx+ORvYOJNc4w43eFgIERUhzHJMsyixxZV1WVDd/tdpsTCAoqlQrn4imHWQ9Pp1POQ3wLD4UhcYUehk5EwRMOX+oQL0AemOER1qZqkdbTuZYHgwGHNZlMOEzYvWzEI5Ios1qtxtVRr9ep1WrRbDajZJKw2JfLJXOJzrNYLHj9zEspJ5mrgR8Mz/LI1V1+rNvtUqfTYSDDMDgpbwv7j0M7Il8LmAIhDTwmknLPaS7kIh2m6fa7fvgHaEGH0U2HikyNRoNs2+bSQ8jgGTRAh5ZlceLAb7GHesA/gqGOkX0kSDQI7IuOhDXoeM6hG7OHWR1+1WBN9Rpe32DtOY7D2YWE0DcRciEgQOAuZpFRcJfECYem6zqZpsmhom96nlcMCBFD/dBctVplwgVfH3VsUfSYUQ2YUTVorkLojzT3FoeiAsATpJLd+ygp4jK4g4dl/0Z/ABM2M9t2Z0MqAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"입출력(I/O)을 진행하는 동안 스레드는 대기합니다\"\n        title=\"\"\n        src=\"/static/90cbe4b350e82531d400f0629f9246b1/6a5fb/2.png\"\n        srcset=\"/static/90cbe4b350e82531d400f0629f9246b1/c26ae/2.png 158w,\n/static/90cbe4b350e82531d400f0629f9246b1/6a5fb/2.png 249w\"\n        sizes=\"(max-width: 249px) 100vw, 249px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<blockquote>\n<p><strong>I/O 대기 시간이 전체 실행 시간의 대부분을 차지합니다.</strong></p>\n<p><br>\n실측 결과 전체 실행 시간 800ms 중 CPU 사용 시간은 4ms에 불과했습니다. 99.5%가 I/O 대기 시간이었습니다.</p>\n</blockquote>\n<h3>블로킹 I/O의 문제점</h3>\n<blockquote>\n<p><strong>블로킹 I/O는 I/O 완료 시까지 스레드를 대기시킵니다.</strong></p>\n<p><br>\nI/O 대기 중인 스레드는 CPU를 전혀 사용하지 않습니다. CPU 효율을 높이려면 더 많은 스레드가 필요합니다.</p>\n</blockquote>\n<p><strong>요청 당 스레드(thread per request)</strong> 방식으로 스레드를 늘리면 2가지 문제가 발생합니다.</p>\n<p><strong>1. 메모리 병목</strong></p>\n<p>스레드 1개당 수백 KB~수 MB의 메모리를 사용합니다. 1만 개 스레드면 약 10GB의 메모리가 필요합니다.</p>\n<p><strong>2. 컨텍스트 스위칭 오버헤드</strong></p>\n<blockquote>\n<p><strong>컨텍스트 스위칭(Context Switching)</strong></p>\n<p><br>\nOS가 스레드를 전환할 때 현재 스레드 상태를 저장하고 다음 스레드 상태를 복원하는 과정입니다.</p>\n<p><br>\n마이크로초 단위로 실행되지만, 스레드가 많아지면 CPU 효율에 영향을 줍니다.</p>\n</blockquote>\n<h3>성능 개선의 2가지 방법</h3>\n<p>자원 효율을 높여 성능을 개선하는 방법은 2가지입니다.</p>\n<ol>\n<li><strong>가상 스레드</strong>(경량 스레드) 사용</li>\n<li><strong>논블로킹 I/O</strong> 사용</li>\n</ol>\n<blockquote>\n<p><strong>성능 개선은 필요할 때만</strong></p>\n<p><br>\n트래픽이 적다면 성능 개선이 불필요합니다. 실제 문제가 발생하거나 예상 트래픽이 높을 때만 적용하세요.</p>\n</blockquote>\n<h2>가상 스레드로 자원 효율 높이기</h2>\n<blockquote>\n<p><strong>가상 스레드는 I/O 대기 시 다른 작업을 수행합니다.</strong></p>\n<p><br>\n블로킹 I/O 코드 그대로 사용하면서 CPU 효율을 높일 수 있습니다. 자바의 가상 스레드나 Go의 고루틴이 이에 해당합니다.</p>\n</blockquote>\n<h3>가상 스레드의 구조</h3>\n<p><strong>경량 스레드</strong>는 OS가 아닌 언어 런타임(JVM)이 관리하는 스레드입니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 453px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/277af4289611a5163dd64fbe825c96c0/2108e/3.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 74.0506329113924%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAACQ0lEQVR42oVUiW7aQBDl/7+rUqWqCUloChiMjQ92ba9PfGEMrzNjEZG0SVca7TH27DvGnuGT0XUdmqZB27ZvwWd5niNJElnf5+q6lrPZZwW52L9G3/c4Ho9/nV8uFyksBa/X67vgwUkuylGWJbIsk5lRDMOAy3jBOI4U08xnXyK8FeSRmAT2zoaOtOzLqoS38bF5sbGcr7Bd7GBUitNwwqxre8RhAuVrKE8jizOcz2ehlWc5ojBG4IbQQUQRI41zKKVkr/YKgRPg4B5QZCVOJyp4LGq4Sw+ruYXlwxqhrSbxixxaaUKxxc9vj/j9sIL1tKU8vVwUSEIjKL2Nh73lCxBByPz7rsdwGtDTDXzLjTI7xyZMGp0pN+nUda2wctd77FaOFExvBbumQ+wbKFfj4CikOhOBq6pCalJoL4Zr7RHsDlCOJq0ypGkKo1NEQUIRI/JjlEK5x6wua+xeXayeLKJNlOlFRlWUBSIdw37dYf79mSgvJR8QZR1F8O0Q9i9HJOE5UWZCyP3DiEaa2Qxe37vMe26l8TIKdZakJcq5KaSIIUbxwaAqKpKMEVYNPCsQJJuFTU5Hby6bxMj5y48F5bZTfh8hCALSz8PmeYvl40oMjakb+PJZSxqyBkw1JBqszb2GoXOAQ+L7diDPJIyGcmVeibN5koshx/IoUn3Z2BwfB9Nnl7m9uI2W1E7r+UZcH1jD6Sm8++xu3zLT5lunmFqK103bCCJGWJhSUNbVfxDefgJM72PwZewom8DB7cL9yf38B+dmeDTs7DMvAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"가상 스레드 구조\"\n        title=\"\"\n        src=\"/static/277af4289611a5163dd64fbe825c96c0/2108e/3.png\"\n        srcset=\"/static/277af4289611a5163dd64fbe825c96c0/c26ae/3.png 158w,\n/static/277af4289611a5163dd64fbe825c96c0/6bdcf/3.png 315w,\n/static/277af4289611a5163dd64fbe825c96c0/2108e/3.png 453w\"\n        sizes=\"(max-width: 453px) 100vw, 453px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>JVM은 CPU 코어 개수만큼 플랫폼 스레드를 생성하고, 플랫폼 스레드가 여러 가상 스레드를 번갈아 실행합니다.</p>\n<h3>메모리 효율 비교</h3>\n<p><strong>플랫폼 스레드 1만 개</strong>: 약 9.8GB</p>\n<ul>\n<li>스레드당 1MB 스택 메모리 사용</li>\n</ul>\n<p><strong>가상 스레드 1만 개</strong>: 약 28MB</p>\n<ul>\n<li>가상 스레드당 평균 2KB</li>\n<li>플랫폼 스레드 8개 추가 (8MB)</li>\n<li><strong>300배 이상 메모리 효율</strong></li>\n</ul>\n<h3>생성 시간 비교 (10만 개 기준)</h3>\n<ul>\n<li>플랫폼 스레드: 21,467ms</li>\n<li>가상 스레드: 196ms</li>\n<li><strong>100배 이상 빠름</strong></li>\n</ul>\n<h3>가상 스레드의 동작 방식</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 527px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/4fa59e41f0c8dba186b1d3095b30127e/44385/4.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 29.11392405063291%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABEklEQVR42lWR2W7EIAxF8/9f2FajNiQMYTEQkknIMqPb2A8d9cFCgDk61zTTNCHnjGVZsK4rtm2D1hohBKlaq1S4E3wX0H51sK1HdBnWWTjnQEQYxxHneaJhEBeDHo+HrMYYeO8FyPu6VTjtYdrhAioETUg+Xz1Oeq21SCm9gfM8i0WMEV3XCYitM2X8fCioy6rkguM4/hIwJFLEVjfs+y7p+L5hKwZyYylFYjA4jwk5jWg/Fe7fBuuy4vl8Sd9gBvhwJaCA/div8/M6r/8NefU6SBzFsXpCMCQP8pihlBIrnhc/LKmA7lHsu1sP3wexbfhTuNiUTBRgf9MgnRBtkjg8cLbiOXGKNzDJXK1yiEMS4C/Xjca1vjTKXQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"가상 스레드 변경\"\n        title=\"\"\n        src=\"/static/4fa59e41f0c8dba186b1d3095b30127e/44385/4.png\"\n        srcset=\"/static/4fa59e41f0c8dba186b1d3095b30127e/c26ae/4.png 158w,\n/static/4fa59e41f0c8dba186b1d3095b30127e/6bdcf/4.png 315w,\n/static/4fa59e41f0c8dba186b1d3095b30127e/44385/4.png 527w\"\n        sizes=\"(max-width: 527px) 100vw, 527px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<blockquote>\n<p><strong>마운트(mount)와 언마운트(unmount)</strong></p>\n<p><br>\n가상 스레드가 플랫폼 스레드(캐리어 스레드)에 연결되면 <strong>마운트</strong>, 해제되면 <strong>언마운트</strong>됩니다.</p>\n<p><br>\nI/O 블로킹 발생 시 언마운트되고, 플랫폼 스레드는 다른 가상 스레드를 실행합니다.</p>\n</blockquote>\n<p><strong>동작 과정</strong></p>\n<ol>\n<li>플랫폼 스레드 1이 가상 스레드 1 실행</li>\n<li>가상 스레드 1이 I/O 대기 시 언마운트</li>\n<li>플랫폼 스레드 1이 가상 스레드 2 실행</li>\n<li>I/O 완료 시 가상 스레드 1 재개</li>\n</ol>\n<blockquote>\n<p><strong>주의: synchronized 사용 시</strong></p>\n<p><br>\nsynchronized로 인한 블로킹은 언마운트되지 않습니다. 플랫폼 스레드도 함께 블로킹됩니다.</p>\n<p><br>\n가상 스레드 사용 시 ReentrantLock 사용을 권장합니다.</p>\n</blockquote>\n<h3>가상 스레드 적용 시점</h3>\n<blockquote>\n<p><strong>I/O 중심 작업에만 효과적입니다.</strong></p>\n<p><br>\n네트워크 I/O, DB 쿼리 등 I/O 대기가 많은 작업에서 효과를 발휘합니다.</p>\n<p><br>\nCPU 중심 작업(이미지 처리, 정렬 등)에서는 효과가 없거나 오히려 성능이 나빠질 수 있습니다.</p>\n</blockquote>\n<p><strong>가상 스레드 효과를 얻기 위한 조건</strong></p>\n<p>가상 스레드 개수 > 플랫폼 스레드 개수</p>\n<p>예: CPU 코어 16개, 동시 요청 10개</p>\n<ul>\n<li>플랫폼 스레드 16개 > 가상 스레드 10개</li>\n<li>효과 없음</li>\n</ul>\n<p>해결: CPU 코어를 4개로 줄이거나 트래픽을 늘려 동시 요청 100개 이상으로 증가</p>\n<blockquote>\n<p><strong>가상 스레드의 장점</strong></p>\n<p><br>\n<strong>기존 코드를 거의 수정하지 않아도 됩니다.</strong> 스프링, JDBC 드라이버 등 주요 라이브러리가 이미 지원합니다.</p>\n<p><br>\n처리량을 높이는 것이지, 개별 요청의 실행 속도를 빠르게 하는 것은 아닙니다.</p>\n</blockquote>\n<h2>논블로킹 I/O로 성능 더 높이기</h2>\n<blockquote>\n<p><strong>경량 스레드도 한계가 있습니다.</strong></p>\n<p><br>\n트래픽이 폭발적으로 증가하면 경량 스레드도 메모리와 스케줄링 오버헤드가 발생합니다.</p>\n<p><br>\n이때는 <strong>논블로킹 I/O</strong>로 구조적 변경이 필요합니다.</p>\n</blockquote>\n<p>Nginx, Netty, Node.js 등이 논블로킹 I/O를 사용합니다.</p>\n<h3>논블로킹 I/O 동작 방식</h3>\n<blockquote>\n<p><strong>데이터를 읽을 때까지 대기하지 않습니다.</strong></p>\n<p><br>\n<code class=\"language-text\">channel.read()</code>는 읽을 데이터가 없으면 즉시 0을 리턴합니다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> byteReads <span class=\"token operator\">=</span> channel<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 대기하지 않음</span>\n<span class=\"token comment\">// 읽은 데이터가 없어도 다음 코드 즉시 실행</span></code></pre></div>\n<p><strong>핵심: Selector를 이용한 이벤트 루프</strong></p>\n<ol>\n<li>실행 가능한 I/O 연산이 있을 때까지 대기</li>\n<li>실행 가능한 I/O 연산 목록 조회</li>\n<li>각 I/O 연산 처리</li>\n<li>반복</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 570px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/50ce36d9d77970e6b0889a0f8452fc87/432e7/5.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 44.93670886075949%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABLUlEQVR42oWSbY+DIBCE/f//8HJJcxVQQFEQ+2KrnWP2zn60GoLsxmd2Z6lw8LxeL0x5gmkM2raB8xbX6/XoF1RHyW3bkMYEWzuok4FTHnOecb/fsSwLcs5IKWGaJok9Ho/PwDhE2LND/a3gdYdYBMZxFIgxBnVdQyklscvlgorU5/OJfeda11V2VsH4vwHl3eR8u92kdedcsaKFtRbzPEu8ItV7L6XHGEWJysMwyLlzPTrdQ58adCYgTxl5zgghCIjApim5rvurkNR9UZ1eMMEK+J3ihL4N4mOwQzknESeQIC5C38AjD9k622aznPi2rUV0ebdMCGFsnTBp+dNQxj7C/Xicv2q4s0fog9hBAGFaa6mSQ6JI9ekeypSVRVOXe6idmL9bw2tDEPfdsl+tfreajhNq5wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"자바 논블로킹 IO\"\n        title=\"\"\n        src=\"/static/50ce36d9d77970e6b0889a0f8452fc87/432e7/5.png\"\n        srcset=\"/static/50ce36d9d77970e6b0889a0f8452fc87/c26ae/5.png 158w,\n/static/50ce36d9d77970e6b0889a0f8452fc87/6bdcf/5.png 315w,\n/static/50ce36d9d77970e6b0889a0f8452fc87/432e7/5.png 570w\"\n        sizes=\"(max-width: 570px) 100vw, 570px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<blockquote>\n<p><strong>I/O 멀티플렉싱(Multiplexing)</strong></p>\n<p><br>\n단일 이벤트 루프에서 여러 I/O 작업을 처리하는 방식입니다.</p>\n<p><br>\nOS별로 epoll(리눅스), IOCP(윈도우) 등을 사용합니다.</p>\n</blockquote>\n<p><strong>논블로킹 I/O의 장점</strong></p>\n<ul>\n<li>블로킹 I/O: 클라이언트 1,000개 = 스레드 1,000개</li>\n<li>논블로킹 I/O: 클라이언트 수와 무관하게 소수의 스레드 사용 (보통 CPU 코어 수만큼)</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 509px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1ab3afd07db9070bf67be3ba56e319b9/71554/6.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 59.49367088607595%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABKElEQVR42o2S6YqFMAyF+/7P6A/B5bp73XczfIGIM8igENOTpKdJT528/I7jkK7rpKoq6fte8dPn3hLu+66EcRyrB78mXNdV5nlWvyzLr3VRFBfGY9u2XTHHSQTMGGWaJsnzXNI0VQI6SpJEMeOWZamY8b/fr2RZJp/PR8ZxFMePgjAMZRgGNTZByCY8hGwAk+cQRoewrmuNg2nE0VXbtmq0jHEIxogUsbaRwMQx4oatxvGLokh831fSpmkuBc/zVDOVjRx/V/le52Cnbca2cZ8UJMaInudp7etnY2ra+HfMNJDdVbccnkOdtWwnkqRLukZBrsAwa7sWcqzJIRp5Vflvh4jE6DwR7hbPBl4BmE0oD0ZtroF4EATPhHy0b51Bhv9vjVHPs/kBJ42krUa0qiQAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"논블로킹 IO에서 동시성을 높이기 위해 N개의 스레드를 씀\"\n        title=\"\"\n        src=\"/static/1ab3afd07db9070bf67be3ba56e319b9/71554/6.png\"\n        srcset=\"/static/1ab3afd07db9070bf67be3ba56e319b9/c26ae/6.png 158w,\n/static/1ab3afd07db9070bf67be3ba56e319b9/6bdcf/6.png 315w,\n/static/1ab3afd07db9070bf67be3ba56e319b9/71554/6.png 509w\"\n        sizes=\"(max-width: 509px) 100vw, 509px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>리액터 패턴</h3>\n<blockquote>\n<p><strong>리액터(Reactor) 패턴</strong></p>\n<p><br>\n이벤트 루프가 이벤트를 대기하고 핸들러에 전달하는 패턴입니다.</p>\n<p><br>\nNetty, Nginx, Node.js가 리액터 패턴을 사용합니다.</p>\n</blockquote>\n<p><strong>구조</strong></p>\n<ol>\n<li>이벤트 발생 대기</li>\n<li>이벤트를 처리할 핸들러 조회</li>\n<li>핸들러가 이벤트 처리</li>\n<li>반복</li>\n</ol>\n<p><strong>멀티코어 활용</strong></p>\n<ul>\n<li>Netty: 여러 개의 이벤트 루프 생성</li>\n<li>Node.js: 별도 스레드 풀로 CPU 중심 작업 처리</li>\n</ul>\n<h3>프레임워크 사용 권장</h3>\n<blockquote>\n<p><strong>저수준 논블로킹 I/O API는 복잡합니다.</strong></p>\n<p><br>\nNetty, Reactor Netty 등 프레임워크를 사용하면 더 간단하게 구현할 수 있습니다.</p>\n</blockquote>\n<h3>성능 개선 효과</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 432px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e1cd7755fb475baa51b36a49bc45521e/0e0c3/7.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.9620253164557%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABUUlEQVR42q2TTUvDQBCGgwfxDwge/EHeFfEq4q3nYvHU0n/hVS+iCIL0oHgUET2ooIdCSBpCvtoUyVez2eR1s93EJlTbgwNhyezOszvzzkj4xbIs46tlWdB1HbIsI47jcq/YR7EKk6Io4kFhGFYOL/poQpDEE2RpWvFzoGEY8H1/KSA7AUJTPH30cf/8Bn045nGpAEtBEHBgvi6yVKSnOmOs77chbTfRPr/lvoQBy5RN0yyBf6YpglTHxcZBBys7TXQEkCT0J2VN0+B53v8Ac+XyFy5Tw6WAhJA5KVfbpw4csBpuHnaxunuE7sXdFEhngHVRYnZbXxlA1Y1SiFlRFNvF2l4L0lYDx2e9qShUiMJ/kgR5LUsVWcDlwyuuH98x/PLLtkjFC0degNZpD42TK9y8fHIfpaJt6pNRXKAqCmzW8HOniIFHtgXXsUAmUWVSvgHhrTxqEjMA0AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"논블로킹 IO 성능\"\n        title=\"\"\n        src=\"/static/e1cd7755fb475baa51b36a49bc45521e/0e0c3/7.png\"\n        srcset=\"/static/e1cd7755fb475baa51b36a49bc45521e/c26ae/7.png 158w,\n/static/e1cd7755fb475baa51b36a49bc45521e/6bdcf/7.png 315w,\n/static/e1cd7755fb475baa51b36a49bc45521e/0e0c3/7.png 432w\"\n        sizes=\"(max-width: 432px) 100vw, 432px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>실측 결과 (힙 메모리 1.5G 조건)</strong></p>\n<ul>\n<li>블로킹 I/O: 최대 동접 6천</li>\n<li>논블로킹 I/O: 최대 동접 12만</li>\n<li><strong>20배 성능 향상</strong></li>\n</ul>\n<h2>비교표: 블로킹 vs 논블로킹 vs 가상 스레드</h2>\n<table>\n<thead>\n<tr>\n<th>항목</th>\n<th>블로킹 I/O</th>\n<th>가상 스레드</th>\n<th>논블로킹 I/O</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>스레드 사용</strong></td>\n<td>요청당 1개</td>\n<td>요청당 1개 (경량)</td>\n<td>CPU 코어 수만큼</td>\n</tr>\n<tr>\n<td><strong>메모리 (1만 요청)</strong></td>\n<td>~10GB</td>\n<td>~28MB</td>\n<td>~수십MB</td>\n</tr>\n<tr>\n<td><strong>구현 복잡도</strong></td>\n<td>낮음</td>\n<td>낮음</td>\n<td>높음</td>\n</tr>\n<tr>\n<td><strong>코드 수정</strong></td>\n<td>-</td>\n<td>최소</td>\n<td>대폭</td>\n</tr>\n<tr>\n<td><strong>최대 동시 처리</strong></td>\n<td>수천</td>\n<td>수십만~백만</td>\n<td>수십만~백만</td>\n</tr>\n<tr>\n<td><strong>적용 난이도</strong></td>\n<td>-</td>\n<td>쉬움</td>\n<td>어려움</td>\n</tr>\n<tr>\n<td><strong>프레임워크 지원</strong></td>\n<td>모든 프레임워크</td>\n<td>주요 프레임워크 지원</td>\n<td>Netty, Reactor 등</td>\n</tr>\n</tbody>\n</table>\n<h2>실전 적용 가이드</h2>\n<h3>1. 성능 문제 확인</h3>\n<blockquote>\n<p><strong>먼저 문제가 있는지 확인하세요.</strong></p>\n<p><br>\n성능 문제가 없다면 굳이 변경할 필요가 없습니다.</p>\n<p><br>\n논블로킹 I/O는 코드 복잡도를 크게 높입니다.</p>\n</blockquote>\n<h3>2. 문제 원인 파악</h3>\n<p><strong>I/O 문제가 아닌 경우</strong></p>\n<ul>\n<li>DB 쿼리 느림: 쿼리 최적화, 캐시 사용</li>\n<li>CPU 중심 작업(이미지 처리 등): 가상 스레드/논블로킹 I/O 효과 없음</li>\n</ul>\n<p><strong>I/O 문제인 경우</strong></p>\n<ul>\n<li>동시 접속자 증가로 메모리 부족: 가상 스레드 적용</li>\n<li>극대 트래픽: 논블로킹 I/O 고려</li>\n</ul>\n<h3>3. 적용 우선순위</h3>\n<p><strong>1순위: 가상 스레드</strong></p>\n<ul>\n<li>기존 코드 거의 수정 불필요</li>\n<li>빠른 적용 가능</li>\n<li>대부분의 경우 충분한 성능</li>\n</ul>\n<p><strong>2순위: 서버 확장</strong></p>\n<ul>\n<li>가상 스레드 적용 불가 시</li>\n<li>구현 변경 여유 없을 시</li>\n<li>비용 증가 감수</li>\n</ul>\n<p><strong>3순위: 논블로킹 I/O</strong></p>\n<ul>\n<li>최고 성능 필요 시</li>\n<li>팀에 기술 역량 있을 시</li>\n<li>장기적 투자 가능 시</li>\n</ul>","wordCount":{"words":882},"frontmatter":{"title":"Blocking & Non-Blocking I/O로 성능 개선하기","date":"September 15, 2025","description":"Blocking & Non-Blocking의 차이를 알고 더 나아가서 성능까지 개선합니다."}},"previous":{"fields":{"slug":"/jvm-jit-compiler/"},"frontmatter":{"title":"JIT 컴파일러 심화"}},"next":{"fields":{"slug":"/java/"},"frontmatter":{"title":"JVM 핵심 정리"}}},"pageContext":{"id":"05152dfc-1fc7-52d3-bbc8-33b7c98519ad","previousPostId":"2082780b-02d4-51da-9cf9-d53183ff2475","nextPostId":"181ca4df-5804-5faf-8f7d-4ce57a2b598f"}},"staticQueryHashes":["3257411868","3517523002"],"slicesMap":{}}