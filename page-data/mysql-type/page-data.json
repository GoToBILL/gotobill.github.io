{"componentChunkName":"component---src-templates-blog-post-js","path":"/mysql-type/","result":{"data":{"site":{"siteMetadata":{"title":"GoToBill"}},"markdownRemark":{"id":"0be373a1-12aa-5f76-bf71-ee3d62c48bc3","excerpt":"이 글은 Real MySQL 8.0 책의 내용을 참고하여 작성되었습니다. type 컬럼이란? type 컬럼은 MySQL…","html":"<blockquote>\n<p>이 글은 Real MySQL 8.0 책의 내용을 참고하여 작성되었습니다.</p>\n</blockquote>\n<h2>type 컬럼이란?</h2>\n<p>type 컬럼은 MySQL이 각 테이블의 레코드를 <strong>어떤 방식으로 읽었는지</strong>를 나타냅니다.</p>\n<p><strong>핵심 개념</strong></p>\n<ul>\n<li>인덱스를 사용했는지, 풀 테이블 스캔을 했는지 확인</li>\n<li>쿼리 튜닝 시 반드시 체크해야 할 핵심 정보</li>\n<li>MySQL 매뉴얼에서는 <strong>조인 타입</strong>이라 부르지만, <strong>테이블 접근 방법</strong>(Access type)으로 이해하는 것이 좋습니다</li>\n</ul>\n<p><strong>공통 규칙</strong></p>\n<ul>\n<li>하나의 SELECT 쿼리는 12가지 중 <strong>단 하나의 접근 방법만</strong> 사용합니다</li>\n<li>index_merge를 제외하면 <strong>하나의 인덱스만</strong> 사용합니다</li>\n<li>MySQL 옵티마이저는 이 접근 방법들과 비용을 계산하여 최소 비용의 방법을 선택합니다</li>\n</ul>\n<hr>\n<h2>type 컬럼의 12가지 값</h2>\n<p>성능이 좋은 순서대로 정리하면 다음과 같습니다.</p>\n<table>\n<thead>\n<tr>\n<th>순위</th>\n<th>type</th>\n<th>설명</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>system</td>\n<td>레코드 1건 이하 (MyISAM, MEMORY)</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>const</td>\n<td>PK/UK로 단일 행 조회</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>eq_ref</td>\n<td>조인에서 PK/UK로 단일 행 조회</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>ref</td>\n<td>인덱스로 동등 조건 검색</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>fulltext</td>\n<td>전문 검색 인덱스 사용</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>ref_or_null</td>\n<td>ref + NULL 비교</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>unique_subquery</td>\n<td>IN 서브쿼리 (중복 없음)</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>index_subquery</td>\n<td>IN 서브쿼리 (중복 제거)</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>range</td>\n<td>인덱스 레인지 스캔</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>index_merge</td>\n<td>2개 이상 인덱스 병합</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>index</td>\n<td>인덱스 풀 스캔</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td>ALL</td>\n<td>풀 테이블 스캔</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>1. system</h2>\n<p>레코드가 1건 이하인 테이블 접근 방법입니다. <strong>InnoDB에서는 나타나지 않고</strong>, MyISAM이나 MEMORY 테이블에서만 사용됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> tb_dual <span class=\"token punctuation\">(</span>fd1 <span class=\"token keyword\">int</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">ENGINE</span><span class=\"token operator\">=</span>MyISAM<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> tb_dual <span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">EXPLAIN</span> <span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> tb_dual<span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>rows</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>tb_dual</td>\n<td>system</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>InnoDB로 변경하면 ALL 또는 index로 표시됩니다. 일반적으로 거의 보이지 않습니다.</p>\n<hr>\n<h2>2. const</h2>\n<p>PK나 Unique Key로 <strong>반드시 1건만 반환</strong>하는 쿼리에 사용됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> employees <span class=\"token keyword\">WHERE</span> emp_no<span class=\"token operator\">=</span><span class=\"token number\">10001</span><span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>key</th>\n<th>key_len</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>employees</td>\n<td>const</td>\n<td>PRIMARY</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>\n<p><strong>const가 되는 조건</strong></p>\n<ul>\n<li>PK/UK의 <strong>모든 컬럼</strong>을 동등 조건으로 사용</li>\n<li>반드시 1건만 반환</li>\n</ul>\n<p><strong>const가 안 되는 경우</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- PK의 일부만 사용</span>\n<span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> dept_emp <span class=\"token keyword\">WHERE</span> dept_no<span class=\"token operator\">=</span><span class=\"token string\">'d005'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>key</th>\n<th>rows</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>dept_emp</td>\n<td>ref</td>\n<td>PRIMARY</td>\n<td>165571</td>\n</tr>\n</tbody>\n</table>\n<p>PK의 일부만 사용하면 ref 타입으로 표시됩니다.</p>\n<p><strong>옵티마이저의 상수화</strong></p>\n<p>const 타입은 쿼리 최적화 단계에서 미리 실행되어 상수로 변환됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 원본 쿼리</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">FROM</span> employees e1\n<span class=\"token keyword\">WHERE</span> first_name<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">SELECT</span> first_name <span class=\"token keyword\">FROM</span> employees e2 <span class=\"token keyword\">WHERE</span> emp_no<span class=\"token operator\">=</span><span class=\"token number\">100001</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- 옵티마이저가 변환한 쿼리</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">FROM</span> employees e1\n<span class=\"token keyword\">WHERE</span> first_name<span class=\"token operator\">=</span><span class=\"token string\">'Jasminko'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">-- 서브쿼리 결과를 상수로 변환</span></code></pre></div>\n<hr>\n<h2>3. eq_ref</h2>\n<p>조인에서 <strong>두 번째 이후 테이블</strong>을 PK/UK로 검색할 때 사용됩니다. 반드시 1건만 반환됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> dept_emp de<span class=\"token punctuation\">,</span> employees e\n<span class=\"token keyword\">WHERE</span> e<span class=\"token punctuation\">.</span>emp_no<span class=\"token operator\">=</span>de<span class=\"token punctuation\">.</span>emp_no <span class=\"token operator\">AND</span> de<span class=\"token punctuation\">.</span>dept_no<span class=\"token operator\">=</span><span class=\"token string\">'d005'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>key</th>\n<th>key_len</th>\n<th>rows</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>de</td>\n<td>ref</td>\n<td>PRIMARY</td>\n<td>16</td>\n<td>165571</td>\n</tr>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>e</td>\n<td>eq_ref</td>\n<td>PRIMARY</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p><strong>eq_ref 조건</strong></p>\n<ul>\n<li>조인에서만 사용</li>\n<li>PK/UK의 모든 컬럼을 조인 조건으로 사용</li>\n<li>Unique 인덱스는 NOT NULL이어야 함</li>\n<li>반드시 1건만 반환</li>\n</ul>\n<hr>\n<h2>4. ref</h2>\n<p>인덱스로 <strong>동등 조건 검색</strong>할 때 사용됩니다. 1건 반환 보장이 없어도 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> dept_emp <span class=\"token keyword\">WHERE</span> dept_no<span class=\"token operator\">=</span><span class=\"token string\">'d005'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>key</th>\n<th>key_len</th>\n<th>ref</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>dept_emp</td>\n<td>ref</td>\n<td>PRIMARY</td>\n<td>16</td>\n<td>const</td>\n</tr>\n</tbody>\n</table>\n<p>ref 컬럼의 const는 비교 값이 상수('d005')임을 의미합니다.</p>\n<hr>\n<h2>5. fulltext</h2>\n<p>전문 검색(Full-text Search) 인덱스를 사용합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> employee_name <span class=\"token punctuation\">(</span>\n    emp_no <span class=\"token keyword\">int</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n    first_name <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">14</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n    last_name <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span>emp_no<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    FULLTEXT <span class=\"token keyword\">KEY</span> fx_name <span class=\"token punctuation\">(</span>first_name<span class=\"token punctuation\">,</span> last_name<span class=\"token punctuation\">)</span> <span class=\"token keyword\">WITH</span> PARSER ngram\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">ENGINE</span><span class=\"token operator\">=</span><span class=\"token keyword\">InnoDB</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> employee_name\n<span class=\"token keyword\">WHERE</span> emp_no <span class=\"token operator\">BETWEEN</span> <span class=\"token number\">10001</span> <span class=\"token operator\">AND</span> <span class=\"token number\">10005</span>\n      <span class=\"token operator\">AND</span> <span class=\"token keyword\">MATCH</span><span class=\"token punctuation\">(</span>first_name<span class=\"token punctuation\">,</span> last_name<span class=\"token punctuation\">)</span> AGAINST<span class=\"token punctuation\">(</span><span class=\"token string\">'Facello'</span> <span class=\"token operator\">IN</span> <span class=\"token keyword\">BOOLEAN</span> <span class=\"token keyword\">MODE</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>key</th>\n<th>Extra</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>employee_name</td>\n<td>fulltext</td>\n<td>fx_name</td>\n<td>Using where; Ft_hints: no_ranking</td>\n</tr>\n</tbody>\n</table>\n<p><strong>특징</strong></p>\n<ul>\n<li>쿼리에 전문 검색 조건이 있으면 높은 우선순위로 선택됩니다</li>\n<li><strong>const, eq_ref, ref가 아닌 경우 일반 인덱스보다 전문 인덱스를 우선 선택합니다</strong></li>\n<li>일반 인덱스의 range가 더 빠른 경우가 많으므로 성능 테스트가 필요합니다</li>\n</ul>\n<hr>\n<h2>6. ref_or_null</h2>\n<p>ref와 동일하지만 <strong>NULL 비교(IS NULL)</strong> 가 추가된 형태입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> titles\n<span class=\"token keyword\">WHERE</span> to_date<span class=\"token operator\">=</span><span class=\"token string\">'1985-03-01'</span> <span class=\"token operator\">OR</span> to_date <span class=\"token operator\">IS</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>key</th>\n<th>key_len</th>\n<th>ref</th>\n<th>rows</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>titles</td>\n<td>ref_or_null</td>\n<td>ix_todate</td>\n<td>4</td>\n<td>const</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>\n<p>자주 사용되지는 않지만, 사용되면 나쁘지 않은 접근 방법입니다.</p>\n<hr>\n<h2>7. unique_subquery</h2>\n<p>IN(subquery)에서 <strong>서브쿼리가 중복 없는 유니크한 값</strong>만 반환할 때 사용됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- semijoin 최적화를 끄고 테스트</span>\n<span class=\"token keyword\">SET</span> optimizer_switch<span class=\"token operator\">=</span><span class=\"token string\">'semijoin=off'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> departments\n<span class=\"token keyword\">WHERE</span> dept_no <span class=\"token operator\">IN</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">SELECT</span> dept_no <span class=\"token keyword\">FROM</span> dept_emp <span class=\"token keyword\">WHERE</span> emp_no<span class=\"token operator\">=</span><span class=\"token number\">10001</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>key</th>\n<th>key_len</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>PRIMARY</td>\n<td>departments</td>\n<td>index</td>\n<td>ux_deptname</td>\n<td>162</td>\n</tr>\n<tr>\n<td>2</td>\n<td>DEPENDENT SUBQUERY</td>\n<td>dept_emp</td>\n<td>unique_subquery</td>\n<td>PRIMARY</td>\n<td>20</td>\n</tr>\n</tbody>\n</table>\n<p>MySQL 8.0에서는 세미 조인 최적화로 인해 더 최적화된 실행 계획이 나올 수 있습니다.</p>\n<hr>\n<h2>8. index_subquery</h2>\n<p>IN(subquery)에서 <strong>서브쿼리가 중복된 값을 반환</strong>할 수 있지만, 인덱스로 중복 제거가 가능할 때 사용됩니다.</p>\n<p><strong>unique_subquery vs index_subquery</strong></p>\n<ul>\n<li><strong>unique_subquery</strong>: 서브쿼리 결과에 중복 없음, 중복 제거 불필요</li>\n<li><strong>index_subquery</strong>: 서브쿼리 결과에 중복 가능, 인덱스로 중복 제거</li>\n</ul>\n<hr>\n<h2>9. range</h2>\n<p>인덱스를 <strong>범위로 검색</strong>하는 인덱스 레인지 스캔입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> employees <span class=\"token keyword\">WHERE</span> emp_no <span class=\"token operator\">BETWEEN</span> <span class=\"token number\">10002</span> <span class=\"token operator\">AND</span> <span class=\"token number\">10004</span><span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>key</th>\n<th>key_len</th>\n<th>rows</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>employees</td>\n<td>range</td>\n<td>PRIMARY</td>\n<td>4</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n<p><strong>range를 사용하는 연산자</strong></p>\n<ul>\n<li><code class=\"language-text\">&lt;</code>, <code class=\"language-text\">></code>, <code class=\"language-text\">&lt;=</code>, <code class=\"language-text\">>=</code></li>\n<li><code class=\"language-text\">BETWEEN</code></li>\n<li><code class=\"language-text\">IN</code></li>\n<li><code class=\"language-text\">IS NULL</code></li>\n<li><code class=\"language-text\">LIKE</code> (와일드카드가 뒤에 있는 경우)</li>\n</ul>\n<p><strong>참고사항</strong></p>\n<p>일반적으로 <strong>const, ref, range</strong>를 통칭하여 \"인덱스 레인지 스캔\"이라 부릅니다. 이 레벨만 돼도 충분히 최적화된 것으로 볼 수 있습니다.</p>\n<hr>\n<h2>10. index_merge</h2>\n<p><strong>2개 이상의 인덱스를 사용</strong>하여 각각 검색한 후 결과를 병합합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> employees\n<span class=\"token keyword\">WHERE</span> emp_no <span class=\"token operator\">BETWEEN</span> <span class=\"token number\">10001</span> <span class=\"token operator\">AND</span> <span class=\"token number\">11000</span>\n      <span class=\"token operator\">OR</span> first_name<span class=\"token operator\">=</span><span class=\"token string\">'Smith'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>type</th>\n<th>key</th>\n<th>key_len</th>\n<th>Extra</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>index_merge</td>\n<td>PRIMARY,ix_firstname</td>\n<td>4,58</td>\n<td>Using union(PRIMARY,ix_firstname); Using where</td>\n</tr>\n</tbody>\n</table>\n<p><strong>특징</strong></p>\n<ul>\n<li>여러 인덱스를 읽으므로 일반적으로 range보다 비효율적입니다</li>\n<li>교집합, 합집합, 중복 제거 등 부가 작업이 필요합니다</li>\n<li>전문 검색 인덱스에는 적용되지 않습니다</li>\n</ul>\n<hr>\n<h2>11. index</h2>\n<p><strong>인덱스 풀 스캔</strong>을 의미합니다. 인덱스를 처음부터 끝까지 읽습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> departments <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> dept_name <span class=\"token keyword\">DESC</span> <span class=\"token keyword\">LIMIT</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>key</th>\n<th>key_len</th>\n<th>rows</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>departments</td>\n<td>index</td>\n<td>ux_deptname</td>\n<td>162</td>\n<td>9</td>\n</tr>\n</tbody>\n</table>\n<p><strong>index가 사용되는 경우</strong></p>\n<ul>\n<li>range/const/ref 방법을 사용할 수 없을 때</li>\n<li><strong>인덱스 컬럼만으로 처리 가능한 쿼리</strong>(커버링 인덱스)</li>\n<li>인덱스로 정렬/그룹핑이 가능한 경우 (별도 정렬 회피)</li>\n</ul>\n<hr>\n<h2>12. ALL</h2>\n<p><strong>풀 테이블 스캔</strong>입니다. 테이블을 처음부터 끝까지 읽습니다.</p>\n<p><strong>특징</strong></p>\n<ul>\n<li>MySQL에서 가장 비효율적인 방법입니다</li>\n<li>InnoDB는 <strong>리드 어헤드</strong>(Read Ahead) 기능으로 대량 I/O를 최적화합니다</li>\n<li>데이터 웨어하우스나 배치 프로그램에서는 의도적으로 사용하기도 합니다</li>\n<li>웹 서비스 같은 OLTP 환경에는 적합하지 않습니다</li>\n</ul>\n<p><strong>MySQL 8.0 병렬 테이블 스캔</strong></p>\n<p>MySQL 8.0에서는 병렬 쿼리 기능으로 여러 스레드가 동시에 테이블을 스캔할 수 있습니다. (초기이기에 조건 없이 전체 테이블 건수를 가져오는 정도만 가능)</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 단일 스레드 (2분 33초)</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token comment\">/*+ SET_VAR(innodb_parallel_read_threads=1) */</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> big_table<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- 4개 스레드 (21초)</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token comment\">/*+ SET_VAR(innodb_parallel_read_threads=4) */</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> big_table<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- 32개 스레드 (5초)</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token comment\">/*+ SET_VAR(innodb_parallel_read_threads=32) */</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> big_table<span class=\"token punctuation\">;</span></code></pre></div>","wordCount":{"words":738},"frontmatter":{"title":"MySQL 실행 계획 - type 컬럼","date":"October 25, 2025","description":"MySQL 실행 계획에서 type 컬럼의 12가지 접근 방법을 성능 순서대로 알아봅니다."}},"previous":{"fields":{"slug":"/mysql-table/"},"frontmatter":{"title":"MySQL 실행 계획 - table, partitions, type 컬럼"}},"next":{"fields":{"slug":"/mysql-key/"},"frontmatter":{"title":"MySQL 실행 계획 - possible_keys, key, key_len, ref, rows, filtered 컬럼"}}},"pageContext":{"id":"0be373a1-12aa-5f76-bf71-ee3d62c48bc3","previousPostId":"94f50ada-9227-5800-ac3d-c97c790b831a","nextPostId":"aa1b5e74-6ee7-5bdd-99ab-4caca4c908d5"}},"staticQueryHashes":["3257411868","3517523002"],"slicesMap":{}}