{"componentChunkName":"component---src-templates-blog-post-js","path":"/cache-part1/","result":{"data":{"site":{"siteMetadata":{"title":"GoToBill"}},"markdownRemark":{"id":"7934a91e-9561-5a22-90e9-8ede258c0daf","excerpt":"이 글은 Facebook의 공식 논문 Scaling Memcache at Facebook을 기반으로 작성되었습니다. Facebook이 직면한 도전과제 Facebook…","html":"<p>이 글은 Facebook의 공식 논문 <a href=\"https://research.facebook.com/publications/scaling-memcache-at-facebook/\">Scaling Memcache at Facebook</a>을 기반으로 작성되었습니다.</p>\n<h2>Facebook이 직면한 도전과제</h2>\n<p>Facebook은 전 세계 수십억 명의 사용자가 실시간으로 소통하는 거대한 소셜 네트워크입니다. 매일 수억 명이 사용하는 이런 규모의 서비스를 운영하려면 전통적인 웹 아키텍처로는 감당할 수 없는 도전과제를 해결해야 했습니다.</p>\n<p><strong>핵심 기술적 도전과제</strong></p>\n<ul>\n<li><strong>실시간 통신 지원</strong>: 사용자들이 즉각적으로 콘텐츠를 주고받을 수 있어야 함</li>\n<li><strong>즉석 콘텐츠 집계</strong>: 뉴스피드, 댓글, 좋아요 등 여러 소스의 데이터를 빠르게 집계해야 함</li>\n<li><strong>수십억 건의 요청 처리</strong>: 초당 수십억 개의 요청을 안정적으로 처리할 수 있어야 함</li>\n<li><strong>지리적 분산</strong>: 여러 지역에 걸쳐 수조 개의 항목을 저장하고, 장애에도 견딜 수 있어야 함</li>\n</ul>\n<p>Facebook은 오픈소스 Memcached를 채택하고, 이를 단일 클러스터에서 다중 지역 분산 시스템까지 점진적으로 확장했습니다. 현재 Facebook의 Memcache 시스템은 세계 최대 규모로, 초당 10억 개 이상의 요청을 처리하고 수조 개의 아이템을 저장합니다.</p>\n<h2>Memcached를 선택한 이유</h2>\n<h3>단순함의 힘</h3>\n<p>Facebook이 Memcached를 선택한 이유는 <strong>단순함</strong>에 있습니다. Memcached는 단 3가지 연산만 제공합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 값 저장</span>\n<span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>         <span class=\"token comment\">// 값 조회</span>\n<span class=\"token function\">delete</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>      <span class=\"token comment\">// 값 삭제</span></code></pre></div>\n<p>이러한 단순함은 대규모 분산 시스템의 기본 구성요소로 매력적이었습니다. 오픈소스 Memcached는 단일 머신의 메모리 내 해시 테이블로 시작했지만, Facebook은 이를 초당 수십억 건을 처리하는 분산 키-값 저장소로 발전시켰습니다.</p>\n<h3>저지연 접근의 가치</h3>\n<p>Memcached가 제공하는 <strong>저지연 접근</strong>, <strong>공유 스토리지 풀</strong>, <strong>저비용</strong>은 데이터 집약적 기능을 실용적으로 구현할 수 있게 했습니다.</p>\n<p>구체적인 예를 들어보겠습니다. 페이지당 수백 개의 DB 쿼리를 실행하는 기능은 너무 느리고 비용이 많이 들어 프로토타입 단계에서 포기하는 경우가 많았습니다. 하지만 Memcached를 사용하면 페이지당 수천 개의 키-값 쌍을 조회하는 것이 실용적으로 가능해졌습니다.</p>\n<h3>읽기 중심 워크로드</h3>\n<p>Facebook의 워크로드는 <strong>읽기 중심</strong>입니다. 사용자들은 콘텐츠를 생성하는 것보다 10배 더 많이 소비합니다. 이러한 10:1 비율의 읽기 중심 패턴은 캐싱 전략이 매우 효과적임을 의미합니다.</p>\n<p>또한 데이터는 MySQL 데이터베이스, HDFS, 다양한 백엔드 서비스 등 이질적인 소스에서 가져와야 하므로 유연한 캐싱 전략이 필요했습니다.</p>\n<h2>Facebook의 Memcache 활용 방식</h2>\n<p>Facebook에서는 <strong>Memcached</strong>를 소스 코드나 바이너리 자체를 의미하는 용어로 사용하고, <strong>Memcache</strong>는 그 위에 구축된 분산 시스템 전체를 의미합니다.</p>\n<h3>Query Cache: DB 부하 감소</h3>\n<p>Memcache의 핵심 목적은 <strong>데이터베이스에 직접 접근하는 빈도를 줄여 DB 부하를 낮추는 것</strong>입니다. Look-aside cache 패턴을 사용하여 클라이언트가 먼저 캐시를 확인하고, 없으면 DB에서 조회 후 캐시에 저장합니다.</p>\n<p>데이터베이스에 값이 변경되면 캐시의 해당 키를 <strong>삭제</strong>해서 다음 요청 시 DB에서 최신 값을 가져오도록 강제합니다. 이 방식은 캐시와 DB 간의 데이터 일관성을 유지하는 데 효과적입니다.</p>\n<h3>Generic Cache: 계산 비용 감소</h3>\n<p><strong>머신러닝 등에서 계산 비용이 큰 결과를 미리 캐시에 저장해둡니다.</strong> 여러 애플리케이션이 필요할 때 빠르게 접근할 수 있어 성능과 자원 효율이 크게 향상됩니다.</p>\n<h3>전체 아키텍처</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6d7e4fd0a7fdf1ce712f76fec71ea76c/72aae/figure2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 79.74683544303798%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAADGklEQVR42mVTaU9iQRB8f9rErJ/9YNQvXuy6KIIoKHLLrVyiHCK4Kh6IUdGIJgIm3qDUTvX6EpOdpDPz3lR3V/dUa91uFy8vL2g2m3h4eECr1cL9/T3a7TZeX1/R6XTA1ev18P7+Lljef8fy/Pb2ho+PD2g6aHt7G4eHh2KFQgFHR0cSjPcM9vn5KWf+29nZwcHBAU5OTlAqlXB1dfV1/waNDFutNhKJBNbX15FMJuXMncGfn5+FIbPT6vW63KVSKWxsbCCdTmNzcxNnZ2dgLI3sPB4PxsbGYDAYMDU1JcbzyMgI9vb2oK/b21vMz89jfHxc7icnJ2WfmJgQu7u7g7a7W8bx8bGAmTUajWJ/f1+Y0ZH/9JXJZIRhrVbD2tqaMGW59B0eHka1WoVGZ9L2+/0wGo2SaXFxUf6R4feA7HMkEsHKyoowozmdTmkVAzKRVixuSzaCaXrDvV4v+vv7hZW+mCQUCqFYLAqWD1Iul4XI4OCg6qMKmM/nkM/nJQhfd2trC5VKRTU6IyAG+R6Q2LIKxD2bzUp7QqEghoaGFMNTaJXKAQKBIH4Z5zBrsWHWvAjDtAkOt1+V8X/J1gUbjLNWmBTOZLbh528zHE4vRkdHcXqqAuayWwivpZHK7yMczyEQ20ThTw1ufwx9fX3CRF/xeBxBdR9LFRFNFhBJ5JErVzEzZ8XAwA80Gg1ojZsbrDg9cHpWsaz2ZZXN7Q3C7fGKzihmTgHlxVbYl51wuHyCczh9cPsU1u2WfvZ6n9AeHx+RoUBVaakvE2ErY384Xnw9Tk6z2VJSSahEqqJUUnwSibj0m1PDpFq5XFIyscHn84sGA4GASMPhcMBms0nJuVwO5+fncrZarUpiq4jFYggGg4goH5diSCldXl5CK5V2RKDp9IYInOLkyFEu+hgyCc/UG5MyATHEUkIcPUqvXr/8J+yZmRkZKYqUzOx2Oyzqe85shsViQTgchsvlwvT0NEwmk1S0tLQkrOi3sLAgMTgxWqfzjouLCxnuRuNGXoo7+8Yx46Po6+npSf6zfB13fX0t/btRj9vtdvAX9PwzXuceGgYAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"전체 아키텍처\"\n        title=\"\"\n        src=\"/static/6d7e4fd0a7fdf1ce712f76fec71ea76c/f058b/figure2.png\"\n        srcset=\"/static/6d7e4fd0a7fdf1ce712f76fec71ea76c/c26ae/figure2.png 158w,\n/static/6d7e4fd0a7fdf1ce712f76fec71ea76c/6bdcf/figure2.png 315w,\n/static/6d7e4fd0a7fdf1ce712f76fec71ea76c/f058b/figure2.png 630w,\n/static/6d7e4fd0a7fdf1ce712f76fec71ea76c/40601/figure2.png 945w,\n/static/6d7e4fd0a7fdf1ce712f76fec71ea76c/72aae/figure2.png 964w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>Look-aside Cache 패턴</h2>\n<p>Facebook의 Memcache는 <strong>Look-aside 캐시 패턴</strong>을 사용합니다. 이는 캐시가 데이터베이스 앞에서 보조 역할을 수행한다는 의미입니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/15111adf40d55dcaf45f720ea673b3b3/2c5fd/figure1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 44.30379746835443%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABO0lEQVR42q1SXW+CQBD0//80E2siJhghQIEK8iW1cCAg05sFDTz0rZdsIHezszNzt8E/r830GaX6vkOapgiCAEWR4/kc3mescXwKWqkKl8uXVF1Xi7PxRTgBu66DZVnYbrcIw1CDRiwHvghvtwL7/R6HwwFlWU6INSHQtg3yPBOAUrVWWOB6jXG/f69UcjVNo930+qu0owS+/yn/K8tUl2UpqupHdkjEYgxLhcMwCI5EFEHLw9DPbhYKScjc4jgSpQSziZO77jHbgiao5YzDSEInZXmTPWYuhLR2Op1wPBpzyMDj0cIwDOx2H0iSRFR4ngvTNBFFkW6e8mQv8ySWg4UwDAOcz2c4jqMtV+9MXdeVyrJMwLZty6X5vj+/AMir8DxPeiliM1lZ3+YrL6WUDGAcf+F4xhh4kez5BXcauC6jTHmrAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Look-aside Cache 패턴\"\n        title=\"\"\n        src=\"/static/15111adf40d55dcaf45f720ea673b3b3/f058b/figure1.png\"\n        srcset=\"/static/15111adf40d55dcaf45f720ea673b3b3/c26ae/figure1.png 158w,\n/static/15111adf40d55dcaf45f720ea673b3b3/6bdcf/figure1.png 315w,\n/static/15111adf40d55dcaf45f720ea673b3b3/f058b/figure1.png 630w,\n/static/15111adf40d55dcaf45f720ea673b3b3/40601/figure1.png 945w,\n/static/15111adf40d55dcaf45f720ea673b3b3/2c5fd/figure1.png 1006w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>읽기 경로 (Cache Miss)</h3>\n<p>캐시 미스가 발생했을 때의 흐름입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// 1. 먼저 캐시에서 조회</span>\nvalue <span class=\"token operator\">=</span> memcache<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 2. 캐시 미스 시 DB에서 조회</span>\n    value <span class=\"token operator\">=</span> database<span class=\"token punctuation\">.</span><span class=\"token function\">select</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 3. 다음을 위해 캐시에 저장</span>\n    memcache<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>쓰기 경로</h3>\n<p>데이터를 수정할 때는 캐시를 업데이트하지 않고 <strong>삭제</strong>합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// 1. DB에 업데이트</span>\ndatabase<span class=\"token punctuation\">.</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 2. 캐시에서 삭제 (업데이트 X)</span>\nmemcache<span class=\"token punctuation\">.</span><span class=\"token function\">delete</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>왜 업데이트가 아닌 삭제인가?</h3>\n<p>삭제를 사용하는 이유는 <strong>멱등성</strong> 때문입니다. 같은 삭제 연산을 여러 번 수행해도 결과는 동일합니다. 반면 업데이트는 순서에 따라 결과가 달라질 수 있습니다.</p>\n<p>또한 캐시는 <strong>Non-authoritative</strong>합니다. 즉, 데이터베이스만이 유일한 진실의 소스(Single Source of Truth)입니다. 캐시는 성능을 위한 보조 수단일 뿐이며, 캐시된 데이터가 제거되어도 문제가 없습니다.</p>\n<h2>전체 시스템 구조</h2>\n<p>Facebook의 Memcache 시스템은 <strong>Region 단위로 분할</strong>되어 있습니다.</p>\n<h3>Region 구조</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/13c2ceb68e03a098532713ae5a7ebd79/fbfd6/cluster.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.9620253164557%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABnElEQVR42nWS6XKkMAyEef8nzG7VHBWG4bLxfQLTkU0212R/fCWrW5KxTTPJhIMM4R4QHt9QATj1Gy7jBhXx5P+kOd0Z/rYD/rz2GKibhx3cbwdxx0L5ZDNmu354LJD3G+Q197hgyhyd63FiF0zrArYLdFHiFsbqnfgVV9mCP2T1b0mAbwrsB0NWaEbdg01nhDBhpeZMlMipaaBBcnkljVVtXTkCxT5J6N1CEXIzNZacZYOGOQkpBayzcN4dOIc5asyaQykF+0XX3tSBdRghVgOxHcPnMnCQC4ZugDUewSV4l2ucokU73DENM2mpEsgzLuBOX692TQM/Kflcjnw3BoO2GI0D85Eu/GAMASwmLDHXnNO6xJn0PnhMKTwxxoDmfO7w8nJB207QOtMRU6Ws9ftaiAAh44dvqvc7zSYVYDWgJR50/GfoRS/nCpT4T80Cej3kRaDJimOnX2TzVExxDwclR1RIhmG8nTF3V2TLq1a8f3WPL72JNmyiEFRo4SUJdJ/JaEStEZSqefGSLfEd0ooXa62pnqe8eEEqvAHTCEzkuTJwkAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"클러스터 구성\"\n        title=\"\"\n        src=\"/static/13c2ceb68e03a098532713ae5a7ebd79/f058b/cluster.png\"\n        srcset=\"/static/13c2ceb68e03a098532713ae5a7ebd79/c26ae/cluster.png 158w,\n/static/13c2ceb68e03a098532713ae5a7ebd79/6bdcf/cluster.png 315w,\n/static/13c2ceb68e03a098532713ae5a7ebd79/f058b/cluster.png 630w,\n/static/13c2ceb68e03a098532713ae5a7ebd79/40601/cluster.png 945w,\n/static/13c2ceb68e03a098532713ae5a7ebd79/78612/cluster.png 1260w,\n/static/13c2ceb68e03a098532713ae5a7ebd79/fbfd6/cluster.png 1357w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>각 Region은 다음으로 구성됩니다:</p>\n<ul>\n<li><strong>여러 Frontend Cluster</strong>: 웹서버(백엔드 WAS) + Memcached 서버로 구성된 클러스터</li>\n<li><strong>하나의 Storage Cluster</strong>: MySQL 데이터베이스 클러스터</li>\n</ul>\n<p><strong>Frontend Cluster</strong>의 \"Frontend\"는 사용자와 직접 통신하는 계층을 의미합니다.</p>\n<p>여기서 <strong>웹서버는 Spring, Django 같은 백엔드 애플리케이션 서버</strong>(WAS)를 말합니다.</p>\n<p>이러한 구조는 지리적으로 분산된 사용자에게 낮은 지연시간을 제공하면서도, 데이터베이스는 한 곳에서 중앙 관리할 수 있게 합니다.</p>\n<h2>클러스터 내 확장: 지연시간과 부하 최적화</h2>\n<p>Facebook은 단일 클러스터 내에서 수천 대의 서버로 확장하면서 <strong>지연시간 감소</strong>와 <strong>부하 감소</strong>라는 두 가지 목표에 집중했습니다.</p>\n<h3>지연시간 감소</h3>\n<h4>All-to-All 통신 패턴의 문제</h4>\n<p>Facebook의 인기 페이지를 로딩하면 평균 <strong>521개의 서로 다른 아이템</strong>을 Memcache에서 가져옵니다. 95 퍼센타일은 무려 1,740개입니다.</p>\n<p>수백 대의 Memcached 서버가 클러스터에 배치되고, 데이터는 <strong>Consistent Hashing</strong>을 통해 분산됩니다. 따라서 웹서버는 하나의 사용자 요청을 처리하기 위해 수많은 Memcached 서버와 통신해야 합니다.</p>\n<p>이러한 <strong>All-to-All 통신 패턴</strong>은 다음 문제를 야기합니다:</p>\n<ul>\n<li><strong>Incast Congestion</strong>: 많은 서버의 응답이 동시에 도착하면 네트워크 정체 발생</li>\n<li><strong>단일 서버 병목</strong>: 하나의 서버가 많은 웹서버의 병목이 될 수 있음</li>\n</ul>\n<h4>병렬 요청과 배치 처리</h4>\n<p>Facebook은 웹 애플리케이션 코드를 구조화하여 네트워크 왕복을 최소화합니다. 데이터 간의 의존성을 나타내는 <strong>DAG</strong>를 구성하고, 이를 통해 동시에 가져올 수 있는 아이템을 최대화합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d697a375ab457a2026f4d67aedad2f5e/c6f66/Dag.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 27.848101265822784%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABFUlEQVR42pVRuU5EMQzMd1MgUdBR8AUUlJQ0VHwADQ01QqBlEfuOvNyHkwxOWBAtkUaexNfYEdMicZhXROfRjEHRGqgV/z05ZxARxOcsYVyA3hQsI1gPKSV8iAOam6RcYIyF8wExEYw2bDP7+M05vO32OD2/xNX1DcRhWrApA50slqDgKY1OlVW21v7Ygnbk3V+YU2FbyrgrpWGtg+hdLStM7PQ5IVHm5MaBFZPJeFcRJhJsKlCxQsfvYv3UUbyOWKajmZglj9nl8xha2zFmH7mvYXUJs3LYQsFeBTx/LJCx4eHxCSdnF7i9u+eiGPnxCGG5QCc+xoHB+a0HGVb1o84zNt5ZoIaVV/TyusPEn5mp8I7pF19ttc6gJ35iZAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"dag 구조도\"\n        title=\"\"\n        src=\"/static/d697a375ab457a2026f4d67aedad2f5e/f058b/Dag.png\"\n        srcset=\"/static/d697a375ab457a2026f4d67aedad2f5e/c26ae/Dag.png 158w,\n/static/d697a375ab457a2026f4d67aedad2f5e/6bdcf/Dag.png 315w,\n/static/d697a375ab457a2026f4d67aedad2f5e/f058b/Dag.png 630w,\n/static/d697a375ab457a2026f4d67aedad2f5e/40601/Dag.png 945w,\n/static/d697a375ab457a2026f4d67aedad2f5e/78612/Dag.png 1260w,\n/static/d697a375ab457a2026f4d67aedad2f5e/c6f66/Dag.png 2722w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>평균적으로 <strong>요청당 24개의 키</strong>로 구성됩니다. 100번의 요청 중 95번은 95개 이하의 키를 사용하며, 나머지 5%의 요청만 그보다 많은 키를 한 번에 조회합니다.</p>\n<h4>UDP와 TCP의 전략적 사용</h4>\n<p><strong>GET 요청: UDP 사용</strong></p>\n<ul>\n<li>지연시간과 오버헤드를 줄이기 위해 UDP 사용</li>\n<li>UDP는 연결이 없으므로 각 스레드가 직접 Memcached 서버와 통신 가능</li>\n<li>연결 유지 오버헤드 제거</li>\n<li>패킷 손실이나 순서 오류는 캐시 미스로 처리</li>\n<li>피크 로드에서 GET 요청의 0.25%만 손실됨</li>\n<li>UDP 사용 시 TCP 대비 <strong>20% 지연시간 감소</strong></li>\n</ul>\n<p><strong>SET/DELETE 요청: TCP 사용</strong></p>\n<ul>\n<li>신뢰성을 위해 TCP 사용</li>\n<li>웹서버와 같은 머신에서 실행되는 <strong>mcrouter</strong>를 통해 처리</li>\n<li>상태 변경 확인이 필요한 작업에 적합</li>\n</ul>\n<p><strong>mcrouter란?</strong></p>\n<p>mcrouter는 memcached 프로토콜을 지원하는 라우팅 프록시입니다:</p>\n<ul>\n<li><strong>라우팅</strong>: 클라이언트 요청을 적절한 Memcached 서버로 전달</li>\n<li><strong>연결 통합</strong>: 웹서버의 수많은 스레드가 각각 TCP 연결을 맺는 대신, mcrouter를 통해 연결을 재사용</li>\n<li><strong>메모리 효율</strong>: TCP 연결마다 소켓 버퍼와 상태 정보가 필요한데, 연결 수를 줄여 메모리 절약</li>\n<li><strong>프로토콜 지원</strong>: UDP(GET)와 TCP(SET/DELETE) 모두 지원 가능</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/72861477c4cd0f20044ac7c41ea3f0d5/9cab2/mc.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 87.34177215189874%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAACz0lEQVR42n1Ta3ebOhD0//9jPc1te/twGztxYtM4Npi3AIGe01lwHrcfrjhzJFbLaHZWrGAmYOhxeToiudthv7lDsr3Ht3++oD6nwKgB52Cjgw4j8q7Cz/0D7p4OuE0ecLP+gUN6xCSPn7BSjUZ9UaiuyNMOZdbN6zpf5klbtMbh0Pb4rQaix6HpsScSibXLnGsS5n1EY4CaQjsHrBONJLfz+iVe64h2iFAUKxi5tz8Z3P0eoblWI78lKnKt6j7AhzeUZYWu6xFinN+NC2iFkJC1kzzutYoVNc28lpigHgJWFQmtv4LBqm6guoEJcY6NdiFsiMkuebLX8tCqaV+/Nf4dYXinsChLdP1/FTZXQuuWHNlr2hY1Fb7k+ReFuaKq/g1PWYuMxtX0TN6LblGoiJIeSZx9xJGNE8h6yV2w4gE8ZYG3HtP9DtPj/jUmkOFj4LXwC6hGGzZOG5iwxEdCfFzh/RBzj0f4LMXfo7Q9Utvg4lrkXuFbucOnyy0yxxjfU86ZVUIoEiKiNYjDgKj1G7zDsk9C16GNbIRTOHcFtiUvdrlHNpRzTIH30KmrQtYd2aU4GQRem1DViM7zD/GvCjs3obAdioneqQKJuiDpcl7yApdRzRXUVpPQUxVLiWSPQ4Fwpn9ZQnKSsgTYllZMs07pqECe/ZhiOzzTQzcXIR7HKE0Zn+GaDcbzZzi142+wZ7kHmOInxvQrfP+IaIqrzijFzPc1NwNSqjXBz0QvY4Uhgc2/Qh8/wBbfEdtb+HqN6XSD8fQRofmFOGZXPnY0evTeYKAFWmZijG7eE6yiLVn1M2z9yPnE6s4I45mV8qDmMK/FDpgavt1hOH2BKzcIFBKGA1y1hZZYc0+bMiq8Ms9GyMwSXt8FYWmMJPvmFubyL2y1RlAkbTew5XqOealEP/11D/9vTAVVbDEcbzBdaE3/QNJ7TPRZP39ihRtac8If924hKh159NUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mcrouter 구조도\"\n        title=\"\"\n        src=\"/static/72861477c4cd0f20044ac7c41ea3f0d5/f058b/mc.png\"\n        srcset=\"/static/72861477c4cd0f20044ac7c41ea3f0d5/c26ae/mc.png 158w,\n/static/72861477c4cd0f20044ac7c41ea3f0d5/6bdcf/mc.png 315w,\n/static/72861477c4cd0f20044ac7c41ea3f0d5/f058b/mc.png 630w,\n/static/72861477c4cd0f20044ac7c41ea3f0d5/9cab2/mc.png 864w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>연결 통합이란?</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/70efa34233a348f2eb9f05a478ae2610/97655/%EC%97%B0%EA%B2%B0%ED%86%B5%ED%95%A9.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 77.84810126582278%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAACh0lEQVR42pVTaW/TQBT0//83ID4hPiCQEIVWLQWJtkmby4nt+j6ytz3MbkJpRYuE5dHeb2fmvY022xTLdYztLkOS5qjqBlPfw1UVXFnC1TXGtsXkHA7fhH99UVm1KMoaddMFDMMeYz8wUAPbEAxoGXC0DuM0gT/GcTpiDJg4OboxzEV+UJKJ0RqGEyIv4LZbDJeX6C8uoOdzmDRDLzW0UlgtV+i6DtI4iKpBe32NxckXKM5roRAZ3myP8H2jNOwwwO73hGD/2FLyX9AGVnBNyENrLCJHVm3XQ3HR2BGyaeGKApI3ysUSZreDqWpIrmseKIoSQkpo7lW8TKQp8sUChmcsyUSO2lt6pDjwmyS9c3nOYAvI2zsYyje0RCgGZNCcBwUZK6pRJLLfxMhvZtBZRksY0FN3NPaPDB3oO7LwCFJ8e1x/stfasN8ZczjHcQiY0nR/qzd6SO9hNxv05+foTr9C0XS9S9DTcJ+U5eOksDraqyssPp9A0R5NL0OWfWX5cgglQdkT5Uy0gnTYt3CeBZl5e/z+0A9jlhLXfY16ln4crdcJ5ncrbOIEMYtcGIWdKJCJKrS17vE/X1QwCTlR0eCaL2RvNFo1oNeC7Z5jGQr2N8MHPLB8OhfNhgTfqltclHOc5df42caQlDFaWkHVk5tYXy6UTKjZkJQxjJ9D1GjWkpJIiwyK7CpKrJnZTNW4qdcBuWrRKIF3ySlezd7j9fIjYllgNBPPmKcBeyvDOyxYXz47jREo+UoSevgjmQXcixqVGPCh/4432094W58hVi8EvFcdOrLcVnyv9Csjm16z7szhsY+UbCjZeMnGBbm+1foFyb1V8BiOrYc9Gvy4mB8S8Tghz+AXfl3U6bFBlqsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"연결 통합\"\n        title=\"\"\n        src=\"/static/70efa34233a348f2eb9f05a478ae2610/f058b/%EC%97%B0%EA%B2%B0%ED%86%B5%ED%95%A9.png\"\n        srcset=\"/static/70efa34233a348f2eb9f05a478ae2610/c26ae/%EC%97%B0%EA%B2%B0%ED%86%B5%ED%95%A9.png 158w,\n/static/70efa34233a348f2eb9f05a478ae2610/6bdcf/%EC%97%B0%EA%B2%B0%ED%86%B5%ED%95%A9.png 315w,\n/static/70efa34233a348f2eb9f05a478ae2610/f058b/%EC%97%B0%EA%B2%B0%ED%86%B5%ED%95%A9.png 630w,\n/static/70efa34233a348f2eb9f05a478ae2610/97655/%EC%97%B0%EA%B2%B0%ED%86%B5%ED%95%A9.png 819w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1f279a1e5c204910114a2391bdca1966/587b0/figure3.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 73.41772151898735%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAACVUlEQVR42o2Ty27TQBSG8z6s6QMUVWzLigWUN2CFkIpYlQjBAhbpFqmLlksLEpUCVGmFUJU0TSUa0iQ0SXOz49iJr3VudlJy+ZmZYDtpQNTSb8945nznnDlnfMAInv71jP6q0Wha9J+PvobDAWo1CZ1OB8a5iWazgUbDZOr1umy927WJ0ZBpQOZUY8i0Uwbs93+B40pQFAUnP3NIp1NIJH7g8DAKSRKZM01TZzKhdl3isHfRY05doLNJN3SmalUAz3MoFPKoVHg2luU62xOLZ+Bf3SLaxNZOFMdnIsKJAlTDZOs+Sr4gHiik1WqylJzzmTyrwWDADN5s72Pu1mPMLS7jxdoOUpyB8AlHgI0xkKYiCBUmenbsnBhkOCUH+OHLARbuPcXCkh+rG7tIchoBlr0IVVWBKFbZZDLCy3KA7z9HMH/Xj/k7Kwish2aBiiKTgpSh67oboZfqbIT/BRqkCLSKNEo35T+afK4MnDRut1vumAIU3SRqwDCbVweOjfus3wzDQGAtiIfP1rES2MRe7BThJIejVJHtmSnK6z2keB2R5ESVncamQFVVcfv+S1y7+QA3lp4gFMsgkhJwlC65wI2P33B98RHRMp6/CuK4IOPr9zzqmuEBaZr02tGUQ/txvPt0gO3dGM54CXzdgCjr7lFkCgLeBsMMHI1nUVXOUZY0dKyuB/QqOoKuyqhwRWjkWyoWkM2col6XxjdJ11As5lETK1DkGspkLFQ4cps45HJZFpDvcr9ZVgemabKIbdtivUm/zt2l8wbpBsuymGzbJnvbTHT9N3KgRShne9aQAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"UDP vs TCP 성능 비교\"\n        title=\"\"\n        src=\"/static/1f279a1e5c204910114a2391bdca1966/f058b/figure3.png\"\n        srcset=\"/static/1f279a1e5c204910114a2391bdca1966/c26ae/figure3.png 158w,\n/static/1f279a1e5c204910114a2391bdca1966/6bdcf/figure3.png 315w,\n/static/1f279a1e5c204910114a2391bdca1966/f058b/figure3.png 630w,\n/static/1f279a1e5c204910114a2391bdca1966/40601/figure3.png 945w,\n/static/1f279a1e5c204910114a2391bdca1966/587b0/figure3.png 970w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>Incast Congestion 해결</h4>\n<p>웹서버는 <strong>슬라이딩 윈도우 메커니즘</strong>을 구현하여 Memcached로 보내는 동시 요청 수를 제한합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/aa71d61e1f649560acc59a6db7202999/d4c13/sliding.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 83.54430379746836%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAACrUlEQVR42p1UW2sTQRTen+I/8cm/oIiCIIo+6pPPgkgVwWItFESfxIciPlhFtFCqFjEVaxs1t8Zcmstmk70ke5mdndndzzPbNI1BrBr4ON9MZs+c851zRlv7JtDpmdjr6Gi2dOiGCcseIkkS/M9Pa1kSUnJEUYiIM8TEpYyQpGl2IFV2ik9DXRrPQOs6EjefC9xflbj3RuD2C4GlNYm23qeIe2hQ1K2OkdnewIZhOjAGTsZHfgAhY0RCTqAVOwKnFgJcfsRw6SHDmcUAVx9zFCs15L/vZiiUa9j+Wka726eLBhhYQ9hDD34QQkw5yxzGMeCFKXyewg0TeGQ9Pk6B/pQUgYzHmElP7akIp6EV/SZc30XIGMKQw6M0AuKMuDowJeHfFeWtmUdft2D0SZORA3PQh21bCOgSKaLxsUOPs4WZheZEHnKjEgIZotBJ8fFHgs1agk/1GO9KEltNic8E22VwveAXvX4H7Zm+gWPvz2LbKeP6cooTcz5OLjCcXmQ4foPhyjLHtZUYuXydClQCp4+4EOCR2LczXNOZjfXBDobcx04jxnpBYKMk8KEioJp+i/a+NFM4oxCeG1CfJhPIMQ7XVJR0SptJAyvN0v1JMbmFHjPQ8gzozESfAlC8TegFJozAJmuh61M7MYcchgwJkrFT0IQcQq1dwbLoR5FPPACLOXza84gr3RVGxA/WGltdRb3ZRqXaQHOvjYFpodXuQO/1s5nmPPq3WZb0QaRGiMQeBRJDP4btS7hMThp31v4JGsttYnjhIkS9hrnXwLklhvMPOO6+Yijv1lCqNpEvVFHcbaBMWRzZNmGxBHd+HlG3iyebCW6thLjzkuNpLswkUI9CtdYi20WjrR/tMCblaZwn85lQddWzlCS0SzY9eBcVp5RjKbMZz+wBn3q+fgLy1gqbZEjXLwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"슬라이딩 윈도우\"\n        title=\"\"\n        src=\"/static/aa71d61e1f649560acc59a6db7202999/f058b/sliding.png\"\n        srcset=\"/static/aa71d61e1f649560acc59a6db7202999/c26ae/sliding.png 158w,\n/static/aa71d61e1f649560acc59a6db7202999/6bdcf/sliding.png 315w,\n/static/aa71d61e1f649560acc59a6db7202999/f058b/sliding.png 630w,\n/static/aa71d61e1f649560acc59a6db7202999/d4c13/sliding.png 825w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>윈도우 크기가 너무 작으면 요청을 순차적으로 보내야 하므로 지연시간이 증가합니다.</p>\n<p><strong>너무 크면 Incast Congestion이 발생합니다.</strong> Facebook은 실험을 통해 최적의 윈도우 크기를 찾았습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7b89a4c0bb5ca3f65ffa495cd077d205/5caea/figure4.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 71.51898734177216%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAABqUlEQVR42qVTa0/DMAzs//9ZwF9gsKndxGAre/T9StKmh+0spRuT9oFIrqzGOd85lwCXNY4jf/HfFTgQB9T3BmmWom0bNE0tkecZ0jRFkpxxPp9wOHzjdDpO+xx1XckZxpkAjTHyMysKYTuOFtYOqOoaYRjh5fkJb28LykNstx+yP4+a6vhc4KSCWCQoy4JAW+i+h29UUfc4jrFYvAo7Y7TUcbNfdaMwZeCAC1hCVZVSqLWCMj0dsFOxb+qZc8zBrgCV6hBFocyhKHIBHAhMa+Ov6wJ6H+gPIEtcrZbCji9A605gOqVnN/84ZgwVdrudzM7dViuAhuaozTXLe2EJRJGaqqrcLfv5sFyOum7QWyszZJbDMNyVyue4odKuZmLoC4ahF9vwTHnxHJXu0VF3jrZTEtyEo6GcVYyWLDdYccPMh5hMyiy9WUuSUZQlcvIm+zPJcmR5LnleuP+8789eGVvmRhI2m7V4jdd6HSKjl8MrSRJ8fW4vdRrL5fusLpKXdPP0nDVYtpuZY+1HEcd7CfbrbR3nHjx4bAngeDwIC35y+/1uAprX+PwHdABFTyx8Kk0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"윈도우 크기에 따른 대기 시간\"\n        title=\"\"\n        src=\"/static/7b89a4c0bb5ca3f65ffa495cd077d205/f058b/figure4.png\"\n        srcset=\"/static/7b89a4c0bb5ca3f65ffa495cd077d205/c26ae/figure4.png 158w,\n/static/7b89a4c0bb5ca3f65ffa495cd077d205/6bdcf/figure4.png 315w,\n/static/7b89a4c0bb5ca3f65ffa495cd077d205/f058b/figure4.png 630w,\n/static/7b89a4c0bb5ca3f65ffa495cd077d205/40601/figure4.png 945w,\n/static/7b89a4c0bb5ca3f65ffa495cd077d205/5caea/figure4.png 996w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>부하 감소: Leases 메커니즘</h3>\n<p>Leases는 Facebook이 개발한 핵심 메커니즘으로, 두 가지 주요 문제를 해결합니다.</p>\n<h4>Stale Sets 문제</h4>\n<p>오래된 데이터가 캐시에 저장되는 문제입니다. 동시 업데이트가 재정렬되면 발생합니다.</p>\n<p><strong>웹서버 A가 DB에서 데이터를 조회하는 동안</strong>, 웹서버 B가 데이터를 업데이트하고 캐시를 삭제합니다. 하지만 웹서버 A는 이미 오래된 값을 가지고 있었고, 나중에 이를 <strong>캐시에 저장하여 최신 데이터를 덮어씁니다.</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e503304c8899f0b72553331bc08d41cb/e5ca1/stale.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 91.13924050632912%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAACdElEQVR42p1UyW7bMBDV/39QLgGKXHzoJUjQxa6LJF5kS5Zk7dyX1yHlJEYABUgJPJEzFB9nZeI94si2Bo8LiaGdFK/6MC2yFRb5Cg4X5WVY67BLM7Td8KZLvMgBU4Gft8iW97DsBOgCXtVvPzEjMVr5gW4axhg4594JHdsSQQ7ZrFGt7+D4jsgOcCJ7N/PD8KQPJP6yH75BDkhAN8MweCtoR5EfIspwGnNDCAUhFbp+xMs2RV5UEEqDc4GEEwcjjNKjZW5aE6SZ5YMkMi4kmq5HWTWo6haMyIIuSWuHgmL6nCvcfj/hUFvkncepc/D4+kgG4RDQjhZZrdExG2Wurun8BZck0V7LgY575I3FeXDoKVIdIZm7KRzXdgJVBxwplJnW55E86D02BZXas8Ryr6NX5eCpbC4EmtI/Mk6zjXKIaThU060/Xwb8eB7iOhwcaM9Rhg2xh9lSdk3Msn+3UGuNgTGqq4kwuFz2Llqz3Iz4RaRhXXQWTJAZZKm/hp2Q/EfcIaibWElxTA3SB4FircAqT81xZWFoo1AO1k4WekP+yYJMr+jwX/DqKa4hT1SqFBoqX0kJlOMETVYbdUWoyOW+76PrkVB18HwPLzMUyzsUv7/RTxkc28Dr7ip1H8pm1i8KjDc8Ao76mOBCB5HlZ93iqM7YjBkeqjX+tPQOkHzSdXgcBAIc5zBk4avslZq9q9EDjqLEdsjw1O7x0h9w5CVK1SIxxyNcVeF8f4/09hb9ahVlWxSzj8OnnWK6DgGaSCSR66aJsh3H2UOO9mzb0itXQOx2kOk+yo7Ofa1sLhbbuoaiy/vHRxQ3N2gWC+jDAaYs8Q89k3tgQMMkbAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Stale Sets 문제\"\n        title=\"\"\n        src=\"/static/e503304c8899f0b72553331bc08d41cb/f058b/stale.png\"\n        srcset=\"/static/e503304c8899f0b72553331bc08d41cb/c26ae/stale.png 158w,\n/static/e503304c8899f0b72553331bc08d41cb/6bdcf/stale.png 315w,\n/static/e503304c8899f0b72553331bc08d41cb/f058b/stale.png 630w,\n/static/e503304c8899f0b72553331bc08d41cb/40601/stale.png 945w,\n/static/e503304c8899f0b72553331bc08d41cb/78612/stale.png 1260w,\n/static/e503304c8899f0b72553331bc08d41cb/e5ca1/stale.png 1332w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>Thundering Herds 문제</h4>\n<p>특정 키에 대한 읽기와 쓰기 활동이 많을 때 발생합니다. 쓰기 활동이 반복적으로 값을 무효화하면 많은 읽기가 비용이 큰 DB 경로로 가게 됩니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/26e8a088cb363593e91ca8c9e7037c3e/10ab7/thunder.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 79.74683544303798%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAADHklEQVR42o2UWY/cRBSF/Td5QhES4q/wgoTgLUhJhIR4AAmekFg6yyQzk/QkTGaBns4009M905u7vbtcqz+uHUUCwUMsHdtVrjr31j33OGqbhrauQZ5NkrKazrm5vEJtd6BqQlnKN03TWkqvqFvDrsm5Wt9ycXPNIttSBU1ua2qvibTSxOstq+WGLMkIzvVwxmK1wQhZcB5lDCsJcruOidMMExw2eBpnUdZQC7S8R8Z6KmUolaVqFMX2N8rkCUrIlHbUWohdwEmQWk6hZK1Skqmsqba/YrRCyzot6611REEieSdHc3L0INDnBAFyxLZ1PbxkElyLNwEjm7yXsZ7g1QjwtHJv5RZCIHo9bfj0+w2f/bDhy58KvnoYuPfYc3fQyHvDFz8rFjGM1RWfH3zHYPCCp8+PGR6PefHqgucvzxj+fs7h0QnL1ZZoMHJ8+MDyyTeWO/c1d+4pPv5a9c+P7is+uKs4ncGqWfHtcMD+4WueHL7i0f4Rj54d8VDQjR8/e8nNYk2UKyeKKa7jhlnq+SvWXMp4VgTmVWC6ldpqOZbU0daetC5Z5jtW2U4UjtkUKWlVUou4xkgNnda4eINfL6HM8HmKrwrcZIz+46yvT5CadUrOiw2rKunVrY20ksxluiKuMxGtE84TWVGv8VLsTUy+95Tm5JQwvUbvH1CfnaOFsFtoBY0ouWkyhsmfnJZXzH3ML/ERP073JCq9YFEntek27BKMEJjRBWY8xr25xJYVWvqxI3QStFM6tjl76QnD8oJjNeG4mbC2Kc6+DRqZoqCazXCpTErDhqp6C3FIyHNCNyeZaQm8iROWux2JLilcJe6oSE1JZZo+u57QCWE5GlEI7GpFK+NWiHp070lCkIa2kmFZK5Q4Jy9ExGXFdFGR5apvaP2O0Hf2kuw6ePH0fyDZemuluVvZ6MUEnlx5Dt44DgVJ5XsXdQr3ovCeV6do2pT9DyAVu12niqlgJ3YtrSI3tfja/IOw887/XO9mE11wHl9yVdxyo9bELkGKRRpKEsHWF2Tyx3nvDEvbMEnnjLdTFnVM4sp/YWsLCqv4GwEZvE7vaTPXAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Thundering Herds 문제\"\n        title=\"\"\n        src=\"/static/26e8a088cb363593e91ca8c9e7037c3e/f058b/thunder.png\"\n        srcset=\"/static/26e8a088cb363593e91ca8c9e7037c3e/c26ae/thunder.png 158w,\n/static/26e8a088cb363593e91ca8c9e7037c3e/6bdcf/thunder.png 315w,\n/static/26e8a088cb363593e91ca8c9e7037c3e/f058b/thunder.png 630w,\n/static/26e8a088cb363593e91ca8c9e7037c3e/40601/thunder.png 945w,\n/static/26e8a088cb363593e91ca8c9e7037c3e/78612/thunder.png 1260w,\n/static/26e8a088cb363593e91ca8c9e7037c3e/10ab7/thunder.png 1552w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>Leases 동작 방식</h4>\n<p>Memcached 인스턴스는 캐시 미스를 경험한 클라이언트에게 <strong>Lease</strong>를 제공합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// 1. 캐시 조회 (미스 시 lease 토큰 받거나 대기 알림 받음)</span>\n<span class=\"token class-name\">LeaseToken</span> lease <span class=\"token operator\">=</span> memcache<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>lease<span class=\"token punctuation\">.</span><span class=\"token function\">isMiss</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>lease<span class=\"token punctuation\">.</span><span class=\"token function\">hasToken</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 2-1. Token을 받은 경우 (첫 번째 요청만): DB 조회</span>\n        value <span class=\"token operator\">=</span> database<span class=\"token punctuation\">.</span><span class=\"token function\">select</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// 3. lease 토큰과 함께 캐시에 저장</span>\n        memcache<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> lease<span class=\"token punctuation\">.</span><span class=\"token function\">getToken</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 2-2. Token 없는 경우 (나머지 요청들): 잠시 대기 후 재시도</span>\n        <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 수 밀리초 대기</span>\n        <span class=\"token keyword\">return</span> memcache<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 캐시에서 재조회 (이미 저장됨)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>Lease의 효과</strong></p>\n<ul>\n<li>Memcached는 토큰을 검증하여 데이터 저장 여부를 결정</li>\n<li>해당 키에 대한 delete 요청을 받으면 토큰 무효화</li>\n<li><strong>10초당 키당 한 번만</strong> 토큰 발행 (Thundering Herds 방지)</li>\n<li>토큰이 최근에 발행된 경우, 클라이언트에게 잠시 대기하라고 알림</li>\n</ul>\n<p><strong>실제 효과</strong></p>\n<p>Thundering Herds가 발생하기 쉬운 키들을 1주일간 분석한 결과:</p>\n<ul>\n<li>Leases 없이: 피크 DB 쿼리율 <strong>17K/s</strong></li>\n<li>Leases 사용: 피크 DB 쿼리율 <strong>1.3K/s</strong></li>\n</ul>\n<p>이는 DB 프로비저닝 비용을 크게 절감합니다.</p>\n<h4>Stale Values 허용</h4>\n<p>일부 사용 사례에서는 약간 오래된 데이터를 반환하는 것이 허용됩니다.</p>\n<p><strong>동작 방식:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. delete(key) 실행\n   ↓\n2. 캐시에서 즉시 삭제하지 않고 \"최근 삭제된 아이템\" 임시 저장소로 이동\n   ↓\n3. GET 요청 시 선택:\n   - Option A: lease token 발급 (DB에서 최신 값 가져오기)\n   - Option B: stale로 마크된 오래된 값 즉시 반환\n   ↓\n4. 짧은 시간 후 임시 저장소에서 완전히 삭제 (flush)</code></pre></div>\n<p><strong>장점:</strong></p>\n<ul>\n<li>애플리케이션이 stale 데이터로도 작동 가능하면 DB 조회 대기 불필요</li>\n<li><strong>예: 좋아요 수가 1초 전 데이터여도 사용자 경험에 큰 영향 없음</strong></li>\n</ul>\n<h3>Memcache Pools</h3>\n<p>범용 캐싱 레이어로 Memcache를 사용하면 서로 다른 특성을 가진 데이터들이 같은 캐시 서버를 공유하게 됩니다.</p>\n<p><strong>문제 상황:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">같은 Memcached 서버에:\n- Low-churn 데이터: 변화 적고 계속 가치 있음 (사용자 프로필)\n- High-churn 데이터: 빠르게 변하고 더 이상 접근 안 됨 (오래된 실시간 피드)\n\n메모리가 부족하면?\n→ LRU로 오래된 것 삭제\n→ 가치 있는 Low-churn 데이터가 삭제됨\n→ 더 이상 접근 안 하는 High-churn 데이터가 메모리 차지\n→ 히트율 감소 (부정적인 간섭)</code></pre></div>\n<p>이런 <strong>부정적인 간섭</strong>을 방지하기 위해 churn 특성별로 캐시 서버를 분리합니다.</p>\n<h4>Pool 분리 전략</h4>\n<p>클러스터의 Memcached 서버를 별도의 <strong>Pool</strong>로 분할합니다:</p>\n<ul>\n<li><strong>Wildcard Pool</strong>: 기본 풀 (대부분의 데이터)</li>\n<li><strong>특수 목적 Pool</strong>: 문제가 되는 키들을 위한 별도 풀</li>\n</ul>\n<p><strong>Pool 분리 예시</strong></p>\n<p><strong>작은 풀:</strong></p>\n<ul>\n<li>데이터: 온라인 상태 표시 (자주 액세스)</li>\n<li>캐시 미스 시: 간단한 DB 쿼리 (비용 저렴)</li>\n<li>풀 크기: 작게 유지</li>\n</ul>\n<p><strong>큰 풀:</strong></p>\n<ul>\n<li>데이터: 복잡한 머신러닝 결과 (드물게 액세스)</li>\n<li>캐시 미스 시: 수십 초 걸리는 재계산 (비용 매우 비쌈)</li>\n<li>풀 크기: 크게 할당 (미스 방지)</li>\n</ul>\n<h4>Churn 특성에 따른 분리</h4>\n<p><strong>Churn이란?</strong></p>\n<p>Churn은 데이터의 변동률을 의미합니다:</p>\n<ul>\n<li><strong>Low-churn</strong>: 데이터가 거의 안 바뀜 (사용자 프로필, 설정 등)</li>\n<li><strong>High-churn</strong>: 데이터가 자주 바뀜 (실시간 피드, 트렌딩 목록 등)</li>\n</ul>\n<p><strong>Low-churn 키</strong>와 <strong>High-churn 키</strong>를 같은 풀에 두면 문제가 발생합니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">문제:\n- Low-churn 키(여전히 가치 있음)가 제거됨\n- High-churn 키(더 이상 액세스 안 됨)보다 먼저 제거됨</code></pre></div>\n<p>이들을 다른 풀에 배치하면 이러한 부정적 간섭을 방지하고, High-churn 풀의 크기를 캐시 미스 비용에 적절하게 조정할 수 있습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/4111f4b0d8ab0fcc97081af19f14b3a2/8b69f/figure5.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 39.24050632911392%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABpElEQVR42l2S3WvTUBiH8/8JXgve+Ae464GXwzsFLxxeOfBCRTZBFHbrKEMtGam2SdbUraVps6Rp1jVts7RrPh7POaHTeeBH3nNe3uf9igYllaAoiluVZXnn/r82/jzP77xpElSW0pHh+z5RFOE4DrquU6//wDAMxuMxYRjS7/eZTCY0Gg1qtZr4GthWU/hGBEHAfD5DS5IFnjdUWiwWKst6fUOaXrNcpqxWS5E9J8sy4jhW3Uh/lq3wLkLe7X9l/8sJQXhFkszRRqOAVqspMvhIuAyQ0Or8tSVUViAskWSl3r7rHe49eM7LvWMBnHItgbJUyzJFuxcCmNwGS1XjKMmLTM1KdrDz7CNPnh5gdwKMXz3uP3zBqzffBDCuKkzTlNksVorjK+q6yfuDI+y2y3Q65fPhMZ8O6/jBWMwvYmt7j+2dD5htD+Nnh0ePd3n9tsZgOKoq3Gx502UUXdJsWWKGSzGrNaZp43R+kwlbHpn4/PxM+WQXjtOm1+uqpUqOVsEKpX9/ocHAxbYtut0zvOGQ01Mb1+0rmITIMbmuq5ZVxVecP3ZNUQ865KI4AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"High-churn vs Low-churn 워킹셋\"\n        title=\"\"\n        src=\"/static/4111f4b0d8ab0fcc97081af19f14b3a2/f058b/figure5.png\"\n        srcset=\"/static/4111f4b0d8ab0fcc97081af19f14b3a2/c26ae/figure5.png 158w,\n/static/4111f4b0d8ab0fcc97081af19f14b3a2/6bdcf/figure5.png 315w,\n/static/4111f4b0d8ab0fcc97081af19f14b3a2/f058b/figure5.png 630w,\n/static/4111f4b0d8ab0fcc97081af19f14b3a2/8b69f/figure5.png 912w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>워킹셋 그래프 해석</strong></p>\n<p>워킹셋(Working Set)은 특정 기간 동안 실제로 사용되는 데이터의 총 크기입니다.</p>\n<ul>\n<li><strong>Low-churn 데이터</strong>: 일일 워킹셋 ≈ 주간 워킹셋 (매일 같은 데이터 재사용)</li>\n<li><strong>High-churn 데이터</strong>: 일일 워킹셋 &#x3C;&#x3C; 주간 워킹셋 (매일 새로운 데이터 추가)</li>\n</ul>\n<p>일일과 주간 워킹셋의 차이가 클수록 churn rate가 높다는 의미입니다.</p>\n<p><strong>High-churn 데이터는 시간이 지나면 더 이상 접근하지 않지만 메모리를 차지하므로, 별도 풀로 분리하여 관리해야 합니다.</strong></p>\n<h3>Pool 내 복제</h3>\n<p>일부 풀에서는 Memcached 서버의 지연시간과 효율성을 향상시키기 위해 <strong>복제</strong>를 사용합니다.</p>\n<p><strong>복제를 선택하는 경우</strong></p>\n<ol>\n<li>애플리케이션이 정기적으로 많은 키를 동시에 가져옴</li>\n<li>전체 데이터 세트가 1~2개의 Memcached 서버에 들어감</li>\n<li>요청 속도가 단일 서버가 처리할 수 있는 것보다 훨씬 높음</li>\n</ol>\n<p><strong>복제가 더 효율적인 이유</strong></p>\n<p><strong>키 분할 방식</strong>에서는 각 클라이언트가 100개 키를 모두 필요로 하기 때문에 모든 서버에 접근해야 합니다. 서버를 나눠도 각 서버가 받는 총 요청 수는 줄지 않습니다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ecd0da684182980d2f7fe9fffa047501/0c3d0/key.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.89873417721519%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB60lEQVR42oWS608TURDF+9f70UQT/aCfiCZKSGokBhVMRMBY0RCLtF3oa7tlu93XvXt3u/RF+3O2ARFJdJKT2dyZPXPPnVMaDAbko4zMaIEiS1Oy0YjRX8iyjIt8jBt4tAc2Pf+ctmujtFrVUvnPFa5SomPsYcZu1WP/JKDlhIwyI40aHYYkzeYqa2MIvYD3pwc8OS7zqLLORu8jYaa4jjCKKBkVcdTW3Fvb4/76N75bHiznLJdLFpeXXM5mq1zEedfh+ZdNyo3XbHxao2x/YGiiVa3oD2VwScUxJp9Qb7tY9hA/SlBxRCoyl1eTJ0IYiSxjUpxwQCd26OlzyX3G08ntG0bRzYTrKL7yXo/o+JjAstCVCvNqFXmoq4ab3j/jn4Qjz8M/OyMW0nR3l5mQImr+S6iVIjY5tY6H1fUZBoriLMsvfkueieQ4STCJwfb71Lwm9UGLU79zV3IiS/nRSXhYrvJ4s8Zh3WUxnzCbzZmOx0wE0+mUxWKB07F5efiGpz/LPNh/xovONkEW316KVjH9MGfrc4Ptr026ruJCfJnIAozvY1otEsmpnMVim51WhbfdHd4dvWLLPbhrG6ffxxSek81quW0iRjXiuRUKmVIrciLIZfM91+GkWcdqNcQZFn4QoKVHyTM5Tp9fd2/rTp95rCMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"키 분할 방식\"\n        title=\"\"\n        src=\"/static/ecd0da684182980d2f7fe9fffa047501/f058b/key.png\"\n        srcset=\"/static/ecd0da684182980d2f7fe9fffa047501/c26ae/key.png 158w,\n/static/ecd0da684182980d2f7fe9fffa047501/6bdcf/key.png 315w,\n/static/ecd0da684182980d2f7fe9fffa047501/f058b/key.png 630w,\n/static/ecd0da684182980d2f7fe9fffa047501/40601/key.png 945w,\n/static/ecd0da684182980d2f7fe9fffa047501/78612/key.png 1260w,\n/static/ecd0da684182980d2f7fe9fffa047501/0c3d0/key.png 1414w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>반면 <strong>복제 방식</strong>에서는 모든 서버가 전체 키를 가지고 있어 클라이언트가 아무 서버나 하나만 선택하면 됩니다. 이로 인해 요청이 여러 서버에 고르게 분산되어 각 서버의 부하가 실제로 감소합니다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/257d5063662868cad568656efa40b2b2/92338/replication.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.89873417721519%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB5ElEQVR42n2S22sTQRjF+8/7Ij4oCoIBbwURBInWVPTFXrVaxZA23SYm2WQ3zWw2e9/ZzXX35+xGKwHpB2duZzhzZuZsjUYj0kSSxKFCQCJjpJQlEpkoLlXjhDiOmU6nWI5NTxiYrmBgXzEQJlEUKT6i0NryPZe+FbHfEByej+mPPLLVkvl8jpxKRCCQqWSxWDCLU/b0U561a9z/tM3jRpWacUye5RTlOI4SdCf86HjcenrAnZffOL0UpDLE9wMFH+EIHM8hiEKsoaDW3KOiV7n95RF36895axySLVel4KQQ9JTDIJ7R7Fxx0RVqnJZkvj70unLWC1Y4oeXodMMhncBAd0z+UGuHRbMWyK/7vyg2zpYztImGZmuki5Sb6kbBLM/KuZu4nJgnHA2OsGJrw+1/BT3Pw4tSWn2L9mCMH8obrzwOHS7HPdqWgt1Hnww3r+y7NvVewIPqGQ93Lvh+OUJGPq7rYauI6JaOrfb4QYAwR+xqB2zr77m3v02l8Zp3w+PNT/HVDxp2ws5Bk93PLUw7KsnVKmOp4iNnKjLLhXqCnGU658j4yQvxkYr2iifdN3wQX8lX2T+HhmkSBIWjCZ7rqKh4ah5cIwzDsi8iJGNJ/2pA/dcZjW6TevccrdcquQKF1m/uZev2jHexcwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"복제 방식\"\n        title=\"\"\n        src=\"/static/257d5063662868cad568656efa40b2b2/f058b/replication.png\"\n        srcset=\"/static/257d5063662868cad568656efa40b2b2/c26ae/replication.png 158w,\n/static/257d5063662868cad568656efa40b2b2/6bdcf/replication.png 315w,\n/static/257d5063662868cad568656efa40b2b2/f058b/replication.png 630w,\n/static/257d5063662868cad568656efa40b2b2/40601/replication.png 945w,\n/static/257d5063662868cad568656efa40b2b2/78612/replication.png 1260w,\n/static/257d5063662868cad568656efa40b2b2/92338/replication.png 1411w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>각 클라이언트는 자신의 IP 주소를 기반으로 복제본을 선택합니다. 일관성 유지를 위해 모든 복제본에 무효화를 전달해야 합니다.</p>\n<h3>장애 처리: Gutter 시스템</h3>\n<p>Memcache에서 데이터를 가져오지 못하면 백엔드 서비스에 과도한 부하가 발생하여 연쇄 장애를 일으킬 수 있습니다.</p>\n<h4>두 가지 규모의 장애</h4>\n<ol>\n<li><strong>소규모 장애</strong>: 네트워크나 서버 장애로 소수의 호스트에 접근 불가</li>\n<li><strong>광범위한 장애</strong>: 클러스터 내 상당 비율의 서버에 영향</li>\n</ol>\n<p>전체 클러스터를 오프라인으로 전환해야 하는 경우, 사용자 요청을 다른 클러스터로 우회시킵니다.</p>\n<h4>Gutter 메커니즘</h4>\n<p>소규모 장애를 위해 <strong>Gutter</strong>라는 특수 시스템을 도입했습니다. Gutter는 실패한 몇 개 서버의 책임을 대신 맡는 작은 머신 세트입니다.</p>\n<p>클러스터 내 Memcached 서버의 약 <code class=\"language-text\">1%</code>를 차지합니다.</p>\n<p><strong>동작 방식</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// 1. 일반 Memcached 서버에 요청</span>\nvalue <span class=\"token operator\">=</span> memcache<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 2. Gutter 풀에 재시도</span>\n    value <span class=\"token operator\">=</span> gutterPool<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 3. DB 조회 후 Gutter에 저장</span>\n        value <span class=\"token operator\">=</span> database<span class=\"token punctuation\">.</span><span class=\"token function\">select</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        gutterPool<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> shortExpiration<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>Gutter의 효과</strong></p>\n<p>Gutter 시스템 도입 후 실제 효과:</p>\n<ul>\n<li><strong>실패를 히트로 전환</strong>: 원래 Memcached 서버 장애로 실패했을 요청의 10~25%를 Gutter에서 성공적으로 처리</li>\n<li><strong>장애율 99% 감소</strong>: 클라이언트가 체감하는 캐시 실패율이 거의 사라짐</li>\n<li><strong>빠른 복구</strong>: Memcached 서버가 완전히 다운되어도 4분 이내에 Gutter 히트율이 35% 이상으로 상승 (자주 50%까지 도달)</li>\n</ul>\n<p><strong>Gutter의 특징</strong></p>\n<ul>\n<li>짧은 만료 시간(short expiration)을 사용하여 약간 오래된 데이터를 제공하더라도 DB 부하를 줄임</li>\n<li>빠른 만료로 인해 별도의 무효화(invalidation) 메커니즘이 필요 없음</li>\n</ul>\n<h4>Rehashing을 사용하지 않는 이유</h4>\n<p>서버 장애 시 다른 접근 방법도 있습니다. 남은 정상 서버들에게 장애 서버의 키를 재분배(Rehashing)하는 것입니다.</p>\n<p><strong>Rehashing의 문제점</strong></p>\n<p>하지만 이 방식은 위험합니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">시나리오: 10대 서버 중 1대 장애 발생\n\n문제: 인기 있는 핫 키(예: 유명인 프로필)가 서버 전체 요청의 20%를 차지\n→ 장애 서버가 이 핫 키를 담당했다면?\n→ Rehashing으로 다른 정상 서버에 핫 키 재배치\n→ 해당 서버에 갑자기 20% 추가 부하 발생\n→ 그 서버도 과부하로 다운\n→ 도미노처럼 연쇄 장애 발생</code></pre></div>\n<p><strong>Gutter의 장점</strong></p>\n<p>Gutter는 유휴 상태의 별도 서버 풀(클러스터의 1%)이므로:</p>\n<ul>\n<li>정상 서버에 추가 부하를 주지 않음</li>\n<li>핫 키 문제와 무관하게 안전하게 장애 처리</li>\n<li>연쇄 장애 위험 차단</li>\n</ul>\n<hr>\n<p>다음 편에서는 지역 내/지역 간 확장과 성능 최적화를 다룹니다.</p>","wordCount":{"words":1597},"frontmatter":{"title":"Facebook Memcached 아키텍처 (1탄) - 기본 설계와 클러스터 내부 최적화","date":"October 01, 2025","description":"초당 10억 요청을 처리하는 Facebook의 분산 캐시 시스템 기본 아키텍처와 단일 클러스터 내 최적화 전략을 분석합니다."}},"previous":{"fields":{"slug":"/network2/"},"frontmatter":{"title":"HTTP, HTTPS 그리고 웹의 동작 원리"}},"next":{"fields":{"slug":"/cache-part2/"},"frontmatter":{"title":"Facebook Memcached 아키텍처 (2탄) - 대규모 확장과 성능 최적화"}}},"pageContext":{"id":"7934a91e-9561-5a22-90e9-8ede258c0daf","previousPostId":"200e4ba5-aeca-5981-bec6-e05f77f432f8","nextPostId":"c562831f-2840-545a-9e1c-fdd33dc31eeb"}},"staticQueryHashes":["3257411868","3517523002"],"slicesMap":{}}