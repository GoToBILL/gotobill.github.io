{"componentChunkName":"component---src-templates-blog-post-js","path":"/mysql-cost-model/","result":{"data":{"site":{"siteMetadata":{"title":"GoToBill"}},"markdownRemark":{"id":"29392d80-1217-5c84-9834-5067e6ef46a2","excerpt":"코스트 모델이란? MySQL 옵티마이저는 여러 실행 계획 중에서 가장 비용이 낮은 계획을 선택합니다. 이때 비용을 계산하는 기준이 코스트 모델(Cost Model)입니다. 쿼리 실행에 필요한 작업들 이 쿼리를 실행하려면: 디스크에서 데이터 페이지 읽기 InnoDB…","html":"<h2>코스트 모델이란?</h2>\n<p>MySQL 옵티마이저는 여러 실행 계획 중에서 가장 <strong>비용이 낮은</strong> 계획을 선택합니다. 이때 비용을 계산하는 기준이 <strong>코스트 모델</strong>(Cost Model)입니다.</p>\n<h3>쿼리 실행에 필요한 작업들</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> orders o\n<span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span> customers c <span class=\"token keyword\">ON</span> o<span class=\"token punctuation\">.</span>customer_id <span class=\"token operator\">=</span> c<span class=\"token punctuation\">.</span>id\n<span class=\"token keyword\">WHERE</span> o<span class=\"token punctuation\">.</span>amount <span class=\"token operator\">></span> <span class=\"token number\">10000</span>\n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> o<span class=\"token punctuation\">.</span>created_at<span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 쿼리를 실행하려면:</p>\n<ol>\n<li>디스크에서 데이터 페이지 읽기</li>\n<li>InnoDB 버퍼 풀에서 데이터 페이지 읽기</li>\n<li>인덱스 키 비교</li>\n<li>WHERE 조건 레코드 평가</li>\n<li>정렬을 위한 임시 테이블 생성</li>\n<li>조인 수행</li>\n</ol>\n<p>각 작업마다 비용이 다릅니다. 디스크 읽기는 메모리 읽기보다 느리고, 정렬은 단순 비교보다 비쌉니다.</p>\n<h3>코스트 모델의 역할</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">실행 계획 A = (디스크 읽기 × 100) + (메모리 읽기 × 1000) + (키 비교 × 500)\n실행 계획 B = (디스크 읽기 × 10) + (메모리 읽기 × 5000) + (키 비교 × 2000)</code></pre></div>\n<p>옵티마이저는 이런 식으로 각 실행 계획의 총 비용을 계산하고, 가장 비용이 낮은 계획을 선택합니다.</p>\n<h2>MySQL 5.7 이전 vs 5.7+</h2>\n<h3>MySQL 5.7 이전: 하드코딩된 비용</h3>\n<p>각 단위 작업의 비용이 MySQL 소스 코드에 상수로 고정되어 있었습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\">// MySQL 소스 코드 (의사 코드)</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">double</span> DISK_READ_COST <span class=\"token operator\">=</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">double</span> MEMORY_READ_COST <span class=\"token operator\">=</span> <span class=\"token number\">0.25</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">double</span> KEY_COMPARE_COST <span class=\"token operator\">=</span> <span class=\"token number\">0.05</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>문제점</strong></p>\n<ul>\n<li>서버 하드웨어가 바뀌어도 비용은 동일</li>\n<li>사용자가 조정 불가능</li>\n</ul>\n<h3>MySQL 5.7+: 조정 가능한 코스트 모델</h3>\n<p>비용 정보를 시스템 테이블에 저장하여 관리자가 조정할 수 있게 되었습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 코스트 모델 테이블 확인</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> mysql<span class=\"token punctuation\">.</span>server_cost<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> mysql<span class=\"token punctuation\">.</span>engine_cost<span class=\"token punctuation\">;</span></code></pre></div>\n<p>MySQL 8.0에서는 히스토그램과 버퍼 풀 메모리 적재 비율까지 반영하여 정확도가 더 높아졌습니다.</p>\n<h2>코스트 모델 구성</h2>\n<h3>server_cost 테이블</h3>\n<p>쿼리 처리 과정의 일반적인 작업 비용을 관리합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>\n    cost_name<span class=\"token punctuation\">,</span>\n    default_value<span class=\"token punctuation\">,</span>\n    cost_value<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">comment</span>\n<span class=\"token keyword\">FROM</span> mysql<span class=\"token punctuation\">.</span>server_cost<span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>cost_name</th>\n<th>default_value</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>disk_temptable_create_cost</td>\n<td>20.00</td>\n<td>디스크 임시 테이블 생성</td>\n</tr>\n<tr>\n<td>disk_temptable_row_cost</td>\n<td>0.50</td>\n<td>디스크 임시 테이블 레코드 읽기</td>\n</tr>\n<tr>\n<td>key_compare_cost</td>\n<td>0.05</td>\n<td>인덱스 키 비교</td>\n</tr>\n<tr>\n<td>memory_temptable_create_cost</td>\n<td>1.00</td>\n<td>메모리 임시 테이블 생성</td>\n</tr>\n<tr>\n<td>memory_temptable_row_cost</td>\n<td>0.10</td>\n<td>메모리 임시 테이블 레코드 읽기</td>\n</tr>\n<tr>\n<td>row_evaluate_cost</td>\n<td>0.10</td>\n<td>레코드 조건 평가</td>\n</tr>\n</tbody>\n</table>\n<h3>engine_cost 테이블</h3>\n<p>스토리지 엔진별 작업 비용을 관리합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>\n    engine_name<span class=\"token punctuation\">,</span>\n    cost_name<span class=\"token punctuation\">,</span>\n    default_value<span class=\"token punctuation\">,</span>\n    cost_value<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">comment</span>\n<span class=\"token keyword\">FROM</span> mysql<span class=\"token punctuation\">.</span>engine_cost<span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>engine_name</th>\n<th>cost_name</th>\n<th>default_value</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>default</td>\n<td>io_block_read_cost</td>\n<td>1.00</td>\n<td>디스크 데이터 페이지 읽기</td>\n</tr>\n<tr>\n<td>default</td>\n<td>memory_block_read_cost</td>\n<td>0.25</td>\n<td>메모리 데이터 페이지 읽기</td>\n</tr>\n</tbody>\n</table>\n<p><strong>engine_name</strong></p>\n<ul>\n<li><strong>default</strong>: 모든 스토리지 엔진에 적용되는 기본값</li>\n<li><strong>InnoDB</strong>, <strong>MyISAM</strong>, <strong>MEMORY</strong>: 특정 엔진별로 다른 값 설정 가능</li>\n</ul>\n<p>현재는 InnoDB에서만 코스트 모델이 의미 있게 작동합니다.</p>\n<h2>단위 작업 비용이 미치는 영향</h2>\n<p>각 비용을 조정하면 옵티마이저의 선택이 달라집니다. 하지만 <strong>절대 함부로 변경하지 마세요.</strong></p>\n<h3>row_evaluate_cost</h3>\n<p>레코드 조건 평가 비용입니다.</p>\n<p><strong>값을 높이면</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 많은 레코드를 평가하는 풀 테이블 스캔이 비쌈</span>\n<span class=\"token comment\">-- 적은 레코드를 평가하는 인덱스 레인지 스캔이 선호됨</span></code></pre></div>\n<p>풀 테이블 스캔보다 인덱스 레인지 스캔을 선택할 가능성이 높아집니다.</p>\n<h3>key_compare_cost</h3>\n<p>인덱스 키 비교 비용입니다.</p>\n<p><strong>값을 높이면</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 정렬(ORDER BY)처럼 키 비교가 많은 작업이 비쌈</span>\n<span class=\"token comment\">-- 가능하면 정렬을 피하는 실행 계획 선택</span></code></pre></div>\n<p>정렬을 수행하지 않는 방향의 실행 계획을 선택할 가능성이 높아집니다.</p>\n<h3>io_block_read_cost</h3>\n<p>디스크 읽기 비용입니다.</p>\n<p><strong>값을 높이면</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 디스크 읽기가 많은 인덱스는 비쌈</span>\n<span class=\"token comment\">-- InnoDB 버퍼 풀에 많이 적재된 인덱스를 선호</span></code></pre></div>\n<p>버퍼 풀 적중률이 높은 인덱스를 사용할 가능성이 높아집니다.</p>\n<h3>memory_block_read_cost</h3>\n<p>메모리 읽기 비용입니다.</p>\n<p><strong>값을 높이면</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 메모리 읽기도 비싸다고 판단</span>\n<span class=\"token comment\">-- 버퍼 풀 적중률이 낮아도 해당 인덱스를 사용 가능</span></code></pre></div>\n<p>버퍼 풀에 적재되지 않았어도 효율적인 인덱스라면 사용할 가능성이 높아집니다.</p>\n<h3>disk_temptable_create_cost</h3>\n<p>디스크 임시 테이블 생성 비용입니다.</p>\n<p><strong>값을 높이면</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 디스크 임시 테이블 생성을 회피</span>\n<span class=\"token comment\">-- GROUP BY, ORDER BY를 인덱스로 처리하려 시도</span></code></pre></div>\n<p>임시 테이블을 만들지 않는 방향의 실행 계획을 선택할 가능성이 높아집니다.</p>\n<h3>기본 EXPLAIN</h3>\n<p>일반적인 EXPLAIN은 비용을 보여주지 않습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> employees\n<span class=\"token keyword\">WHERE</span> first_name <span class=\"token operator\">=</span> <span class=\"token string\">'Matt'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>key</th>\n<th>rows</th>\n<th>filtered</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>employees</td>\n<td>ref</td>\n<td>ix_firstname</td>\n<td>233</td>\n<td>100.00</td>\n</tr>\n</tbody>\n</table>\n<p>예상 레코드 수(rows)만 표시되고 <strong>비용은 표시되지 않습니다.</strong></p>\n<h3>EXPLAIN FORMAT=TREE</h3>\n<p>간단하게 비용을 확인할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span> FORMAT<span class=\"token operator\">=</span>TREE\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> employees\n<span class=\"token keyword\">WHERE</span> first_name <span class=\"token operator\">=</span> <span class=\"token string\">'Matt'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>결과</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-> Index lookup on employees using ix_firstname (first_name='Matt')\n   (cost=256.10 rows=233)</code></pre></div>\n<p><strong>해석</strong></p>\n<ul>\n<li><strong>cost=256.10</strong>: 예상 비용</li>\n<li><strong>rows=233</strong>: 예상 레코드 수</li>\n</ul>\n<p><strong>더 복잡한 쿼리 예시</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span> FORMAT<span class=\"token operator\">=</span>TREE\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> employees\n<span class=\"token keyword\">WHERE</span> first_name <span class=\"token operator\">=</span> <span class=\"token string\">'Matt'</span>\n  <span class=\"token operator\">AND</span> hire_date <span class=\"token operator\">></span> <span class=\"token string\">'1990-01-01'</span>\n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> birth_date<span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>결과</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-> Sort: employees.birth_date  (cost=285.33 rows=77)\n    -> Filter: (employees.hire_date > '1990-01-01')  (cost=256.10 rows=77)\n        -> Index lookup on employees using ix_firstname (first_name='Matt')\n           (cost=256.10 rows=233)</code></pre></div>\n<p><strong>해석</strong></p>\n<p>각 단계별로 들여쓰기되어 표시됩니다.</p>\n<ol>\n<li><strong>인덱스 조회</strong> (cost=256.10): ix_firstname 인덱스로 first_name='Matt' 검색</li>\n<li><strong>필터링</strong> (cost=256.10): hire_date 조건으로 233건 → 77건 필터링</li>\n<li><strong>정렬</strong> (cost=285.33): birth_date로 정렬</li>\n</ol>\n<p>비용이 증가하는 것을 볼 수 있습니다 (256.10 → 285.33).</p>\n<h3>EXPLAIN FORMAT=JSON</h3>\n<p>상세한 비용 정보를 확인할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span> FORMAT<span class=\"token operator\">=</span>JSON\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> employees\n<span class=\"token keyword\">WHERE</span> first_name <span class=\"token operator\">=</span> <span class=\"token string\">'Matt'</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"query_block\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"select_id\"</span><span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"cost_info\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"query_cost\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"255.08\"</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"table\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"table_name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"employees\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"access_type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"ref\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"key\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"ix_firstname\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"rows_examined_per_scan\"</span><span class=\"token operator\">:</span> <span class=\"token number\">233</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"rows_produced_per_join\"</span><span class=\"token operator\">:</span> <span class=\"token number\">233</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"filtered\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"100.00\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"cost_info\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"read_cost\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"231.78\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"eval_cost\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"23.30\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"prefix_cost\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"255.08\"</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>비용 항목</strong></p>\n<ul>\n<li><strong>read_cost</strong>: 인덱스/테이블 읽기 비용 (231.78)</li>\n<li><strong>eval_cost</strong>: 레코드 평가 비용 (23.30)</li>\n<li><strong>prefix_cost</strong>: 전체 비용 (255.08 = read_cost + eval_cost)</li>\n<li><strong>query_cost</strong>: 쿼리 전체 비용</li>\n</ul>\n<h3>EXPLAIN ANALYZE로 실제 성능 측정</h3>\n<p>MySQL 8.0.18부터 지원하는 기능으로, <strong>실제 쿼리를 실행</strong>하여 예상 비용과 실제 소요 시간을 함께 보여줍니다.</p>\n<p><strong>EXPLAIN vs EXPLAIN ANALYZE</strong></p>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>EXPLAIN</th>\n<th>EXPLAIN ANALYZE</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>실행 방식</td>\n<td>실행 계획만 수립</td>\n<td><strong>실제 쿼리 실행</strong></td>\n</tr>\n<tr>\n<td>소요 시간</td>\n<td>즉시</td>\n<td>쿼리 완료까지 대기</td>\n</tr>\n<tr>\n<td>제공 정보</td>\n<td>예상 비용, 예상 rows</td>\n<td>예상 + <strong>실제 시간, 실제 rows</strong></td>\n</tr>\n<tr>\n<td>용도</td>\n<td>빠른 계획 확인</td>\n<td>실제 성능 측정</td>\n</tr>\n</tbody>\n</table>\n<p><strong>기본 사용법</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span> <span class=\"token keyword\">ANALYZE</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> employees\n<span class=\"token keyword\">WHERE</span> first_name <span class=\"token operator\">=</span> <span class=\"token string\">'Matt'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>결과</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-> Index lookup on employees using ix_firstname (first_name='Matt')\n   (cost=256.10 rows=233)\n   (actual time=0.348..1.046 rows=233 loops=1)</code></pre></div>\n<p><strong>필드 설명</strong></p>\n<ul>\n<li><strong>cost=256.10</strong>: 예상 비용</li>\n<li><strong>rows=233</strong>: 예상 레코드 수</li>\n<li><strong>actual time=0.348..1.046</strong>: 실제 소요 시간 (밀리초)\n<ul>\n<li>첫 번째 값 (0.348): 첫 레코드를 가져오는 데 걸린 시간</li>\n<li>두 번째 값 (1.046): 마지막 레코드를 가져오는 데 걸린 시간</li>\n</ul>\n</li>\n<li><strong>rows=233</strong>: 실제 처리한 레코드 수</li>\n<li><strong>loops=1</strong>: 반복 실행 횟수</li>\n</ul>\n<p><strong>TREE 포맷 읽는 법</strong></p>\n<p>EXPLAIN ANALYZE는 항상 TREE 포맷으로 결과를 표시합니다. 들여쓰기로 실행 순서를 파악할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span> <span class=\"token keyword\">ANALYZE</span>\n<span class=\"token keyword\">SELECT</span> e<span class=\"token punctuation\">.</span>emp_no<span class=\"token punctuation\">,</span> <span class=\"token function\">AVG</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span>salary<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">FROM</span> employees e\n<span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span> salaries s <span class=\"token keyword\">ON</span> s<span class=\"token punctuation\">.</span>emp_no <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>emp_no\n    <span class=\"token operator\">AND</span> s<span class=\"token punctuation\">.</span>salary <span class=\"token operator\">></span> <span class=\"token number\">50000</span>\n    <span class=\"token operator\">AND</span> s<span class=\"token punctuation\">.</span>from_date <span class=\"token operator\">&lt;=</span> <span class=\"token string\">'1990-01-01'</span>\n    <span class=\"token operator\">AND</span> s<span class=\"token punctuation\">.</span>to_date <span class=\"token operator\">></span> <span class=\"token string\">'1990-01-01'</span>\n<span class=\"token keyword\">WHERE</span> e<span class=\"token punctuation\">.</span>first_name <span class=\"token operator\">=</span> <span class=\"token string\">'Matt'</span>\n<span class=\"token keyword\">GROUP</span> <span class=\"token keyword\">BY</span> e<span class=\"token punctuation\">.</span>hire_date<span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>결과</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">A) -> Table scan on &lt;temporary>\n       (actual time=0.001..0.004 rows=48 loops=1)\n\nB)    -> Aggregate using temporary table\n          (actual time=3.799..3.808 rows=48 loops=1)\n\nC)       -> Nested loop inner join (cost=685.24 rows=135)\n             (actual time=0.367..3.602 rows=48 loops=1)\n\nD)          -> Index lookup on e using ix_firstname (first_name='Matt')\n                (cost=215.08 rows=233)\n                (actual time=0.348..1.046 rows=233 loops=1)\n\nE)          -> Filter: ((s.salary > 50000) and (s.from_date &lt;= '1990-01-01')\n                        and (s.to_date > '1990-01-01'))\n                (actual time=0.009..0.011 rows=0 loops=233)\n\nF)             -> Index lookup on s using PRIMARY (emp_no=e.emp_no)\n                   (cost=0.98 rows=10)\n                   (actual time=0.007..0.009 rows=10 loops=233)</code></pre></div>\n<p><strong>실행 순서 규칙</strong></p>\n<ol>\n<li><strong>들여쓰기가 같은 레벨</strong>: 상단에 위치한 라인이 먼저 실행</li>\n<li><strong>들여쓰기가 다른 레벨</strong>: 가장 안쪽에 위치한 라인이 먼저 실행</li>\n</ol>\n<p><strong>위 쿼리의 실제 실행 순서</strong></p>\n<ol>\n<li><strong>D) Index lookup on e using ix_firstname</strong> - employees 테이블 인덱스로 first_name='Matt' 조회</li>\n<li><strong>F) Index lookup on s using PRIMARY</strong> - salaries 테이블 프라이머리 키로 emp_no 조회</li>\n<li><strong>E) Filter</strong> - salary, from_date, to_date 조건 필터링</li>\n<li><strong>C) Nested loop inner join</strong> - 조인 수행</li>\n<li><strong>B) Aggregate using temporary table</strong> - GROUP BY를 위한 임시 테이블 생성 및 집계</li>\n<li><strong>A) Table scan on temporary</strong> - 임시 테이블 결과 반환</li>\n</ol>\n<p><strong>한글로 풀어쓴 실행 계획</strong></p>\n<ol>\n<li>employees 테이블의 ix_firstname 인덱스를 통해 first_name='Matt' 조건에 일치하는 레코드 검색 (233건)</li>\n<li>salaries 테이블의 PRIMARY 키를 통해 emp_no가 1번 결과의 emp_no와 동일한 레코드 검색 (평균 10건씩)</li>\n<li>salary > 50000, from_date &#x3C;= '1990-01-01', to_date > '1990-01-01' 조건에 일치하는 건만 필터링</li>\n<li>1번과 3번의 결과를 조인</li>\n<li>임시 테이블에 결과를 저장하면서 hire_date로 GROUP BY 집계 실행</li>\n<li>임시 테이블의 결과를 읽어서 최종 반환 (48건)</li>\n</ol>\n<p><strong>loops의 의미</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">F) -> Index lookup on s using PRIMARY (emp_no=e.emp_no)\n      (actual time=0.007..0.009 rows=10 loops=233)</code></pre></div>\n<ul>\n<li><strong>loops=233</strong>: 이 작업을 233번 반복 실행</li>\n<li><strong>rows=10</strong>: 매번 평균 10건의 레코드 처리</li>\n<li><strong>actual time=0.007..0.009</strong>: 첫 레코드는 평균 0.007ms, 마지막 레코드를 읽는데는 평균 0.009ms 소요</li>\n</ul>\n<p>즉, employees 테이블에서 233명을 찾았고, 각 사람마다 salaries 테이블을 조회(10건씩)하여 총 233번 반복했다는 의미입니다.</p>\n<p><strong>활용 방법</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 1. 먼저 EXPLAIN으로 실행 계획 확인</span>\n<span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- 2. 계획이 합리적이면 EXPLAIN ANALYZE로 실제 성능 측정</span>\n<span class=\"token keyword\">EXPLAIN</span> <span class=\"token keyword\">ANALYZE</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>주의사항</strong></p>\n<ul>\n<li>EXPLAIN ANALYZE는 <strong>실제로 쿼리를 실행</strong>합니다</li>\n<li>느린 쿼리는 완료될 때까지 기다려야 결과를 볼 수 있습니다</li>\n<li>대용량 테이블에서는 먼저 EXPLAIN으로 계획을 확인하고 튜닝한 후 사용하세요</li>\n<li>UPDATE, DELETE 쿼리도 실행되므로 프로덕션 환경에서는 주의가 필요합니다</li>\n</ul>\n<h2>단위 작업 비용이 미치는 영향</h2>","wordCount":{"words":799},"frontmatter":{"title":"MySQL 코스트 모델 이해하기","date":"October 19, 2025","description":"MySQL 옵티마이저가 실행 계획의 비용을 계산하는 코스트 모델의 동작 원리와 활용 방법을 설명합니다."}},"previous":{"fields":{"slug":"/mysql-histogram/"},"frontmatter":{"title":"MySQL 히스토그램으로 쿼리 성능 개선하기"}},"next":{"fields":{"slug":"/mysql-select-type/"},"frontmatter":{"title":"MySQL 실행 계획 - id와 select_type"}}},"pageContext":{"id":"29392d80-1217-5c84-9834-5067e6ef46a2","previousPostId":"4c6d09e4-c0ee-565e-998c-5ad61669fc8b","nextPostId":"cb47e515-3ee5-5d97-9ac4-0ac02482380b"}},"staticQueryHashes":["3257411868","3517523002"],"slicesMap":{}}