{"componentChunkName":"component---src-templates-blog-post-js","path":"/mysql-extra-part2/","result":{"data":{"site":{"siteMetadata":{"title":"GoToBill"}},"markdownRemark":{"id":"3f933b63-ddc6-5345-af67-76703c1284e7","excerpt":"이 글은 Real MySQL 8.0 책의 내용을 참고하여 작성되었습니다. 22. Using join buffer 의미: 조인 시 조인 버퍼 사용 조인 대상 테이블(드리븐 테이블)에 적절한 인덱스가 없을 때 조인 버퍼를 사용합니다. id select_type table type key…","html":"<blockquote>\n<p>이 글은 Real MySQL 8.0 책의 내용을 참고하여 작성되었습니다.</p>\n</blockquote>\n<hr>\n<h2>22. Using join buffer</h2>\n<p><strong>의미</strong>: 조인 시 조인 버퍼 사용</p>\n<p>조인 대상 테이블(드리븐 테이블)에 적절한 인덱스가 없을 때 조인 버퍼를 사용합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> dept_emp de<span class=\"token punctuation\">,</span> employees e\n<span class=\"token keyword\">WHERE</span> de<span class=\"token punctuation\">.</span>from_date<span class=\"token operator\">></span><span class=\"token string\">'2005-01-01'</span> <span class=\"token operator\">AND</span> e<span class=\"token punctuation\">.</span>emp_no<span class=\"token operator\">&lt;</span><span class=\"token number\">10904</span><span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>key</th>\n<th>Extra</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>de</td>\n<td>range</td>\n<td>ix_fromdate</td>\n<td>Using index condition</td>\n</tr>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>e</td>\n<td>range</td>\n<td>PRIMARY</td>\n<td>Using where; Using join buffer (hash join)</td>\n</tr>\n</tbody>\n</table>\n<h3>조인 버퍼 종류</h3>\n<p><strong>Block Nested Loop (BNL)</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Using join buffer (Block Nested Loop)</code></pre></div>\n<p><strong>언제 사용되나?</strong></p>\n<p>드리븐 테이블에 조인 조건에 맞는 인덱스가 없을 때 사용됩니다.</p>\n<p><strong>동작 방식</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- dept_emp: 30만 건, employees: 10만 건</span>\n<span class=\"token comment\">-- employees에 dept_no 인덱스 없음</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> dept_emp de\n<span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span> employees e <span class=\"token keyword\">ON</span> de<span class=\"token punctuation\">.</span>dept_no <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>dept_no\n<span class=\"token keyword\">WHERE</span> de<span class=\"token punctuation\">.</span>from_date <span class=\"token operator\">></span> <span class=\"token string\">'2005-01-01'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ol>\n<li>dept_emp에서 조건에 맞는 1만 건을 조인 버퍼에 저장</li>\n<li>employees 테이블을 처음부터 끝까지 스캔하면서 버퍼의 1만 건과 비교</li>\n<li>인덱스가 없어서 매번 풀 스캔 필요</li>\n</ol>\n<p><strong>문제점</strong>: 드리븐 테이블을 반복 풀 스캔하여 비효율적</p>\n<hr>\n<p><strong>Batched Key Access (BKA)</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Using join buffer (Batched Key Access)</code></pre></div>\n<p><strong>언제 사용되나?</strong></p>\n<p>드리븐 테이블에 인덱스가 있고, MRR 최적화를 사용할 때입니다.</p>\n<p><strong>동작 방식</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- dept_emp: 30만 건, employees: 10만 건</span>\n<span class=\"token comment\">-- employees에 dept_no 인덱스 있음</span>\n<span class=\"token keyword\">SET</span> optimizer_switch<span class=\"token operator\">=</span><span class=\"token string\">'mrr=on,mrr_cost_based=off,batched_key_access=on'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> dept_emp de\n<span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span> employees e <span class=\"token keyword\">ON</span> de<span class=\"token punctuation\">.</span>dept_no <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>dept_no\n<span class=\"token keyword\">WHERE</span> de<span class=\"token punctuation\">.</span>from_date <span class=\"token operator\">></span> <span class=\"token string\">'2005-01-01'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ol>\n<li>dept_emp에서 조건에 맞는 레코드들의 dept_no를 버퍼에 모음\n<ul>\n<li>예: [d001, d003, d001, d005, d003, ...]</li>\n</ul>\n</li>\n<li>dept_no를 정렬하여 중복 제거\n<ul>\n<li>정렬 후: [d001, d003, d005, ...]</li>\n</ul>\n</li>\n<li>정렬된 순서대로 employees의 인덱스를 한 번에 조회 (MRR)</li>\n<li>디스크 랜덤 I/O를 순차 I/O로 변환</li>\n</ol>\n<p><strong>장점</strong>: 인덱스를 사용하면서도 디스크 접근을 최적화</p>\n<hr>\n<p><strong>hash join (MySQL 8.0.18+)</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Using join buffer (hash join)</code></pre></div>\n<p><strong>언제 사용되나?</strong></p>\n<p>등호(=) 조인이고 인덱스가 없을 때 자동으로 사용됩니다. BNL보다 훨씬 빠릅니다.</p>\n<p><strong>동작 방식</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- dept_emp: 30만 건, employees: 10만 건</span>\n<span class=\"token comment\">-- employees에 dept_no 인덱스 없음</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> dept_emp de\n<span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span> employees e <span class=\"token keyword\">ON</span> de<span class=\"token punctuation\">.</span>dept_no <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>dept_no\n<span class=\"token keyword\">WHERE</span> de<span class=\"token punctuation\">.</span>from_date <span class=\"token operator\">></span> <span class=\"token string\">'2005-01-01'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ol>\n<li>\n<p><strong>Build Phase</strong>: dept_emp에서 1만 건을 읽어 해시 테이블 생성</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">해시 테이블:\nhash(d001) → [레코드1, 레코드5, ...]\nhash(d003) → [레코드2, 레코드7, ...]\nhash(d005) → [레코드3, ...]</code></pre></div>\n</li>\n<li>\n<p><strong>Probe Phase</strong>: employees를 스캔하면서 해시 테이블 조회</p>\n<ul>\n<li>employees의 dept_no = 'd001' → 해시 테이블에서 hash(d001) 조회 (O(1))</li>\n<li>일치하는 레코드들과 조인</li>\n</ul>\n</li>\n</ol>\n<h3>성능 개선</h3>\n<p><strong>문제점</strong></p>\n<p>조인 조건에 인덱스가 없어서 비효율적입니다.</p>\n<p><strong>해결 방법</strong></p>\n<ol>\n<li>드리븐 테이블의 조인 컬럼에 인덱스 추가</li>\n<li>조인 순서 변경 (힌트 사용)</li>\n<li><code class=\"language-text\">join_buffer_size</code> 설정 (기본 1MB, 데이터 웨어하우스는 더 크게)</li>\n</ol>\n<hr>\n<h2>23. Using MRR</h2>\n<p><strong>의미</strong>: MRR(Multi Range Read) 최적화 사용</p>\n<p>MySQL 엔진이 여러 개의 키 값을 스토리지 엔진으로 한 번에 전달하고, 스토리지 엔진은 이를 정렬하여 최소한의 페이지 접근으로 레코드를 읽습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token comment\">/*+ JOIN_ORDER(s, e) */</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> employees e<span class=\"token punctuation\">,</span>\n     salaries s\n<span class=\"token keyword\">WHERE</span> e<span class=\"token punctuation\">.</span>first_name<span class=\"token operator\">=</span><span class=\"token string\">'Matt'</span>\n  <span class=\"token operator\">AND</span> e<span class=\"token punctuation\">.</span>hire_date <span class=\"token operator\">BETWEEN</span> <span class=\"token string\">'1990-01-01'</span> <span class=\"token operator\">AND</span> <span class=\"token string\">'1991-01-01'</span>\n  <span class=\"token operator\">AND</span> s<span class=\"token punctuation\">.</span>emp_no<span class=\"token operator\">=</span>e<span class=\"token punctuation\">.</span>emp_no\n  <span class=\"token operator\">AND</span> s<span class=\"token punctuation\">.</span>from_date <span class=\"token operator\">BETWEEN</span> <span class=\"token string\">'1990-01-01'</span> <span class=\"token operator\">AND</span> <span class=\"token string\">'1991-01-01'</span>\n  <span class=\"token operator\">AND</span> s<span class=\"token punctuation\">.</span>salary <span class=\"token operator\">BETWEEN</span> <span class=\"token number\">50000</span> <span class=\"token operator\">AND</span> <span class=\"token number\">60000</span><span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>table</th>\n<th>type</th>\n<th>key</th>\n<th>Extra</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>s</td>\n<td>range</td>\n<td>ix_salary</td>\n<td>Using index condition; Using MRR</td>\n</tr>\n<tr>\n<td>1</td>\n<td>e</td>\n<td>eq_ref</td>\n<td>PRIMARY</td>\n<td>Using where</td>\n</tr>\n</tbody>\n</table>\n<p><strong>장점</strong></p>\n<ul>\n<li>디스크 접근 최소화</li>\n<li>대량 레코드 읽기 시 효율적</li>\n</ul>\n<hr>\n<h2>24. Using sort_union / Using union / Using intersect</h2>\n<p><strong>의미</strong>: index_merge 접근 방법 사용 시 인덱스 병합 방식</p>\n<h3>Using intersect</h3>\n<p><strong>의미</strong>: AND로 연결된 조건의 교집합</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> employees\n<span class=\"token keyword\">WHERE</span> emp_no <span class=\"token operator\">BETWEEN</span> <span class=\"token number\">10001</span> <span class=\"token operator\">AND</span> <span class=\"token number\">11000</span>\n  <span class=\"token operator\">AND</span> first_name<span class=\"token operator\">=</span><span class=\"token string\">'Smith'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>Using union</h3>\n<p><strong>의미</strong>: OR로 연결된 조건의 합집합 (동등 비교)</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> employees\n<span class=\"token keyword\">WHERE</span> emp_no<span class=\"token operator\">=</span><span class=\"token number\">10001</span>\n   <span class=\"token operator\">OR</span> first_name<span class=\"token operator\">=</span><span class=\"token string\">'Smith'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>Using sort_union</h3>\n<p><strong>의미</strong>: OR로 연결된 범위 조건의 합집합 (정렬 후 병합)</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> employees\n<span class=\"token keyword\">WHERE</span> emp_no <span class=\"token operator\">BETWEEN</span> <span class=\"token number\">10001</span> <span class=\"token operator\">AND</span> <span class=\"token number\">11000</span>\n   <span class=\"token operator\">OR</span> first_name<span class=\"token operator\">=</span><span class=\"token string\">'Smith'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>차이점</strong></p>\n<ul>\n<li><strong>Using union</strong>: 동등 비교, 중복 적음</li>\n<li><strong>Using sort_union</strong>: 범위 비교, 프라이머리 키를 먼저 읽어 정렬 후 병합</li>\n</ul>\n<hr>\n<h2>25. Using temporary</h2>\n<p><strong>의미</strong>: 중간 결과를 담기 위해 임시 테이블 사용</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> employees\n<span class=\"token keyword\">GROUP</span> <span class=\"token keyword\">BY</span> gender\n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> <span class=\"token function\">MIN</span><span class=\"token punctuation\">(</span>emp_no<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>Extra</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>employees</td>\n<td>index</td>\n<td>Using temporary; Using filesort</td>\n</tr>\n</tbody>\n</table>\n<h3>임시 테이블 사용 케이스</h3>\n<p><strong>Extra에 표시되는 경우</strong></p>\n<ul>\n<li>GROUP BY와 ORDER BY 컬럼이 다를 때</li>\n</ul>\n<p><strong>Extra에 표시되지 않지만 사용하는 경우</strong></p>\n<ol>\n<li><strong>FROM 절의 서브쿼리</strong>: 파생 테이블(Derived table)은 항상 임시 테이블</li>\n<li><strong>COUNT(DISTINCT column1)</strong>: 인덱스를 사용할 수 없으면 임시 테이블</li>\n<li><strong>UNION / UNION DISTINCT</strong>: 결과 병합 시 임시 테이블 (MySQL 8.0에서 UNION ALL은 제외)</li>\n<li><strong>인덱스 없는 정렬</strong>: 정렬 버퍼도 임시 테이블과 동일</li>\n</ol>\n<h3>메모리 vs 디스크</h3>\n<p>실행 계획만으로는 임시 테이블이 메모리에 생성됐는지 디스크에 생성됐는지 알 수 없습니다.</p>\n<p><strong>상태 변수로 확인</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">STATUS</span> <span class=\"token operator\">LIKE</span> <span class=\"token string\">'Created_tmp%'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">Created_tmp_tables</code>: 생성된 임시 테이블 수</li>\n<li><code class=\"language-text\">Created_tmp_disk_tables</code>: 디스크에 생성된 임시 테이블 수</li>\n</ul>\n<h3>성능 영향</h3>\n<p>임시 테이블 생성은 부하가 크므로 다음과 같이 개선하세요:</p>\n<ol>\n<li>GROUP BY와 ORDER BY 컬럼을 동일하게</li>\n<li>인덱스 활용으로 GROUP BY/ORDER BY 처리</li>\n<li>서브쿼리를 조인으로 변경</li>\n</ol>\n<hr>\n<h2>26. Using where</h2>\n<p><strong>의미</strong>: MySQL 엔진에서 WHERE 조건 필터링 수행</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> employees\n<span class=\"token keyword\">WHERE</span> emp_no <span class=\"token operator\">&lt;</span> <span class=\"token number\">10010</span> <span class=\"token operator\">AND</span> first_name<span class=\"token operator\">=</span><span class=\"token string\">'Matt'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>key</th>\n<th>rows</th>\n<th>filtered</th>\n<th>Extra</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>employees</td>\n<td>range</td>\n<td>PRIMARY</td>\n<td>100</td>\n<td>50.00</td>\n<td>Using where</td>\n</tr>\n</tbody>\n</table>\n<h3>두 가지 의미</h3>\n<ol>\n<li><strong>스토리지 엔진에서 읽은 레코드를 MySQL 엔진에서 필터링</strong></li>\n<li><strong>일부 조건은 인덱스를 사용하지 못했음</strong></li>\n</ol>\n<h3>처리 과정</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[스토리지 엔진]\nemp_no BETWEEN 10001 AND 10100\n→ 100건 읽음\n\n[MySQL 엔진]\ngender='F' 조건 필터링\n→ 37건만 반환 (63건 버림)</code></pre></div>\n<h3>성능 판단</h3>\n<p><strong>filtered 컬럼 확인</strong></p>\n<ul>\n<li>filtered = 50%: 읽은 레코드 중 50%만 반환</li>\n<li>filtered 값이 낮을수록 비효율적</li>\n</ul>\n<p><strong>개선 방법</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 기존: emp_no만 인덱스 사용</span>\n<span class=\"token keyword\">WHERE</span> emp_no <span class=\"token operator\">BETWEEN</span> <span class=\"token number\">10001</span> <span class=\"token operator\">AND</span> <span class=\"token number\">10100</span> <span class=\"token operator\">AND</span> gender<span class=\"token operator\">=</span><span class=\"token string\">'F'</span>\n\n<span class=\"token comment\">-- 개선: 복합 인덱스 생성</span>\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">INDEX</span> idx_emp_gender <span class=\"token keyword\">ON</span> employees<span class=\"token punctuation\">(</span>emp_no<span class=\"token punctuation\">,</span> gender<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>복합 인덱스를 사용하면 두 조건 모두 작업 범위 결정 조건이 되어 필요한 37건만 정확하게 읽습니다.</p>\n<h3>주의사항</h3>\n<p><strong>Using where + type: ALL</strong></p>\n<p>이 조합은 풀 테이블 스캔이므로 반드시 개선이 필요합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> employees\n<span class=\"token keyword\">WHERE</span> first_name<span class=\"token operator\">=</span><span class=\"token string\">'Matt'</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">-- 인덱스 없음</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>Extra</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>employees</td>\n<td>ALL</td>\n<td>Using where</td>\n</tr>\n</tbody>\n</table>\n<p><strong>개선</strong>: first_name에 인덱스 추가</p>\n<hr>\n<h2>27. Zero limit</h2>\n<p><strong>의미</strong>: 메타데이터만 필요한 경우 (LIMIT 0)</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span> <span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> employees <span class=\"token keyword\">LIMIT</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>Extra</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>SIMPLE</td>\n<td>NULL</td>\n<td>NULL</td>\n<td>Zero limit</td>\n</tr>\n</tbody>\n</table>\n<p><strong>사용 목적</strong></p>\n<p>쿼리 결과값의 메타데이터만 필요한 경우:</p>\n<ul>\n<li>컬럼 개수</li>\n<li>각 컬럼의 타입</li>\n<li>컬럼 이름</li>\n</ul>\n<p>실제 테이블 레코드는 전혀 읽지 않고 메타정보만 반환합니다.</p>\n<hr>\n<h2>전체 Extra 메시지 요약</h2>\n<h3>최상 (매우 좋음)</h3>\n<table>\n<thead>\n<tr>\n<th>메시지</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Using index</td>\n<td>커버링 인덱스, 데이터 파일 안 읽음</td>\n</tr>\n<tr>\n<td>Select tables optimized away</td>\n<td>MIN/MAX 최적화, 1~2건만 읽음</td>\n</tr>\n</tbody>\n</table>\n<h3>양호 (좋음)</h3>\n<table>\n<thead>\n<tr>\n<th>메시지</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Using index condition</td>\n<td>인덱스 컨디션 푸시다운</td>\n</tr>\n<tr>\n<td>Using index for group-by</td>\n<td>루스 인덱스 스캔</td>\n</tr>\n<tr>\n<td>Using index for skip scan</td>\n<td>인덱스 스킵 스캔</td>\n</tr>\n<tr>\n<td>Using MRR</td>\n<td>디스크 접근 최적화</td>\n</tr>\n<tr>\n<td>FirstMatch / LooseScan</td>\n<td>세미 조인 최적화</td>\n</tr>\n<tr>\n<td>Distinct</td>\n<td>중복 제거 최적화</td>\n</tr>\n<tr>\n<td>Not exists</td>\n<td>안티 조인 최적화</td>\n</tr>\n</tbody>\n</table>\n<h3>보통 (확인 필요)</h3>\n<table>\n<thead>\n<tr>\n<th>메시지</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Using where</td>\n<td>필터링 수행 (filtered 값 확인)</td>\n</tr>\n<tr>\n<td>Range checked for each record</td>\n<td>레코드마다 인덱스 선택</td>\n</tr>\n</tbody>\n</table>\n<h3>나쁨 (개선 필요)</h3>\n<table>\n<thead>\n<tr>\n<th>메시지</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Using filesort</td>\n<td>정렬에 인덱스 미사용</td>\n</tr>\n<tr>\n<td>Using temporary</td>\n<td>임시 테이블 생성</td>\n</tr>\n<tr>\n<td>Using join buffer</td>\n<td>조인에 인덱스 미사용</td>\n</tr>\n<tr>\n<td>Full scan on NULL key</td>\n<td>NULL 처리로 풀 스캔</td>\n</tr>\n</tbody>\n</table>\n<h3>정보성 (문제 아님)</h3>\n<table>\n<thead>\n<tr>\n<th>메시지</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>const row not found</td>\n<td>const 테이블에 레코드 없음</td>\n</tr>\n<tr>\n<td>Impossible WHERE/HAVING</td>\n<td>조건이 항상 FALSE</td>\n</tr>\n<tr>\n<td>No tables used</td>\n<td>FROM 절 없음</td>\n</tr>\n<tr>\n<td>Plan isn't ready yet</td>\n<td>실행 계획 수립 중</td>\n</tr>\n<tr>\n<td>Zero limit</td>\n<td>LIMIT 0 사용</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>실전 튜닝 가이드</h2>\n<h3>1단계: 즉시 개선 필요 항목 확인</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> employees e\n    <span class=\"token keyword\">LEFT</span> <span class=\"token keyword\">JOIN</span> salaries s <span class=\"token keyword\">ON</span> e<span class=\"token punctuation\">.</span>emp_no<span class=\"token operator\">=</span>s<span class=\"token punctuation\">.</span>emp_no\n<span class=\"token keyword\">WHERE</span> e<span class=\"token punctuation\">.</span>first_name<span class=\"token operator\">=</span><span class=\"token string\">'Matt'</span>\n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> e<span class=\"token punctuation\">.</span>birth_date<span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>체크 포인트</strong></p>\n<ol>\n<li><strong>Using filesort</strong>: birth_date에 인덱스 필요</li>\n<li><strong>Using temporary</strong>: GROUP BY/ORDER BY 조정</li>\n<li><strong>Using join buffer</strong>: 조인 컬럼에 인덱스 필요</li>\n<li><strong>type: ALL</strong>: 테이블 풀 스캔 확인</li>\n</ol>\n<h3>2단계: 커버링 인덱스 적용 검토</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 현재</span>\n<span class=\"token keyword\">SELECT</span> emp_no<span class=\"token punctuation\">,</span> first_name<span class=\"token punctuation\">,</span> birth_date\n<span class=\"token keyword\">FROM</span> employees\n<span class=\"token keyword\">WHERE</span> first_name<span class=\"token operator\">=</span><span class=\"token string\">'Matt'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- 개선: first_name, birth_date 복합 인덱스 생성</span>\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">INDEX</span> idx_name_birth <span class=\"token keyword\">ON</span> employees<span class=\"token punctuation\">(</span>first_name<span class=\"token punctuation\">,</span> birth_date<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>결과</strong>: Using index 표시 (커버링 인덱스)</p>\n<h3>3단계: filtered 값 확인</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> employees\n<span class=\"token keyword\">WHERE</span> emp_no <span class=\"token operator\">&lt;</span> <span class=\"token number\">10100</span> <span class=\"token operator\">AND</span> gender<span class=\"token operator\">=</span><span class=\"token string\">'F'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>rows</th>\n<th>filtered</th>\n<th>실제 조인 대상</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>100</td>\n<td>50.00</td>\n<td>50건</td>\n</tr>\n<tr>\n<td>100</td>\n<td>10.00</td>\n<td>10건</td>\n</tr>\n</tbody>\n</table>\n<p>filtered 값이 낮으면 복합 인덱스 추가를 검토하세요.</p>\n<h3>4단계: 조인 순서 최적화</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- JOIN_ORDER 힌트로 조인 순서 조정</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token comment\">/*+ JOIN_ORDER(e, s) */</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> employees e<span class=\"token punctuation\">,</span> salaries s\n<span class=\"token keyword\">WHERE</span> e<span class=\"token punctuation\">.</span>first_name<span class=\"token operator\">=</span><span class=\"token string\">'Matt'</span>\n  <span class=\"token operator\">AND</span> s<span class=\"token punctuation\">.</span>emp_no<span class=\"token operator\">=</span>e<span class=\"token punctuation\">.</span>emp_no\n  <span class=\"token operator\">AND</span> s<span class=\"token punctuation\">.</span>salary <span class=\"token operator\">></span> <span class=\"token number\">50000</span><span class=\"token punctuation\">;</span></code></pre></div>\n<hr>\n<h2>최종 체크리스트</h2>\n<p>쿼리 튜닝 시 Extra 컬럼에서 확인할 항목:</p>\n<p><strong>필수 확인</strong></p>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Using filesort 있는가? → 인덱스로 정렬 가능한가?</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Using temporary 있는가? → GROUP BY/ORDER BY 최적화 가능한가?</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Using index 표시되는가? → 커버링 인덱스 적용 가능한가?</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> type: ALL + Using where인가? → 인덱스 추가 필요</li>\n</ul>\n<p><strong>추가 확인</strong></p>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Using join buffer 있는가? → 조인 컬럼에 인덱스 필요</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> filtered 값이 낮은가? → 복합 인덱스 검토</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Range checked for each record 있는가? → 조인 조건 개선</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Using MRR/ICP 사용 중인가? → 최적화 적용됨</li>\n</ul>\n<p><strong>참고 확인</strong></p>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Using index for group-by → 루스 인덱스 스캔 (양호)</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Select tables optimized away → MIN/MAX 최적화 (최상)</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> FirstMatch/LooseScan → 세미 조인 최적화 (양호)</li>\n</ul>\n<p>실행 계획을 완벽하게 이해했다면 이제 실전 쿼리 최적화를 시작하세요!</p>","wordCount":{"words":982},"frontmatter":{"title":"MySQL 실행 계획 - Extra 컬럼 (2편)","date":"October 27, 2025","description":"MySQL 실행 계획의 Extra 컬럼 - 조인 버퍼, 임시 테이블, WHERE 필터링 최적화를 알아봅니다."}},"previous":{"fields":{"slug":"/mysql-key/"},"frontmatter":{"title":"MySQL 실행 계획 - possible_keys, key, key_len, ref, rows, filtered 컬럼"}},"next":{"fields":{"slug":"/mysql-extra/"},"frontmatter":{"title":"MySQL 실행 계획 - Extra 컬럼 (1편)"}}},"pageContext":{"id":"3f933b63-ddc6-5345-af67-76703c1284e7","previousPostId":"aa1b5e74-6ee7-5bdd-99ab-4caca4c908d5","nextPostId":"daaba5ec-b28c-5b48-a042-e7b21f6d1ab4"}},"staticQueryHashes":["3257411868","3517523002"],"slicesMap":{}}