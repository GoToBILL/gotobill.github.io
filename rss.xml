<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[GoToBill's Dev Blog RSS Feed]]></title><description><![CDATA[개발 이야기를 다루는 기술 블로그]]></description><link>https://gotobill.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Sun, 21 Sep 2025 12:53:29 GMT</lastBuildDate><item><title><![CDATA[JPA @OneToOne 양방향 관계에서 발생하는 N+1 문제 해결 방법]]></title><description><![CDATA[문제 상황 User와 UserProfile이 양방향 @OneToOne 관계로 매핑되어 있을 때, User를 조회하면 UserProfile에 대한 추가 쿼리가 발생하는 N+1 문제를 겪었습니다. 문제 발생 원인 1. @OneToOne…]]></description><link>https://gotobill.github.io/oneToone/</link><guid isPermaLink="false">https://gotobill.github.io/oneToone/</guid><pubDate>Sun, 21 Sep 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;문제 상황&lt;/h2&gt;
&lt;p&gt;User와 UserProfile이 양방향 @OneToOne 관계로 매핑되어 있을 때, User를 조회하면 UserProfile에 대한 추가 쿼리가 발생하는 N+1 문제를 겪었습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// User 엔티티&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@Entity&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Id&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Long&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token annotation punctuation&quot;&gt;@OneToOne&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;mappedBy &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;user&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; fetch &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;FetchType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;LAZY&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;UserProfile&lt;/span&gt; userProfile&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// UserProfile 엔티티&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@Entity&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;UserProfile&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Id&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Long&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token annotation punctuation&quot;&gt;@OneToOne&lt;/span&gt;
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@JoinColumn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;user_id&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;User&lt;/span&gt; user&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;문제 발생 원인&lt;/h2&gt;
&lt;h3&gt;1. @OneToOne 연관관계 주인이 아닌 쪽의 프록시 생성 불가&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;핵심 문제&lt;/strong&gt;
JPA는 @OneToOne 관계에서 연관관계 주인이 아닌 쪽(mappedBy를 사용하는 쪽)은 프록시 객체를 생성할 수 없습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;User 엔티티가 로드될 때:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JPA는 UserProfile이 존재하는지 확인하기 위해 무조건 쿼리를 실행&lt;/li&gt;
&lt;li&gt;FetchType.LAZY를 설정해도 프록시 생성이 불가능하므로 의미가 없음&lt;/li&gt;
&lt;li&gt;존재하면 프록시 객체, 존재하지 않으면 null을 설정해야 하는데 이를 확인하려면 쿼리가 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2. @Data 어노테이션의 부작용&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@Data&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;// 모든 필드에 대한 getter/setter 자동 생성&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;UserProfile&lt;/span&gt; userProfile&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;주의사항&lt;/strong&gt;
@Data 어노테이션은 모든 필드에 대한 getter를 생성하므로, JSON 직렬화나 toString() 호출 시 의도치 않게 UserProfile에 접근하게 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;실제 발생한 쿼리&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;sql&quot;&gt;&lt;pre class=&quot;language-sql&quot;&gt;&lt;code class=&quot;language-sql&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;-- 1. CustomerFeedback 조회 (User JOIN FETCH 포함)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;SELECT&lt;/span&gt; cf&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; u&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; fi&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; s&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; su&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;FROM&lt;/span&gt; feedback cf
&lt;span class=&quot;token keyword&quot;&gt;LEFT&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;JOIN&lt;/span&gt; users u &lt;span class=&quot;token keyword&quot;&gt;ON&lt;/span&gt; cf&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;user_id &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; u&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;user_id
&lt;span class=&quot;token keyword&quot;&gt;LEFT&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;JOIN&lt;/span&gt; food_item fi &lt;span class=&quot;token keyword&quot;&gt;ON&lt;/span&gt; cf&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;food_id &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fi&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;food_id
&lt;span class=&quot;token keyword&quot;&gt;LEFT&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;JOIN&lt;/span&gt; store s &lt;span class=&quot;token keyword&quot;&gt;ON&lt;/span&gt; cf&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;store_id &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; s&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;store_id
&lt;span class=&quot;token keyword&quot;&gt;LEFT&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;JOIN&lt;/span&gt; survey su &lt;span class=&quot;token keyword&quot;&gt;ON&lt;/span&gt; cf&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;survey_id &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; su&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;survey_id
&lt;span class=&quot;token keyword&quot;&gt;WHERE&lt;/span&gt; cf&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;store_id &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; ? &lt;span class=&quot;token operator&quot;&gt;AND&lt;/span&gt; cf&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;is_active &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;-- 2. 각 User마다 UserProfile 조회 (N개)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;SELECT&lt;/span&gt; up&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;FROM&lt;/span&gt; user_profile up &lt;span class=&quot;token keyword&quot;&gt;WHERE&lt;/span&gt; up&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;user_id &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; ?&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;SELECT&lt;/span&gt; up&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;FROM&lt;/span&gt; user_profile up &lt;span class=&quot;token keyword&quot;&gt;WHERE&lt;/span&gt; up&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;user_id &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; ?&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;SELECT&lt;/span&gt; up&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;FROM&lt;/span&gt; user_profile up &lt;span class=&quot;token keyword&quot;&gt;WHERE&lt;/span&gt; up&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;user_id &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; ?&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;-- ... (N번 반복)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;해결 방법&lt;/h2&gt;
&lt;h3&gt;방법 1: Fetch Join에 UserProfile 포함&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@Query&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token triple-quoted-string string&quot;&gt;&quot;&quot;&quot;
    SELECT cf FROM CustomerFeedback cf
    LEFT JOIN FETCH cf.user u
    LEFT JOIN FETCH u.userProfile
    WHERE cf.store.id = :storeId
    &quot;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token class-name&quot;&gt;Page&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;CustomerFeedback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;findByStoreIdWithDetails&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@Param&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;storeId&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Long&lt;/span&gt; storeId&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Pageable&lt;/span&gt; pageable&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;방법 2: 단방향 관계로 변경&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Best Practice&lt;/strong&gt;
양방향 관계가 꼭 필요하지 않다면 단방향으로 변경하는 것이 가장 깨끗한 해결책입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@Entity&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Id&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Long&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// UserProfile 참조 제거&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token annotation punctuation&quot;&gt;@Entity&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;UserProfile&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@OneToOne&lt;/span&gt;
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@JoinColumn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;user_id&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;User&lt;/span&gt; user&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;// 단방향 관계만 유지&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;방법 3: @JsonIgnore 또는 @ToString.Exclude 사용&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@Entity&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@Getter&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@Setter&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@ToString.Exclude&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;// toString()에서 UserProfile 제외&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@OneToOne&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;mappedBy &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;user&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@JsonIgnore&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;// JSON 직렬화에서 제외&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;UserProfile&lt;/span&gt; userProfile&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;방법 4: @OneToOne 대신 @ManyToOne 사용&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@Entity&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;UserProfile&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@ManyToOne&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;// 실제로는 1:1이지만 ManyToOne으로 매핑&lt;/span&gt;
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@JoinColumn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;user_id&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; unique &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;// unique 제약조건으로 1:1 보장&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;User&lt;/span&gt; user&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;성능 비교&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;방법&lt;/th&gt;
&lt;th&gt;쿼리 수&lt;/th&gt;
&lt;th&gt;장점&lt;/th&gt;
&lt;th&gt;단점&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Fetch Join&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;한 번의 쿼리로 모든 데이터 조회&lt;/td&gt;
&lt;td&gt;페이징 시 메모리에서 처리&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;단방향 관계&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;N+1 문제 원천 차단&lt;/td&gt;
&lt;td&gt;양방향 탐색 불가&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;@JsonIgnore&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;N+1&lt;/td&gt;
&lt;td&gt;구현이 간단&lt;/td&gt;
&lt;td&gt;근본적 해결책이 아님&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;@ManyToOne&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Lazy Loading 정상 작동&lt;/td&gt;
&lt;td&gt;의미적으로 부정확&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;결론&lt;/h2&gt;
&lt;h3&gt;권장 사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;@OneToOne 양방향 관계는 가능한 피하고 단방향으로 설계&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;양방향이 필요하다면 Fetch Join 사용&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@Data 어노테이션 대신 필요한 어노테이션만 선택적으로 사용&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DTO 변환 시 필요한 필드만 명시적으로 접근&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;핵심 정리&lt;/strong&gt;
@OneToOne 양방향 관계는 JPA의 구조적 한계로 인해 N+1 문제가 발생하기 쉽습니다. 설계 단계에서부터 이를 고려하여 단방향 관계로 설계하거나, 불가피한 경우 Fetch Join을 통해 해결하는 것이 좋습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;추가 고려사항&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;캐싱 전략&lt;/strong&gt;: 자주 조회되는 UserProfile의 경우 2차 캐시 활용 고려&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;배치 페치 사이즈&lt;/strong&gt;: &lt;code class=&quot;language-text&quot;&gt;@BatchSize&lt;/code&gt; 어노테이션으로 N+1 쿼리 수 감소&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;프로젝션&lt;/strong&gt;: 필요한 필드만 조회하는 DTO 프로젝션 활용&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[네트워크 기초 정리]]></title><description><![CDATA[네트워크 서버에는 2개의 공인 IP가 있었습니다: 인바운드 IP: 외부에서 서버로 들어올 때 쓰는 IP 아웃바운드 IP: 서버에서 외부로 나갈 때 쓰는 IP…]]></description><link>https://gotobill.github.io/TCP/</link><guid isPermaLink="false">https://gotobill.github.io/TCP/</guid><pubDate>Wed, 17 Sep 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;네트워크&lt;/h2&gt;
&lt;p&gt;서버에는 2개의 공인 IP가 있었습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;인바운드 IP&lt;/strong&gt;: 외부에서 서버로 들어올 때 쓰는 IP&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;아웃바운드 IP&lt;/strong&gt;: 서버에서 외부로 나갈 때 쓰는 IP&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;노드, 네트워크, 라우터&lt;/h2&gt;
&lt;p&gt;데이터를 송수신하는 모든 장치를 &lt;strong&gt;노드&lt;/strong&gt;라고 부릅니다. 우리가 쓰는 휴대폰, 노트북, 서버 장비 등이 모두 노드에 해당합니다. 이런 각 노드가 서로 데이터를 주고받기 위해 연결된 시스템을 &lt;strong&gt;네트워크&lt;/strong&gt;라고 합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 326px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/bb40e9042d33fa7156d113367c4fd2fb/ce9b1/1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 75.9493670886076%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAABlUlEQVR42qVUy4rCQBD0w/wxr4JnTwHFg1cRPAuKV0HworCKRqJGD74RTXyb2q2WljGr4rINTaZnaqqfk0gQBDgcDrhcLjifz9jv99jtdvI11dzTNfHU4/EoNrki+JFutwvLspDP52XzEz2dThiNRnAcB7PZTGyqEDabTTmoVqvwPA9hIYHK9XqVr+u6KBQKSCaTKBaLsvdAOJ1OUa/XsVqt8E6UnFlls1mkUinkcjkhY/pC2G63EY/Hkclk4Hu+KAEUOqCzxWIhNuvn+77YjUZDgiA5M2MfIkyBoMFggOVyKZd4QACbxTrxkm3bQqTFVxwbQuFXIuQmQeFaKYjeO52OEOplxSpeJ+UXoSmMnEBGNZ/P75GFnar9NMJnQqAZ2Tvcy5QZXb/fF2UNWeN/EY7HY1QqFZnNWCyGcrn8tMYfE67Xa6TTaZRKJUSjUSQSiXtX/0RokvZ6PdRqNenyZDJ5OQWbzebhbQuh1sh8qzrE2hDzTJ8f57b11cLQHWK73d4GmwDzT8J5Cq/1PHymE8A1lY6+AbtUfhM60tHPAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;네트워크 구조&quot;
        title=&quot;&quot;
        src=&quot;/static/bb40e9042d33fa7156d113367c4fd2fb/ce9b1/1.png&quot;
        srcset=&quot;/static/bb40e9042d33fa7156d113367c4fd2fb/c26ae/1.png 158w,
/static/bb40e9042d33fa7156d113367c4fd2fb/6bdcf/1.png 315w,
/static/bb40e9042d33fa7156d113367c4fd2fb/ce9b1/1.png 326w&quot;
        sizes=&quot;(max-width: 326px) 100vw, 326px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;패킷(Packet)&lt;/h3&gt;
&lt;p&gt;노드가 네트워크를 통해 전송하는 데이터의 단위를 패킷이라고 합니다. 패킷은 헤더와 페이로드로 구성됩니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;헤더&lt;/strong&gt;: 패킷의 발신자와 수신자 정보가 들어있습니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;페이로드&lt;/strong&gt;: 실제 전송되는 데이터가 들어있습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;데이터는 일정 크기를 가진 여러 패킷으로 나뉘어 전송됩니다.&lt;/p&gt;
&lt;p&gt;네트워크의 예로 집에서 쓰는 공유기에 연결된 장치들을 들 수 있습니다. 공유기에 연결된 휴대폰이나 컴퓨터가 하나의 네트워크를 구성하죠. 마찬가지로 사무실에서 사용하는 컴퓨터들도 하나의 네트워크를 구성합니다.&lt;/p&gt;
&lt;p&gt;서로 다른 네트워크에 속한 노드는 직접 연결해서 패킷을 송수신할 수 없습니다.&lt;/p&gt;
&lt;p&gt;이때 사용되는 것이 &lt;strong&gt;라우터&lt;/strong&gt;입니다. 라우터는 네트워크 간에 패킷을 전송하는 역할을 합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 452px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/ff661b761b1304066995c38c7f19de5a/fcb94/2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 20.253164556962027%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA1klEQVR42mWQ206DQBCGeSLqBfb9Q7g2mmJRRIlE3Q0Q7C5YTmU/OxiunMkm/2y+OXrGGJIkoe975nlmmibGccRdfXEL7vrERC/LnxZOeOFEW2uROpLrpWlKGIbUdU3TNGRZxjiMtD+W58+Yonxb4/fqlaePA925oz6VPBb31G2JVprdzQ7f91FK4UmBKIqoqmr9kAZd12Hab47FA7nO6M89uXpZY9saykZzyO8oTwr1pdjvbwmCAK01nowaxzHDMKwjbytv5pz7py/zZWWElZXlFNu5fgF70Sc47UttLAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;라우터를 통한 네트워크 연결&quot;
        title=&quot;&quot;
        src=&quot;/static/ff661b761b1304066995c38c7f19de5a/fcb94/2.png&quot;
        srcset=&quot;/static/ff661b761b1304066995c38c7f19de5a/c26ae/2.png 158w,
/static/ff661b761b1304066995c38c7f19de5a/6bdcf/2.png 315w,
/static/ff661b761b1304066995c38c7f19de5a/fcb94/2.png 452w&quot;
        sizes=&quot;(max-width: 452px) 100vw, 452px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;도메인과 IP 주소&lt;/h2&gt;
&lt;p&gt;각 노드의 IP 주소를 외우기는 쉽지 않습니다. 그래서 IP 주소에 기억하기 쉬운 이름을 붙이는데, 그게 바로 &lt;strong&gt;도메인 이름&lt;/strong&gt;입니다. 도메인 이름을 IP 주소로 변환하는 체계가 &lt;strong&gt;DNS&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;p&gt;DNS를 인터넷 전화번호부라고 생각하시면 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;도메인 이름은 계층 구조를 갖습니다. 각 계층은 점(.)으로 구분되며, 오른쪽이 상위 계층이고 왼쪽이 하위 계층입니다.&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;도메인 계층 구조&lt;/h3&gt;
&lt;p&gt;가장 오른쪽이 &lt;strong&gt;최상위 계층&lt;/strong&gt;입니다. 최상위 계층에는 두 가지 종류가 있습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;일반 최상위 도메인&lt;/strong&gt;: com, org, net, gov, app, biz, tech 등&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;국가 최상위 도메인&lt;/strong&gt;: kr, jp, au, cn 등&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;일반 최상위 도메인 (예: .com)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2차 도메인이 주요 이름이 됩니다&lt;/strong&gt; (회사나 브랜드 이름)&lt;/li&gt;
&lt;li&gt;예: naver.com → naver가 2차 도메인&lt;/li&gt;
&lt;li&gt;3차부터는 용도별로 사용: cafe.naver.com, &lt;a href=&quot;http://www.google.com&quot;&gt;www.google.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;국가 최상위 도메인 (예: .kr)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2차 계층&lt;/strong&gt;까지 미리 정의되어 있습니다
&lt;ul&gt;
&lt;li&gt;ac.kr: 대학 등 교육 기관용&lt;/li&gt;
&lt;li&gt;co.kr: 기업용&lt;/li&gt;
&lt;li&gt;go.kr: 정부 기관용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;3차 계층이 주요 이름이 됩니다&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;예: gasapp.co.kr → gasapp이 주요 이름&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;DNS 작동 방식&lt;/h3&gt;
&lt;p&gt;도메인 이름에 해당하는 IP 주소는 DNS 서버를 통해 알아냅니다.&lt;/p&gt;
&lt;h4&gt;간단한 설명&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;http://www.naver.com%EC%9D%84&quot;&gt;www.naver.com을&lt;/a&gt; 브라우저에 입력하면, 브라우저가 DNS 서버한테 &quot;&lt;a href=&quot;http://www.naver.com%EC%9D%98&quot;&gt;www.naver.com의&lt;/a&gt; IP 주소가 뭐예요?&quot;라고 물어봅니다. DNS 서버는 해당 IP 주소를 알려주고, 브라우저는 그 IP 주소로 데이터를 보냅니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;1. www.naver.com의 IP 주소 요청
2. 223.130.192.248 응답
3. 데이터 전송&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;실제 DNS 조회 과정 (상세)&lt;/h4&gt;
&lt;p&gt;실제로는 여러 DNS 서버를 거쳐가며 IP 주소를 찾습니다. &lt;strong&gt;구글&lt;/strong&gt;에 접속하는 과정을 예로 들어보겠습니다:&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 482px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/a582629e39a7beedfb929d27de7ec9c4/37e0d/3.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 201.8987341772152%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEXElEQVR42p1XaXfiRhAk6wNzSUInutGJACFO23iTteO3m+Qlb///36l0j4FgO7aRP/Sb0SCVqrv6EA0vGuGlBVmFYLSEl83h5wv4tB7vA1qDfI7/e7bx7GCYI0hLaMEMPdWF5Y+gWENoTgLTz6HaCXQnhWKGUL0SfjKh5/K3Ad1hhpDe3NUDXDUvkSQZ1L4Gz/EQRTEsawCX9rLUQ1t14KdTQeJthvQ2Px7DSdcwwhn0sBSrMZzBiiroQSnOeLWzDby4+MDlnfl0Y0DuBOlEvCAuKhSztQDgs6fz4oQYHsVyby5ZlJcYTVdiL2L2ws2PAY+YMqvLqx7OL1oESGfJGO898y4gM+prNmzHx8D2aD+AE2ZvuvuuyyHFqW84aLe7WCyvsdrcQlFU9BSDfpvu3K/JkN3t6zYkqY8eGTP0oqKey+wOGzNIRjMkxRytbl/EMabrbDIXv+3v+xCQYzTwU4TZlMBm4uF9Crn0e0yKs+oDPxH2DmABh1ScVmvMlxtUFDf3DaGWFM/F6hrr6+0rlv8BDlO6OUUxmWG5XNFaijNh+3qlJA8obSazJba/3mNz8/UpyY9SqbFn5482VE4rUWZJ9ZvY2yl1nNFGAPF9lhtDM6mWNQcOhUXVXXFt2uGBaYNTxKcO0xk9Qhk/YLD4E/byL7HydSu9p5et4BNLFqYnKUhSEi+IEA4TqJqJxi+XokSfATbTB8jFPZz13zCqH/A3/6A/fcRF9A1BQSypE111ZBiGjSgmocJYmE7XX86bRwx3+eaOtzDTaxjUaUzqJGa6EatTbOGRyj7dp5k+FNWCZrjQTTLLE5WkqIMjhgdRMgQRW75bqcTY6HwvCgsS7kTg7jOk1OKz4LUoH5u/qxDLi2HYQ2TjCjbloelGz8rwJEB+gBNdJtdkRadmEcBxQ2oYvriWFPNFDE8AHGYlupKOTkdCnk8wLeeYTCtopPJVWzm4fTpDip1KOXfZ7JIojhDFoOt2VxHMX4tyonGT5RpmRk6QUe3nzzpQLUBmybFkNuXyFhF1H1acz2oDMiOFcq5Fyd2TdQycUOSk3Dcptpp4GadXDcAJBV+GJKskxhyjYirMptFwdn61Y5nXY9imRntx2aJaLmANPIRhgm5PxpczBizrAYouTgJYlMj6IBSCmE4kzKbO4yefUJlBudw4XiwKjwTeixzcVUstQE4RlRqDTMPKDVJou+Zg075WpexjqFk+ms0O0qwQvZB7YqvVFYm9H62nx5AAOXZfzi6R5WPko4kAbjTOxfxm12sB7iei1LcgESN2ndeebIiu88nSK5DTXC7KBWY0FafVij6iFgewmv2QGPoxylmF7e0Nvt7dkW2xXtN4CJNPAHIeFjfQaUwo4QLR4lHs1XhN4+Pu0CBOb1/5DN3sHp38HuHNT1g0FYPbn5Anv6OVfyfRnj6Pa/TDEsroAd38G8zqD2jld7FKxQOk8Y/DB3y9SqG/FE62gJ1UB3NS/ruxPMTwXzqpUAzdL4adAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;머메이드&quot;
        title=&quot;&quot;
        src=&quot;/static/a582629e39a7beedfb929d27de7ec9c4/37e0d/3.png&quot;
        srcset=&quot;/static/a582629e39a7beedfb929d27de7ec9c4/c26ae/3.png 158w,
/static/a582629e39a7beedfb929d27de7ec9c4/6bdcf/3.png 315w,
/static/a582629e39a7beedfb929d27de7ec9c4/37e0d/3.png 482w&quot;
        sizes=&quot;(max-width: 482px) 100vw, 482px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이 과정이 복잡해 보이지만 실제로는 1초도 안 걸립니다. 한 번 조회한 결과는 캐시에 저장되어 다음에 더 빠르게 접속할 수 있습니다.&lt;/p&gt;
&lt;p&gt;로컬에서 개발할 때 쓰는 localhost는 특별한 주소입니다. localhost의 IP 주소는 127.0.0.1입니다.&lt;/p&gt;
&lt;p&gt;이건 &lt;strong&gt;루프백 주소&lt;/strong&gt;라고 해서 자기 자신을 가리킬 때 쓰는 IP 주소입니다.&lt;/p&gt;
&lt;h3&gt;hosts 파일&lt;/h3&gt;
&lt;p&gt;모든 컴퓨터는 hosts 파일을 가지고 있습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;리눅스&lt;/strong&gt;: &lt;code class=&quot;language-text&quot;&gt;/etc&lt;/code&gt; 디렉토리에 있습니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;윈도우&lt;/strong&gt;: &lt;code class=&quot;language-text&quot;&gt;C:\Windows\System32\drivers\etc&lt;/code&gt; 디렉토리에 있습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;도메인 이름과 IP 주소 개수&lt;/h3&gt;
&lt;p&gt;하나의 도메인에 여러 IP 주소가 매핑될 수 있습니다. nslookup 명령어로 확인해볼 수 있습니다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;$ &lt;span class=&quot;token function&quot;&gt;nslookup&lt;/span&gt; www.naver.com
&lt;span class=&quot;token punctuation&quot;&gt;..&lt;/span&gt;.
Address: &lt;span class=&quot;token number&quot;&gt;223.130&lt;/span&gt;.192.248
Address: &lt;span class=&quot;token number&quot;&gt;223.130&lt;/span&gt;.192.247
Address: &lt;span class=&quot;token number&quot;&gt;223.130&lt;/span&gt;.200.219
Address: &lt;span class=&quot;token number&quot;&gt;223.130&lt;/span&gt;.200.236&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;한 도메인에 IP 주소를 여러 개 매핑하는 이유 중 하나는 &lt;strong&gt;부하 분산&lt;/strong&gt; 때문입니다.&lt;/p&gt;
&lt;h2&gt;고정 IP와 동적 IP&lt;/h2&gt;
&lt;p&gt;같은 네트워크에서 각 노드는 서로 다른 IP 주소를 가져야 합니다. IP 주소로 패킷을 보낼 노드를 구분하기 때문에, 같은 IP 주소를 가진 노드가 있으면 IP 충돌이 일어납니다.&lt;/p&gt;
&lt;p&gt;노드의 IP 주소는 2가지 방식으로 지정합니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;고정 IP&lt;/strong&gt;: 노드가 고정된 IP를 갖습니다. 서버 IP가 대표적이죠.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;동적 IP&lt;/strong&gt;: 노드가 네트워크에 연결할 때마다 IP를 할당받습니다. DHCP(Dynamic Host Configuration Protocol) 서버가 이걸 담당합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;DHCP 서버&lt;/h2&gt;
&lt;h4&gt;DHCP 동작 과정 (DORA)&lt;/h4&gt;
&lt;p&gt;DHCP는 &lt;strong&gt;브로드캐스팅&lt;/strong&gt;을 통해 IP를 할당받습니다. 이 과정을 &lt;strong&gt;DORA&lt;/strong&gt;라고 부르는데, 각 단계의 앞글자를 딴 것입니다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;D - Discover (발견)
O - Offer (제안)
R - Request (요청)
A - Acknowledgment (확인)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;상세한 DHCP 과정&lt;/h4&gt;
&lt;p&gt;노트북을 WiFi에 연결하는 상황을 예로 들어보겠습니다:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;① DHCP Discover - &quot;DHCP 서버 어디있어요?&quot;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;노트북: &quot;저 IP가 없는데 누가 좀 줘요!&quot; (브로드캐스트)
발신: 0.0.0.0 (아직 IP가 없음)
수신: 255.255.255.255 (네트워크 전체에 외침)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;② DHCP Offer - &quot;내가 줄 수 있어&quot;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;공유기(DHCP 서버): &quot;192.168.0.105 쓸래?&quot;
제안 내용:
- IP 주소: 192.168.0.105
- 서브넷 마스크: 255.255.255.0
- 게이트웨이: 192.168.0.1
- DNS: 8.8.8.8
- 임대 시간: 24시간&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;③ DHCP Request - &quot;그거 주세요!&quot;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;노트북: &quot;네, 192.168.0.105 주세요!&quot; (브로드캐스트)
→ 여러 DHCP 서버가 있을 수 있어서 가장 먼저 응답을 주는 DHCP 서버를 선택
→ 브로드 캐스팅으로 알림

메시지 내용:
- Transaction ID: 이전 DHCP 메시지와 동일한 ID
- DHCP Message Type: REQUEST
- Requested IP Address (Option 50): 192.168.0.105
- DHCP Server Identifier (Option 54): 선택한 서버의 IP&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;④ DHCP ACK - &quot;자, 여기 있어&quot;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;공유기: &quot;확인! 192.168.0.105는 24시간 동안 네 거야&quot;
→ 이제 노트북은 정식으로 IP를 받음&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;브로드캐스팅이란?&lt;/h4&gt;
&lt;p&gt;브로드캐스팅은 네트워크의 모든 기기에게 동시에 메시지를 보내는 방식입니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;유니캐스트&lt;/strong&gt;: 1:1 통신 (특정 IP로 전송)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;브로드캐스트&lt;/strong&gt;: 1:전체 통신 (255.255.255.255로 전송)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;멀티캐스트&lt;/strong&gt;: 1:그룹 통신 (특정 그룹에만 전송)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;애니캐스트&lt;/strong&gt;: 1:가장 가까운 1개 (같은 IP를 가진 여러 서버 중 가장 가까운 곳으로)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;애니캐스트 예시:&lt;/strong&gt;
CDN이나 DNS 루트 서버가 애니캐스트를 사용합니다. 예를 들어 구글 DNS(8.8.8.8)는 전 세계에 수백 개 서버가 있는데, 모두 같은 IP를 갖습니다. 한국에서 8.8.8.8에 접속하면 한국에서 가장 가까운 서버로 자동 연결됩니다.&lt;/p&gt;
&lt;p&gt;DHCP가 브로드캐스트를 쓰는 이유는 간단합니다. &lt;strong&gt;아직 IP가 없는 기기는 DHCP 서버가 어디 있는지 모르기 때문입니다&lt;/strong&gt;. 그래서 &quot;야! 다들 들어봐! 나 IP 필요해!&quot;라고 네트워크 전체에 외치는 거죠.&lt;/p&gt;
&lt;h4&gt;IP 임대 시간과 갱신&lt;/h4&gt;
&lt;p&gt;DHCP로 받은 IP는 영구적이지 않습니다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;임대 시간&lt;/strong&gt;: 보통 24시간 (설정 가능)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;50% 시점&lt;/strong&gt;: 12시간 지나면 갱신 시도&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;87.5% 시점&lt;/strong&gt;: 갱신 실패 시 다시 시도&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;만료&lt;/strong&gt;: 새로 DHCP Discover부터 다시 시작&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이렇게 임대 방식을 쓰는 이유는 한정된 IP 주소를 효율적으로 관리하기 위해서입니다.&lt;/p&gt;
&lt;h2&gt;공인 IP와 사설 IP&lt;/h2&gt;
&lt;p&gt;웹 브라우저에 &lt;a href=&quot;http://www.google.com%EC%9D%B4%EB%82%98&quot;&gt;www.google.com이나&lt;/a&gt; &lt;a href=&quot;http://www.daum.net&quot;&gt;www.daum.net&lt;/a&gt; 같은 도메인을 입력하면 DNS 서버에서 IP 주소를 받아와서 접속합니다. 이때 사용하는 IP 주소는 인터넷 어디서든 접근 가능한 &lt;strong&gt;공인(public) IP&lt;/strong&gt; 주소입니다.&lt;/p&gt;
&lt;p&gt;모든 네트워크에서 쓸 수 있는 공인 IP와 달리, 네트워크 내부에서만 쓰는 &lt;strong&gt;사설(private) IP&lt;/strong&gt; 주소도 있습니다. 사설 IP는 특정 네트워크 안에서만 유효하고 외부에서는 접근할 수 없습니다.&lt;/p&gt;
&lt;p&gt;사설 IP로 쓸 수 있는 주소 범위입니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;192.168.x.x&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;10.x.x.x&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;172.16.x.x ~ 172.31.x.x&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;공인 IP 알아내기&lt;/h3&gt;
&lt;p&gt;간단한 방법은 &lt;a href=&quot;https://ifconfig.me&quot;&gt;https://ifconfig.me&lt;/a&gt; 같은 사이트에 접속해서 확인하는 겁니다.&lt;/p&gt;
&lt;p&gt;리눅스에서도 아래 명령어로 공인 IP 주소를 확인할 수 있습니다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;curl&lt;/span&gt; ifconfig.me&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;NAT&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;NAT&lt;/strong&gt;(Network Address Translation, 네트워크 주소 변환)는 네트워크 주소를 변환하는 기술입니다. 인터넷에 연결하려면 내부의 사설 IP와 인터넷의 공인 IP 간 변환이 필요한데, NAT가 이걸 처리합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SNAT(Source NAT)&lt;/strong&gt;: 나가는 패킷의 출발지 변경 (AWS NAT Gateway)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 546px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/188f0abb2526b60722a87f39da470064/76aed/4.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 20.253164556962027%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAArklEQVR42n1PSwqFMAzs/W/iPYQiupVurYiKFrX+6n8kActbvcDQpDNJJkJKiSAIcF0XfuM8TyzLwu+/IH7fd9z3zbVQSiGKIgzDgHVdMc8zoyxLxHEMYww30HDnnMc4jpimibVt26LvezYlwjBkh9ZaHpLnObquQ13XSNOUc2rSWqNpGlRVxRrS0iLi6I8WbNsGkWUZkiRhu8/zeOvkoigKf/LHESj/cByHP5vqF1oVMOfdhmVmAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;snat&quot;
        title=&quot;&quot;
        src=&quot;/static/188f0abb2526b60722a87f39da470064/76aed/4.png&quot;
        srcset=&quot;/static/188f0abb2526b60722a87f39da470064/c26ae/4.png 158w,
/static/188f0abb2526b60722a87f39da470064/6bdcf/4.png 315w,
/static/188f0abb2526b60722a87f39da470064/76aed/4.png 546w&quot;
        sizes=&quot;(max-width: 546px) 100vw, 546px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DNAT(Destination NAT)&lt;/strong&gt;: 들어오는 패킷의 목적지 변경 (AWS ALB/NLB)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 585px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/a4481de1170d3cb90af544093f05083a/78a22/5.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 22.78481012658228%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABD0lEQVR42m2QO0vDYBSG8y/FzcnB0sWli876A6qT4g2hZlAkBLEQbAdBx1iNRggkqIm532+E5LXfgXZQH3j5DnzwnJfDFUWBqqrA6Lpumd/UdQ3P8yi6rsP8svDwMcVIOcCtdo2rt3NcqmfgBEGAJEl/JGxJkiQIwxBZlpGwaRqaXc9F7McYPu5iY7yC7Wkfg7t19Mar4DRNg6qqsG0bQRAgiiLEcUwi13UhyzKJ0zQlaZ7nJGZ8p59QXBnvvgLVf6ZwPM9DFEXabFkWSVg7dgomNwyD5rIs0bbtMozT2T7681Y79wNsTXrYlNbAmaYJx3HwH2wJ+1s0WjC/Mr0T4wbHT0OMXg5x8XqEk9kefgCC/Wt7WiNwEgAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;snat&quot;
        title=&quot;&quot;
        src=&quot;/static/a4481de1170d3cb90af544093f05083a/78a22/5.png&quot;
        srcset=&quot;/static/a4481de1170d3cb90af544093f05083a/c26ae/5.png 158w,
/static/a4481de1170d3cb90af544093f05083a/6bdcf/5.png 315w,
/static/a4481de1170d3cb90af544093f05083a/78a22/5.png 585w&quot;
        sizes=&quot;(max-width: 585px) 100vw, 585px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;DNAT는 서버 구성할 때 많이 씁니다. 보통 보안이나 이중화를 위해 서버는 사설 IP를 쓰고, 공인 IP는 라우터나 방화벽 같은 네트워크 장비에 할당합니다.&lt;/p&gt;
&lt;h2&gt;VPN&lt;/h2&gt;
&lt;p&gt;백엔드 서버를 개발하고 운영하다 보면 서버나 DB에 접속할 일이 많습니다. SSH로 서버에 접속해서 프로세스를 확인하거나 OS 설정을 바꿔야 할 때도 있고, DB에 접속해서 SQL을 실행해야 할 때도 있죠.&lt;/p&gt;
&lt;p&gt;서버 네트워크의 노드에 안전하게 접근하려면 &lt;strong&gt;VPN&lt;/strong&gt;(Virtual Private Network, 가상 사설 네트워크)을 사용합니다. VPN은 인터넷 같은 공용 네트워크에서 서로 다른 네트워크 간에 암호화된 연결을 제공합니다.
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/1a31889900d9f6791e839395c7e1c624/084e2/6.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 36.075949367088604%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABbklEQVR42pWRzU/bQBDF898iOCCOqEVCOfeAeoRDb0gVl0oETkCBEFBBlUyRFSikxCSQKCTGGyfO2t71/vCazwOXjjSat6vRm3lvSsYYXjLLMrJn/FHY/yRJMNpwJ9octnZxOscc5bXR/0umMkpKKXq9Ho1GAxEIxpMRnf4tD0MfOZFIKYnjmCiKCEKfrn+HSQ1Vb4v5vSmWTsp82p/mx8UqZFCykx3HYXNzg+t/TUIpODzb5bzp4jU96vU6rptj74aLG5eD023EUPD79ogvvz7zzfma1wW2ritPhFprWq0W1WoVIUQuW+MHAyYywm4fhiFBEGD7ZDzBHw5AQc3bYfFglqXjMuXaHJXLtSdC69t4PC5kt9ttup0uWulXX9/7Z3tTlRbvmvezkGolL+zPULlae5NsG+02NgsyLNHbsV6IjclyP2WB6/0/rLrLrF9+z+tKcRj0M+H/hB2apgkjMaLfHdDr3BNHCTrVKK14BN1nBmPVDY7wAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;snat&quot;
        title=&quot;&quot;
        src=&quot;/static/1a31889900d9f6791e839395c7e1c624/f058b/6.png&quot;
        srcset=&quot;/static/1a31889900d9f6791e839395c7e1c624/c26ae/6.png 158w,
/static/1a31889900d9f6791e839395c7e1c624/6bdcf/6.png 315w,
/static/1a31889900d9f6791e839395c7e1c624/f058b/6.png 630w,
/static/1a31889900d9f6791e839395c7e1c624/084e2/6.png 632w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;개발자는 VPN 클라이언트로 VPN에 접속할 수 있습니다. 집이나 카페에서 서버 네트워크에 접근해야 할 때 이 방식을 씁니다.&lt;/p&gt;
&lt;h2&gt;프로토콜과 TCP, UDP, QUIC&lt;/h2&gt;
&lt;p&gt;네트워크에서 두 노드가 데이터를 주고받기 위해 정한 규칙을 &lt;strong&gt;프로토콜&lt;/strong&gt;(protocol)이라고 합니다. 네트워크는 여러 계층으로 구성되고 각 계층마다 사용하는 프로토콜이 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP/IP 모델의 계층별 프로토콜&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;애플리케이션 계층: HTTP, FTP, SMTP&lt;/li&gt;
&lt;li&gt;전송 계층: TCP, UDP&lt;/li&gt;
&lt;li&gt;네트워크 계층: IP&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;TCP (Transmission Control Protocol)&lt;/h3&gt;
&lt;p&gt;TCP는 연결 기반 프로토콜입니다. 전화 통화처럼 먼저 연결을 맺고 나서 데이터를 주고받습니다. TCP에서 두 노드가 연결을 맺는 과정을 &lt;strong&gt;3-Way Handshake&lt;/strong&gt;라고 부릅니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 288px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/cb29290e24696aca7edccfca61f34e87/477c9/7.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 101.26582278481011%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAABq0lEQVR42pWUaavCMBBF/f8/SEFQUUE/+EXrgoIK7rjv+zKPM5CSatOngdCSSU7u3BkS22w2UqlUpN1uS6fTkapXleVyKYzX6yVRg33NZlMOh4O/P7ZarcTzPBmPxzIajRS83+8DB9kYBl+v19Lr9YJAs3GxWEir1dL/5/MZgLnG8XiURqMR2OcD+/2+JJNJhXGjWecQMdsGE0NhJpMJiPCBg8FACoWC/m+3W8EKvlhRr9dlOp1+KMb/XC7nBhaLxUCQ7+l0kvP5rHBU4i+qjcJsNhsOJC0DfDweoZ6xlwuwxPiXSqXcQJMyQdYp1GQyUQBqUGgO3m436Xa7bg/fgUzaiPXZbKYdUC6X9RL8vVwu6mtkygZ4v981bQ6RGubzNet2UZxAipJIJOR6vWpqpAgEqKsXI4EojMfjkUX5GZhOpzWAKkxnUFVi+GYX7CtgPp/3+4u52+10nQeAav+s8L2xKQITlTQ0l9DgxldUf93YYYVgHSuA0pu1Wi26sd8V/vd8zedzt0LeNbuxo4b92jiBw+FQSqXSV0D7gf0AmiDmY/YvgzNU2n5g/wCoNQWFHlgvlQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;3handshake&quot;
        title=&quot;&quot;
        src=&quot;/static/cb29290e24696aca7edccfca61f34e87/477c9/7.png&quot;
        srcset=&quot;/static/cb29290e24696aca7edccfca61f34e87/c26ae/7.png 158w,
/static/cb29290e24696aca7edccfca61f34e87/477c9/7.png 288w&quot;
        sizes=&quot;(max-width: 288px) 100vw, 288px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;클라이언트 → 서버: SYN (Seq=1000)
서버 → 클라이언트: SYN-ACK (Seq=3000, Ack=1001)
클라이언트 → 서버: ACK (Seq=1001, Ack=3001)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Seq와 Ack가 뭔가요?&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Seq(Sequence Number)&lt;/strong&gt;: &quot;내가 보내는 데이터의 번호&quot;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ack(Acknowledgment Number)&lt;/strong&gt;: &quot;다음에 받고 싶은 상대방 데이터의 번호&quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예를 들어 서버가 &lt;code class=&quot;language-text&quot;&gt;Ack=1001&lt;/code&gt;을 보내면 &quot;클라이언트님, 1000번까지 잘 받았고 이제 1001번 주세요&quot;라는 의미입니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/b2b62ce43413961e186c907eaabc0bb5/e51a6/8.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 58.86075949367089%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAPoAAAD6AG1e1JrAAABOUlEQVR42nWSO0/EMBCE7/+XlPwACgoKGiQKaJGQ6GhoqMiLKE6c+JnH8fmSs0w4rMTZjHdmZ20fjucxjVPXdc654z9jWZa2bb33ETnwDtqzYIxRSmmtQbyfslLEJBKY0UV9JYtO8QTyw1tZVG1a5P0ju7q+iwVvnj7xlSbc3r88Pr8GMtWstcxCiKqqkOcXIzG173sQKSUJZVlikFWMBDKRnxbrx6+8lIMiZpAdyUY7wF6ZrKi0pacFkIQzeXbWm7zKhRTjMlrv1uY3slGAvZbFd8FMrJ3dyKntuq5X27/Ip8qYojIGV/ACOfackrUesCZVt1YOvmJlPgi7caJnrWwU3m0YM+eMNQKktw1j4dRn6LluGlTDk1T+e3M47XmeA5mtj7abpkF+Zzt1EeU4kcNF4R2YXskU+QFmPrlMmnHaUgAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;3handshake&quot;
        title=&quot;&quot;
        src=&quot;/static/b2b62ce43413961e186c907eaabc0bb5/f058b/8.png&quot;
        srcset=&quot;/static/b2b62ce43413961e186c907eaabc0bb5/c26ae/8.png 158w,
/static/b2b62ce43413961e186c907eaabc0bb5/6bdcf/8.png 315w,
/static/b2b62ce43413961e186c907eaabc0bb5/f058b/8.png 630w,
/static/b2b62ce43413961e186c907eaabc0bb5/e51a6/8.png 783w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP/1.0&lt;/strong&gt;: 매 요청마다 새로운 TCP 연결을 맺어야 했습니다 (Connection: close가 기본값)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP/1.1&lt;/strong&gt;: &lt;strong&gt;Keep-Alive&lt;/strong&gt;로 하나의 TCP 연결을 재사용할 수 있게 되었습니다 (Connection: keep-alive가 기본값)&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/d835a9de463d539b677b5f425319b517/4ff83/9.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 70.88607594936708%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC80lEQVR42nVT7UtTURh/pm6uzTXnptO0uc05w2KmVzOxvJR7ueqducEg0BD6MKms8A03W50PGUzUypDKNLRSkQmWEZElXqfLCGYYmFIhfZD+jtt92co5euDynHvOc37Py+93AKKGI7HQjkyiGmQES89xMPvyoRbxHkAQieK8mEQaqEGlYPUYwOorEtl8BQC0AGKsEImg7IoSKjoywIoMYO7WwCmPnvv2G+aWcGA2pIUznXlQfl0LrkAi7M3aNRaSETefjbY+mNdFD6ZDW49nNna97Jqi6CTWXxx4VWzrmRhDFMX9uxASTa59fze5vuvkLiGaTmD9RPBr1a3p5VDLvZfaKODMyrf50dWfPCDNAz5aWG/xPl96y0BxFXkeTimmVre+jHzcqYupUGH2y7nZAEqItCXkWlHWy/bGqS0oA872ZP9tv75LBsWXcwGIZH5jhLm4eV8Dy3350DZoALQpguZxMSCmpQaPEpo6pFwcxextP9LCh7t6aH9iBJyp2B0WskdSu1eNud1CHpBm2PkxlAz+brnE0Ztlta6lYY5gViW5qjGQczhHAGuBQGLur3Fx+jBKkTtelMgbgyWp5xdNxY4V4nDD7Lk44gDHkzB85IgfC2vCWWEJDUz2Oo8CSCTZ2zLQIGgtnXOismBVR/kS1mheqdbbZ53xgC5GNnW92TC4dgAuvVFkO6gcVcMUFq3wN+NpQ2fehqnd2IaNnggVbMteY2E+GdMyN/NYbWFC/OSw4X3B+qEBjFIFsB15afVTfbRCmhEuzRDWZOmQphDe9Mi8BP8HLHSJgPRr4MJnJTRTqcDqzjGUwwhcHjsaJAaWaV50vCJqUSaQkVmzWWl9t3zx2DW1/XS/LoBvpjRVLGQ4zZ/yjfaZSrD5jsYBkkgVA0jcyIs8UUYNgJLo3M7MoKlV56gcLJor21KiwoCIPZOwme131DGkWPqlQKAcHi8CaL+tg/o+2f73KQRrW1rMZQIdjGOZuJr8Ly4yQ7JdxVTOvaQ/bznqEwV5Wg0AAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;파이프라이닝&quot;
        title=&quot;&quot;
        src=&quot;/static/d835a9de463d539b677b5f425319b517/f058b/9.png&quot;
        srcset=&quot;/static/d835a9de463d539b677b5f425319b517/c26ae/9.png 158w,
/static/d835a9de463d539b677b5f425319b517/6bdcf/9.png 315w,
/static/d835a9de463d539b677b5f425319b517/f058b/9.png 630w,
/static/d835a9de463d539b677b5f425319b517/4ff83/9.png 843w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;파이프라이닝 없음&lt;/strong&gt;: 요청을 보내고 응답을 받은 후에야 다음 요청을 보낼 수 있습니다&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt; (요청-응답-요청-응답)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;파이프라이닝 있음&lt;/strong&gt;: 응답을 기다리지 않고 여러 요청을 연속으로 보낼 수 있습니다&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(요청-요청-요청 → 응답-응답-응답)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그렇지만 파이프 라이닝은 일부 패킷이 유실되면 그 패킷이 도착할 때까지 이후 패킷을 처리하지 못하는 &lt;strong&gt;HOL 블로킹&lt;/strong&gt;(Head-of-Line Blocking) 문제가 있습니다.&lt;/p&gt;
&lt;h2&gt;HTTP/2.0&lt;/h2&gt;
&lt;h3&gt;바이너리 프레이밍&lt;/h3&gt;
&lt;p&gt;HTTP/1.x는 Plain Text(평문)를 사용하고 개행으로 구별했지만, HTTP/2.0에서는 &lt;strong&gt;바이너리 포맷&lt;/strong&gt;으로 인코딩된 Message, Frame으로 구성됩니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/ca41c32e632a7d7081411873edec7de2/33e10/10.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 51.26582278481012%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAPoAAAD6AG1e1JrAAABeElEQVR42nWSbW+CMBRG/f+/QedkIRFkb06NsinC2AYWrOI0qCBFMaB+UBeX6D7MXYEQE7OTJzftbU/apE1JHFu5vuJzuXI2I+bzgUPW6/U2hBDiuu72H3zfT+HqHXqitNJN6zHXe2adQd+27WMIQohhGI7joBYKhWaz+RaCdRVWN5tNSpfqQ100sTTQm5+txtwl0I1kVVXT6TRFUTRNQy0Wi5IkaZqG0fvvfnuSMcbtEDgH6mKxSGTYBxrLsmDyPC/LsqIo0OzqrViufhh1fZRkMp1H8u7wjdp6JQQurJ1hGMbvz+4kl5DFSP0cj+h6u4w9y1smsud54/HYu2C1WsUy99G41UQIo77ct+XhjCSyO8LTnrCyFNIRJl1hMXqHMWRJBrFc7skPXYF+LRY0vmaptu8m8sxUAqMMQZWMXs1inoqmBNdiGV5sc8bhcIjkr/3ONeW9I0Ic5a4v0n6nFE2Xdit+quMF0I2+wcyxiNm5zHRiwmoQBH+BSft2wJ+BfgAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;HTTP/2 바이너리 프레이밍&quot;
        title=&quot;&quot;
        src=&quot;/static/ca41c32e632a7d7081411873edec7de2/f058b/10.png&quot;
        srcset=&quot;/static/ca41c32e632a7d7081411873edec7de2/c26ae/10.png 158w,
/static/ca41c32e632a7d7081411873edec7de2/6bdcf/10.png 315w,
/static/ca41c32e632a7d7081411873edec7de2/f058b/10.png 630w,
/static/ca41c32e632a7d7081411873edec7de2/33e10/10.png 844w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP/2의 구성 요소:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Stream&lt;/strong&gt;: 구성된 연결 내에서 전달되는 바이트의 양방향 흐름, 하나 이상의 메시지가 전달 가능합니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Message&lt;/strong&gt;: 논리적 요청 또는 응답 메시지에 매핑되는 프레임의 전체 시퀀스입니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Frame&lt;/strong&gt;: HTTP/2에서 통신의 최소 단위. 각 최소 단위에는 하나의 프레임 헤더가 포함됩니다. 이 프레임 헤더는 최소한으로 프레임이 속하는 스트림을 식별합니다. &lt;strong&gt;HEADERS Type Frame, DATA Type Frame&lt;/strong&gt;이 존재합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/15.gif&quot; alt=&quot;HTTP/2 멀티플렉싱 애니메이션&quot;&gt;&lt;/p&gt;
&lt;p&gt;위처럼, 하나의 커넥션에서 여러 병렬 스트림(3개)이 동시에 존재할 수 있습니다. 각 스트림의 프레임들이 뒤섞여서 전송되더라도, Stream Number를 통해 어떤 스트림에 속하는지 식별하여 정확하게 재조립됩니다.&lt;/p&gt;
&lt;h3&gt;HTTP/2의 한계: TCP HOL 블로킹&lt;/h3&gt;
&lt;p&gt;HTTP/2는 응용 계층에서의 HOL 블로킹을 해결했지만, &lt;strong&gt;TCP 레벨에서는 여전히 문제가 있습니다&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;계층별 동작 이해:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;네트워크는 계층으로 나뉘어 동작합니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;응용 계층 (HTTP/2)&lt;/strong&gt;: 프레임과 스트림으로 멀티플렉싱 구현&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;전송 계층 (TCP)&lt;/strong&gt;: 순서를 보장하는 바이트 스트림 전송&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HTTP/2의 모든 스트림은 결국 &lt;strong&gt;하나의 TCP 연결&lt;/strong&gt;을 통해 전송됩니다. TCP는 HTTP/2의 스트림 개념을 모르고, 단지 순서대로 바이트를 전달할 뿐입니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;실제 예시: 10MB 이미지 + 1KB CSS 파일 요청&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;HTTP/1.1 (순차 처리):
1. 10MB 이미지 요청 → 완료 (10초)
2. 1KB CSS 요청 → 완료 (0.1초)
총 시간: 10.1초

HTTP/2 (멀티플렉싱):
1. 10MB 이미지 + 1KB CSS 동시 요청 (프레임 교대로 전송)
2. CSS는 1초 만에 완료 (이미지 중간에 끼워서 전송)
3. 이미지는 10초 만에 완료
총 시간: 10초 (CSS는 1초에 완료!)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/16.gif&quot; alt=&quot;HTTP/2 한계&quot;&gt;&lt;/p&gt;
&lt;p&gt;HTTP/2는 하나의 TCP 연결만 사용하기 때문에, 패킷 하나만 유실되어도 &lt;strong&gt;모든 스트림이 영향을 받습니다&lt;/strong&gt;. 오히려 HTTP/1.1이 여러 TCP 연결을 사용할 때보다 더 심각할 수 있죠.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP 패킷 손실 시나리오:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;TCP 패킷: [1][2][3][4][5][6][7][8][9][10]
                ↑
           3번 패킷 유실!

TCP 패킷 손실 발생:
HTTP/1.1: 모든 데이터 정지 
HTTP/2: 모든 스트림 정지 

결과: 패킷 4~10번이 도착해도 처리 못함
→ TCP가 3번을 기다리느라 모든 HTTP/2 스트림이 멈춤&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Stream 우선순위&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84.gif&quot; alt=&quot;우선순위&quot;&gt;&lt;/p&gt;
&lt;p&gt;HTTP 메시지가 많은 개별 프레임으로 분할될 수 있고 여러 스트림의 프레임을 다중화(Multiplexing)할 수 있게 되면서, &lt;strong&gt;스트림들의 우선순위를 지정할 필요가 생겼습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;클라이언트는 우선순위 지정을 위해 &apos;우선순위 지정 트리&apos;를 사용하여 서버의 스트림 처리 우선순위를 지정할 수 있습니다. &lt;strong&gt;서버는 우선순위가 높은 응답이 클라이언트에 우선적으로 전달될 수 있도록 대역폭을 설정합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;HTTP 헤더 압축 (HPACK)&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/32365d82b3ad2829ce14a7bbe090d7e3/4ff83/12.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 83.54430379746836%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAPoAAAD6AG1e1JrAAACmUlEQVR42o2S60/aYBTG+38bF6Nyk4soVUAolksBC1haoBer406FgCAIODbnzGS4uJBliW5+2NwDOOe+6E7enLxpz+885/ISvV6v1WoNBoO7u7v7J/brj93c3DQajW63e3Fxcf+vERzHURRlMpkMBkOiqngz0YC6y9X2q9WqJEmapqXTaZZl19fXLRbL6uoq7rjAy7JMMAwD2G63G41Gpig4U0FKZcOlFKRA9vt9ZAkEAiRJOhwOq9WKYJvN5vP5ksnkBPZ4PPiq1+sBu0Rmkw8Brtfr2WwWBefz+RkMxmw2A4Oy1+t9gP1+P5Tn5uasYeeC22IObVijrk6nc3l5ORqNeJ4PhwI4JoNOv7ykW1pcXHhlWTFFIiFCEIRUKkXTNMrmT/JeOeKWwkInf3V19XNqo48ffpznv7/PVUUqGyebe4G3ldiRQtfzwkQZVaHm+fl5ktvW+dYMtGODp9EwRnJ4eAjlCBP0uF0rRj0EjbpleOgndxNEMBjcnJpOpwOzlthGCt9+rN1uFwoF+EqlgqE4nU60Bg1429QmPauqirnPZk6GqbiaThYkuZYbDoffpoZXgLh4PI4YrBM+FothweVymXjc+NnZWTQavX/WsC2k+/tIsEm012w2sU9sBTrIcnt7+xiBF1adGuavKAoawWX22ghVO45IRXdEYMTcVjQl105xxGp/PB7P4OHoc0brucI8u6dRMXFHqcx86ahH4Adz0LJHRFqp2UPpeKkvt0fS8SesagZ/GX+tnbzL1dra8Ztysw+m2OhWWqcng/MJjGiQSOHiciS75xVK4WzzEX7GHmBfuhKQax6+CB7iT5VfgIXGORjwKBtH74mKreF/wTuZ1042Y/PFKO7AEUzibCVUNnt0fX39IvwblxYUZWSHwBIAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;HTTP 헤더 압축&quot;
        title=&quot;&quot;
        src=&quot;/static/32365d82b3ad2829ce14a7bbe090d7e3/f058b/12.png&quot;
        srcset=&quot;/static/32365d82b3ad2829ce14a7bbe090d7e3/c26ae/12.png 158w,
/static/32365d82b3ad2829ce14a7bbe090d7e3/6bdcf/12.png 315w,
/static/32365d82b3ad2829ce14a7bbe090d7e3/f058b/12.png 630w,
/static/32365d82b3ad2829ce14a7bbe090d7e3/4ff83/12.png 843w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이전 Header의 내용과 중복되는 필드를 재전송하지 않도록 하여 데이터를 절약합니다. 기존에 HTTP Header가 Plain Text(평문)이었지만, HTTP/2에서는 &lt;strong&gt;Huffman Coding&lt;/strong&gt;을 사용하는 &lt;strong&gt;HPACK&lt;/strong&gt;이라는 Header 압축방식을 이용하여 데이터 전송 효율을 높였습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Huffman Coding&lt;/strong&gt;: 데이터 문자의 빈도에 따라서 다른 길이의 부호를 사용하는 알고리즘&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP의 장점은 신뢰성&lt;/strong&gt;입니다. 패킷 순서를 보장하고 패킷이 유실되면 재전송해줘서 &lt;strong&gt;안정적으로 데이터를 전송할 수 있습니다.&lt;/strong&gt; 그래서 &lt;strong&gt;HTTP, SMTP&lt;/strong&gt; 같은 많은 프로토콜이 TCP를 기반으로 동작합니다.&lt;/p&gt;
&lt;p&gt;하지만 시퀀스 번호, 확인 응답, 재전송 같은 기능 때문에 &lt;strong&gt;UDP보다는 느립니다.&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;UDP (User Datagram Protocol)&lt;/h3&gt;
&lt;p&gt;TCP와 달리 UDP는 연결 과정 없이 바로 데이터를 보냅니다. &lt;strong&gt;데이터가 제대로 전송됐는지도 모르고, 순서도 보장하지 않습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;UDP를 쓰는 애플리케이션은 데이터가 유실될 수 있다고 가정하고 개발해야 합니다.&lt;/p&gt;
&lt;p&gt;UDP는 응답 확인이나 패킷 정렬 같은 과정이 없어서 &lt;strong&gt;TCP보다 빠릅니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;그래서 속도가 중요하거나 약간의 데이터 유실이 괜찮은 통신에 씁니다. &lt;strong&gt;DNS, VoIP, 게임 등이 UDP를 사용하는 대표적인 예입니다.&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;QUIC&lt;/h3&gt;
&lt;p&gt;TCP는 신뢰성이 있지만 느립니다. UDP는 빠르지만 신뢰성이 없죠. 이 둘의 장점을 합친 프로토콜이 &lt;strong&gt;QUIC&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;p&gt;QUIC은 UDP를 기반으로 하면서 TCP의 연결 관리 기능을 프로토콜 수준에서 제공합니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;데이터에 연결 ID&lt;/strong&gt;(Connection ID)를 포함시켜 연결을 유지합니다&lt;/li&gt;
&lt;li&gt;TCP의 혼잡 제어나 패킷 유실 복구 기능을 QUIC에서 제어합니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TLS를 통합해서 기본적으로 암호화됩니다&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;멀티플렉싱으로 한 연결에서 여러 스트림을 동시에 처리합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;HTTP/3&lt;/h3&gt;
&lt;p&gt;HTTP/3 프로토콜은 QUIC을 기반으로 사용합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP/3는 TCP를 버리고 UDP 위에 QUIC을 만들었습니다:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;HTTP/1.1: 여러 TCP 연결 (한 연결 막혀도 다른 연결은 OK)
HTTP/2:  하나의 TCP 연결 (패킷 하나 유실 → 전체 멈춤)
HTTP/3:  QUIC 스트림들 (각 스트림이 독립적으로 동작!)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;QUIC의 독립적인 스트림:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Stream 1: 패킷 유실 → Stream 1만 대기
Stream 2: 정상 진행 ✓
Stream 3: 정상 진행 ✓&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;각 QUIC 스트림이 &lt;strong&gt;자체적으로 순서 보장과 재전송을 처리&lt;/strong&gt;하기 때문에, 한 스트림의 패킷 유실이 다른 스트림에 영향을 주지 않습니다. 마치 여러 개의 독립적인 TCP 연결을 쓰는 것처럼요!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;현재 지원 현황:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;브라우저&lt;/strong&gt;: 크롬, 에지, 사파리 등 주요 브라우저&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;기업&lt;/strong&gt;: 구글, 페이스북 등 주요 기업&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CDN&lt;/strong&gt;: 아카마이, 클라우드플레어, AWS 클라우드프론트 등&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;TCP 연결은 65,535개가 한계인가?&lt;/h3&gt;
&lt;p&gt;포트 번호는 부호 없는 16비트 정수를 씁니다. 그래서 65,535가 포트 번호의 최대값입니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;하지만&lt;/strong&gt; 한 장비에서 만들 수 있는 TCP 연결 개수는 이론적으로 &lt;strong&gt;2^96개&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;p&gt;TCP의 각 연결은 다음 4가지 조합으로 구분되거든요:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;로컬 IP&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;로컬 포트&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;원격 IP&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;원격 포트&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;하나의 로컬 IP에서 특정 원격 IP의 1개 포트에 연결할 수 있는 TCP 연결이 65,535개인 겁니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;실제로는 OS 설정(파일 디스크립터 개수, 포트 범위 설정 등)에 따라 제약을 받습니다.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[Blocking & Non-Blocking I/O로 성능 개선하기]]></title><description><![CDATA[I/O 병목, 어떻게 해결할까? 서버 프로그램은 기본적으로 네트워크 프로그램입니다. 서버는 다양한 구성요소와 네트워크를 통해 데이터를 주고받죠.  많은 서버는 HTTP 프로토콜을 이용해서 클라이언트와 데이터를 주고받습니다. 데이터 처리를 위해 DB…]]></description><link>https://gotobill.github.io/non-blocking/</link><guid isPermaLink="false">https://gotobill.github.io/non-blocking/</guid><pubDate>Mon, 15 Sep 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;I/O 병목, 어떻게 해결할까?&lt;/h2&gt;
&lt;p&gt;서버 프로그램은 기본적으로 네트워크 프로그램입니다. 서버는 다양한 구성요소와 네트워크를 통해 데이터를 주고받죠.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 411px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/555f83330e8aeb3301ec6d97a00198b6/2a432/1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 37.34177215189873%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAyElEQVR42oWR2QqEMAxF+//f6IsgIlrRLu5LhpMh89gJhKZp7jFc3XVdEkKUvu9lGLzM8yzrusp93xJj1DqlpPWyLL83m0sp6/u+75ruPE/puk6qqpK6rhWMENE4jpJzFu+99hFy37ZN7wCZIYGhc8/zCFAAJDU9gvM4DhUCoaaH+H1fPZknreekEAwQJrIeYuBsZMlHsa8ItO1DCOqhbc/Ztq2CsQnLgGFHEfj9YUGaplERtW1qAKxgO/P9L5DNMH2aJgXSK8UH9/Ih5gePnMAAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;서버는 다양한 구성요소와 네트워크로 데이터를 주고받습니다&quot;
        title=&quot;&quot;
        src=&quot;/static/555f83330e8aeb3301ec6d97a00198b6/2a432/1.png&quot;
        srcset=&quot;/static/555f83330e8aeb3301ec6d97a00198b6/c26ae/1.png 158w,
/static/555f83330e8aeb3301ec6d97a00198b6/6bdcf/1.png 315w,
/static/555f83330e8aeb3301ec6d97a00198b6/2a432/1.png 411w&quot;
        sizes=&quot;(max-width: 411px) 100vw, 411px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;많은 서버는 HTTP 프로토콜을 이용해서 클라이언트와 데이터를 주고받습니다. 데이터 처리를 위해 DB를 사용하는데, DB는 TCP에 기반한 프로토콜을 사용해서 데이터를 주고받죠. 레디스를 메모리 캐시로 사용할 때도 네트워크를 통해 데이터를 주고받습니다. 서버 API를 만들 때 개발자가 직접 네트워크 프로그램을 작성하지는 않지만, 서버는 네트워크 통신을 기반으로 동작합니다.&lt;/p&gt;
&lt;p&gt;네트워크를 통해 데이터를 주고받는 과정은 간단하게 다음 두 줄로 정리할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;outputStream&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 출력 스트림으로 데이터 보내기&lt;/span&gt;
inputStream&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 입력 스트림으로 데이터 받기&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;예를 들어 SELECT 쿼리를 실행한다고 해보겠습니다. 서버는 DB와 연결된 출력 스트림을 이용해서 DB에 SELECT 쿼리를 전송합니다. 그리고 DB가 보내는 데이터를 입력 스트림을 통해서 받죠.&lt;/p&gt;
&lt;p&gt;이때 데이터를 보내고 받는 동안 코드를 실행하는 스레드는 데이터 전송이 완료될 때까지 대기하게 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 249px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/90cbe4b350e82531d400f0629f9246b1/6a5fb/2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 134.81012658227846%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAAACXBIWXMAAAsTAAALEwEAmpwYAAACLklEQVR42qVV2Y7CMAzs//8VL4hDQghxtaV3S0/uo9xexmxWLQuFQiQraUIm9nhsJHowLpcLbTYbiqKI0jSlMkO6B8IAmKIo1Gw2KQiC3FkpwOzF9XrNwGWHlAWCnc9n/ka4sDLeFXro+z65rvtv/9UDDLharWg0GtF8PqfhcMiGkLG/3W7Lc4hLYRgyiKZpNB6PaTqdUpzEvLfb7Rh8v98zrzgT1LwdsqXZZCo2g/f7fer1epQkCT+I9eFweC8pl/MNMHRi8vXw6n2aOy+dFPq9E9ghjTWfQwQQwkWYx+ORvYOJNc4w43eFgIERUhzHJMsyixxZV1WVDd/tdpsTCAoqlQrn4imHWQ9Pp1POQ3wLD4UhcYUehk5EwRMOX+oQL0AemOER1qZqkdbTuZYHgwGHNZlMOEzYvWzEI5Ios1qtxtVRr9ep1WrRbDajZJKw2JfLJXOJzrNYLHj9zEspJ5mrgR8Mz/LI1V1+rNvtUqfTYSDDMDgpbwv7j0M7Il8LmAIhDTwmknLPaS7kIh2m6fa7fvgHaEGH0U2HikyNRoNs2+bSQ8jgGTRAh5ZlceLAb7GHesA/gqGOkX0kSDQI7IuOhDXoeM6hG7OHWR1+1WBN9Rpe32DtOY7D2YWE0DcRciEgQOAuZpFRcJfECYem6zqZpsmhom96nlcMCBFD/dBctVplwgVfH3VsUfSYUQ2YUTVorkLojzT3FoeiAsATpJLd+ygp4jK4g4dl/0Z/ABM2M9t2Z0MqAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;입출력(I/O)을 진행하는 동안 스레드는 대기합니다&quot;
        title=&quot;&quot;
        src=&quot;/static/90cbe4b350e82531d400f0629f9246b1/6a5fb/2.png&quot;
        srcset=&quot;/static/90cbe4b350e82531d400f0629f9246b1/c26ae/2.png 158w,
/static/90cbe4b350e82531d400f0629f9246b1/6a5fb/2.png 249w&quot;
        sizes=&quot;(max-width: 249px) 100vw, 249px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;데이터 입출력이 완료될 때까지 스레드는 아무 작업도 하지 않습니다. 즉 입출력이 끝날 때까지 스레드가 &lt;strong&gt;블로킹(blocking)&lt;/strong&gt; 됩니다. 보통 입출력에 소요되는 시간은 코드를 실행하는 시간보다 훨씬 깁니다. 서버처럼 네트워크 연동이 많은 프로그램은 전체 실행 시간의 90% 이상을 입출력 대기에 사용하는 경우도 있죠.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!NOTE]
제가 실행 시간을 측정한 API 중 하나는 전체 실행 시간이 800ms였는데, 이 중 CPU 사용 시간은 4ms에 불과했습니다. 전체 실행 시간의 99.5%가 쿼리 실행이나 외부 API 호출 같은 I/O 처리에 사용된 것이죠. 3초 가까이 실행되는데 CPU 사용 시간이 고작 5ms였던 경우도 있었습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;[!TIP]
&lt;strong&gt;블로킹(blocking)이란?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;작업이 완료될 때까지 스레드가 대기하는 것을 블로킹이라고 합니다. 주로 데이터 입출력 과정에서 블로킹이 발생합니다. 입출력 과정에서 블로킹이 발생하기 때문에 이런 방식을 블로킹 I/O라고도 부르죠.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;스레드가 대기하는 데 시간을 소요한다는 것은, 그 스레드를 실행하는 CPU도 아무것도 하지 않는 시간이 생긴다는 의미입니다. CPU 사용률을 높이려면 CPU가 실행할 스레드를 많이 만들면 됩니다. &lt;strong&gt;요청 당 스레드(thread per request)&lt;/strong&gt; 방식으로 구현한 서버가 이에 해당합니다. 동시에 실행되는 스레드 개수를 늘려 I/O 대기에 따른 CPU 낭비를 줄일 수 있죠.&lt;/p&gt;
&lt;p&gt;하지만 스레드를 생성하는 데는 한계가 있습니다. 스레드는 수백 KB에서 수 MB의 메모리를 사용합니다. 커넥션 당 스레드 방식으로 구현한 웹소켓 서버에 1만 명의 사용자가 동시에 연결했다고 하면, 스레드 1만 개를 생성하는 것만으로 사용하는 메모리는 10GB에 육박합니다. 사용자가 증가하면 메모리가 병목이 되는 것이죠.&lt;/p&gt;
&lt;p&gt;메모리를 늘려 스레드를 많이 만들 수 있게 되더라도 여전히 문제는 남습니다. 바로 &lt;strong&gt;컨텍스트 스위칭&lt;/strong&gt;입니다. 동시에 실행되는 스레드가 증가하면 컨텍스트 스위칭에 사용되는 시간도 증가합니다. 컨텍스트 스위칭에 들어가는 시간은 짧지만, 동시 실행되는 스레드가 많아지면 CPU 효율에 영향을 줍니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!INFO]
&lt;strong&gt;컨텍스트 스위칭이란?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;운영체제는 여러 스레드를 번갈아 가면서 CPU에 할당합니다. 한 스레드를 짧은 시간 동안 실행하고 다음 스레드를 짧은 시간 실행하는 식이다. CPU가 스레드를 전환하려면 현재 실행 중인 스레드의 상태를 기록하고 다음에 실행할 스레드의 상태 정보를 불러와야 한다. 이렇게 상태 정보를 변경하고 스레드를 전환하는 과정을 컨텍스트 스위칭(context switching)이라고 한다.&lt;/p&gt;
&lt;p&gt;컨텍스트 스위칭은 마이크로초 단위로 실행되지만 컨텍스트 스위칭을 하는 동안 CPU는 실질적인 작업을 하지 않는다. 그래서 동시에 실행되는 프로세스와 스레드가 많으면 컨텍스트 스위칭에 소요되는 시간도 무시하기 힘들 만큼 커질 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;정리하면 트래픽이 증가하면 다음 2가지 이유로 자원 효율이 떨어지게 된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I/O 대기와 컨텍스트 스위칭에 따른 CPU 낭비&lt;/li&gt;
&lt;li&gt;요청마다 스레드를 할당함으로써 메모리 사용량이 높음&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;여기까지 보면 왜 톰캣처럼 요청마다 스레드를 할당하는 서버를 사용하는지 궁금한 독자도 있을 것이다. 서버는 DB나 API 호출 같은 입출력 처리가 많고, 이는 톰캣 같은 서버를 사용하면 CPU와 메모리 낭비가 많다는 것을 뜻하기 때문이다.&lt;/p&gt;
&lt;p&gt;그런데 다수의 서비스는 서버의 자원 낭비를 걱정할 필요가 없다. CPU와 메모리 사용에 영향을 줄 만큼 트래픽이 발생하지 않기 때문이다. 수백만 또는 수천만 이상의 고객이 사용할 정도로 인기 있는 서비스가 아니면 CPU와 메모리 자원 부족보다는 다른 이유로 성능 문제가 발생할 때가 많다.&lt;/p&gt;
&lt;p&gt;서비스가 인기를 끌기 시작하면 트래픽이 증가하고 이때부터 처리량을 더 높이기 위한 방법을 고민하면 된다. 가장 쉬운 방법은 2장에서 살펴본 것처럼 서버를 수평 확장하거나 수직 확장해서 자원을 더 확보하는 것이다. 이 방법은 비교적 쉽게 달성할 수 있다. 기존 프로그램을 수정하지 않아도 되기 때문이다. 하지만 서버를 확장하는 것은 비용과 직결된다. 클라우드 환경에서 가상화 서버를 2개에서 4개로 늘리면 비용도 두 배가 된다.&lt;/p&gt;
&lt;p&gt;서버 성능을 높이는 또 다른 방법은 자원 효율을 높이는 것이다. I/O 대기로 인한 CPU 낭비를 줄이고 요청을 처리하는데 필요한 메모리를 줄이는 것이다. 이를 위한 방법으로는 다음 2가지를 꼽을 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가상 스레드나 고루틴 같은 경량 스레드 사용&lt;/li&gt;
&lt;li&gt;논블로킹 또는 비동기 I/O 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;두 방식을 적절히 사용하면 CPU와 메모리 자원을 늘리지 않고도 더 많은 트래픽을 처리할 수 있다. 이 장에서는 이 2가지 방식에 대해 차례대로 살펴볼 것이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Memo&lt;/strong&gt;&lt;br&gt;
성능을 높이겠다고 처음부터 비동기 I/O로 개발하거나 가상 스레드를 적용하지는 말자. 실제로 I/O 성능을 높여야 할 만큼 트래픽이 증가하고 있거나 예상되는 트래픽이 높은 경우에만 적용 여부를 고민하자.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;가상 스레드로 자원 효율 높이기&lt;/h2&gt;
&lt;p&gt;코드를 블로킹 I/O로 작성했는데, 입출력 동안 스레드가 대기하지 않고 다른 일을 할 수 있다면 얼마나 좋을까? 만약 이게 가능하다면 CPU의 유휴 시간이 줄어들고, 더 많은 작업을 처리할 수 있게 된다. 게다가 개발자는 성능을 높이기 위해 별도의 기술을 쓰지 않아도 된다. 이렇게 특별한 노력 없이 CPU 효율을 높일 수 있는 방법이 있다. 바로 자바의 가상 스레드나 Go 언어의 고루틴을 사용하는 것이다. 이 둘을 사용하면 앞서 말한 효과를 얻을 수 있다.&lt;/p&gt;
&lt;p&gt;언어는 다르지만, 가상 스레드와 고루틴은 경량(lightweight) 스레드라는 공통점을 갖는다. 경량 스레드는 OS가 관리하는 스레드가 아니라 JVM(자바 가상 머신) 같은 언어의 런타임이 관리하는 스레드다. 마치 OS가 CPU로 실행할 스레드를 스케줄링 하듯, 언어 런타임이 OS 스레드로 실행할 경량 스레드를 스케줄링한다.&lt;/p&gt;
&lt;p&gt;![그림 7.3 JVM은 가상 스레드를 스케줄링한다](JVM 스케줄링 다이어그램)&lt;/p&gt;
&lt;p&gt;이 책에서는 필자가 익숙한 자바를 기준으로 설명하겠다. [그림 7.3]에서 보는 것처럼 JVM은 플랫폼 스레드(OS 스레드에 1:1로 대응하는 래퍼(wrapper))로 구성된 풀을 유지한다. CPU가 OS 스케줄러에 의해 여러 스레드를 번갈아 실행하는 것처럼 플랫폼 스레드도 JVM 스케줄러에 의해 여러 가상 스레드를 번갈아 실행한다. JVM은 기본적으로 풀에 CPU 코어 개수만큼 플랫폼 스레드를 생성하고 필요에 따라 플랫폼 스레드를 증가시킨다. 이 책을 쓰는 시점에서 풀에 최대로 생성할 수 있는 플랫폼 스레드 개수의 기본값은 256이다.&lt;/p&gt;
&lt;p&gt;가상 스레드를 경량 스레드라고 부르는 이유는 플랫폼 스레드보다 더 적은 자원을 사용하기 때문이다. 우선 가상 스레드는 플랫폼 스레드(즉 OS 스레드)보다 더 적은 메모리를 사용한다. 1만 개의 플랫폼 스레드를 생성해야 한다고 가정해보자. 스레드의 기본 스택 크기가 1MB일 때 10,000MB(약 9.8GB)의 메모리를 사용한다. 물론 이는 예약한(reserved) 메모리 기준이며 실제 사용하는 committed 메모리는 이보다 작다. 하지만 예약한 메모리라고 하더라도 상당량이 필요한 것을 알 수 있다.&lt;/p&gt;
&lt;p&gt;가상 스레드는 훨씬 적은 메모리를 사용한다. 가상 스레드 1개가 평균적으로 2KB의 메모리를 사용한다고 했을 때, 1만 개 가상 스레드가 사용하는 힙 메모리는 약 20MB 정도이다. 여기에 스케줄링을 위한 플랫폼 스레드가 8개라고 하면 추가로 8MB의 스택 메모리를 사용한다. 즉 1만 개 가상 스레드를 실행하기 위해 28MB의 메모리(힙 메모리 20MB와 스택 메모리 8MB)를 사용하는 것이다. 앞서 플랫폼 스레드 1만 개를 만들기 위해 사용된 메모리 크기(9.8GB)와 비교하면 300배 넘게 차이가 난다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;알아두기 가상 스레드와 메모리&lt;/strong&gt;&lt;br&gt;
가상 스레드는 수백 바이트에서 수KB~수십KB의 힙 메모리를 사용한다. 호출 스택의 깊이에 따라 사용하는 메모리를 동적으로 늘렸다가 줄인다. Go 언어의 고루틴도 동일한 방식으로 동작한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;스레드를 생성하는 시간도 차이가 많이 납니다. 얼마나 차이가 나는지 궁금해서 다음 코드를 만들어서 측정해봤습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token class-name&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; threads &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;100_000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 10만 개&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; start &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; threads&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 가상 스레드는 Thread.ofVirtual()로 생성&lt;/span&gt;
&lt;span class=&quot;token class-name&quot;&gt;Thread&lt;/span&gt; thread &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;ofPlatform&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;token class-name&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;InterruptedException&lt;/span&gt; e&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
e&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
threads&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; thread&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; end &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;제가 사용하는 노트북 기준으로 10만 개의 스레드를 생성하고 시작하는데 걸린 시간은 평균적으로 다음과 같았는데 거의 100배 이상 차이가 나는 것을 확인할 수 있었습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;플랫폼 스레드: 21,467ms&lt;/li&gt;
&lt;li&gt;가상 스레드: 196ms&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이처럼 가상 스레드는 플랫폼 스레드에 비해 훨씬 적은 비용(자원, 시간)이 들기 때문에 한 장비에서 수십만에서 백만 개에 이르는 가상 스레드를 생성할 수 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!NOTE]
제가 사용하는 노트북에서 가상 스레드 100만 개는 생성할 수 있었지만 플랫폼 스레드 100만 개를 생성하는 데는 실패했습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이는 톰캣처럼 요청별 스레드(thread per request)를 생성하는 서버에서 가상 스레드를 사용하면 더 적은 메모리로 더 많은 요청을 처리할 수 있다는 것을 뜻합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;알아두기 캐리어(carrier) 스레드&lt;/strong&gt;&lt;br&gt;
가상 스레드를 실행하는 플랫폼 스레드를 캐리어 스레드라고 표현한다. CPU가 여러 스레드를 실행하는 것처럼, 한 개의 캐리어 스레드도 여러 가상 스레드를 실행하게 된다. 특정 가상 스레드가 특정 캐리어 스레드에 연결되는 것을 마운트(mount)되었다고 표현한다. 가상 스레드가 캐리어 스레드에 마운트되면 가상 스레드가 실행된다. 반대로 가상 스레드가 캐리어 스레드로부터 언마운트(unmount)되면 가상 스레드는 실행을 멈춘다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;네트워크 I/O와 가상 스레드&lt;/h3&gt;
&lt;p&gt;가상 스레드는 실행하는 과정에서 블로킹되면 플랫폼 스레드와 언마운트되고 실행이 멈춘다. 이때 언마운트된 플랫폼 스레드는 실행 대기 중인 다른 가상 스레드와 연결된 뒤 실행을 재개한다. [그림 7.4]는 이 스케줄링 과정을 간단하게 표현한 것이다.&lt;/p&gt;
&lt;p&gt;![그림 7.4 가상 스레드가 블로킹되면 플랫폼 스레드는 실행할 가상 스레드를 변경한다](가상 스레드 스케줄링 다이어그램)&lt;/p&gt;
&lt;p&gt;[그림 7.4]에서 플랫폼 스레드 1은 먼저 가상 스레드 1을 실행한다. 가상 스레드 1이 I/O 대기와 같은 블로킹 연산을 만나면, 플랫폼 스레드 1은 가상 스레드 1의 블로킹이 끝날 때까지 기다리지 않고 실행 가능한 다른 가상 스레드를 찾아서 연결한다. 이런 방식으로 플랫폼 스레드 2는 가상 스레드 2를 실행했다가, 가상 스레드 3을 실행하고 다시 가상 스레드 1을 실행하게 된다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;알아두기 블로킹 연산과 synchronized&lt;/strong&gt;&lt;br&gt;
블로킹 연산에는 I/O 기능, ReentrantLock, Thread.sleep() 등이 포함된다. 이들 연산을 사용해서 가상 스레드가 블로킹되면, 플랫폼 스레드는 대기 중인 다른 가상 스레드를 실행한다. 반면에 자바 23 또는 이전 버전에서 synchronized로 인해 블로킹되면, 가상 스레드는 플랫폼 스레드로부터 언마운트되지 않는다. 즉, 플랫폼 스레드도 같이 블로킹된다. 이렇게 가상 스레드가 플랫폼 스레드까지 블로킹할 때 이를 가상 스레드가 플랫폼 스레드에 고정됐다고 한다.&lt;/p&gt;
&lt;p&gt;자바 21 기준으로 synchronized 외에도 JNI 호출 등 가상 스레드가 플랫폼 스레드에 고정되는 경우가 있는데, 가상 스레드가 고정되면 CPU 효율을 높일 수 없다. 가상 스레드를 사용할 때는 이점에 유의하자.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;가상 스레드와 성능&lt;/h3&gt;
&lt;p&gt;우리가 작성하는 코드는 크게 I/O 중심(I/O-bound) 작업과 CPU 중심(CPU-bound) 작업으로 나눌 수 있다. 네트워크 프로그래밍처럼 입출력이 주를 이루는 작업은 I/O 중심 작업에 해당한다. 반대로 정렬처럼 계산이 주를 이루는 작업은 CPU 중심 작업에 해당한다.&lt;/p&gt;
&lt;p&gt;이 두 작업 중 가상 스레드는 I/O 중심 작업일 때 효과가 있다. I/O는 가상 스레드가 지원하는 블로킹 연산이므로, I/O 중심 작업일 때 플랫폼 스레드가 CPU 낭비 없이 효율적으로 여러 가상 스레드를 실행할 수 있다.&lt;/p&gt;
&lt;p&gt;CPU 중심 작업에 가상 스레드를 사용하면 성능 개선 효과를 얻을 수 없다. 오히려 성능이 나빠질 수도 있다. 사용자가 업로드한 이미지의 썸네일을 생성해주는 서버를 생각해보자. 이미지 연산은 전형적인 CPU 중심 작업이다. 이미지를 처리하는 코드에는 블로킹 연산이 없다. 블로킹 연산이 없으므로 이미지 연산을 실행하는 동안 플랫폼 스레드는 계속 1개의 가상 스레드만 실행하게 된다. 가상 스레드를 많이 생성하더라도 동시 실행 효과를 얻을 수 없는 것이다.&lt;/p&gt;
&lt;p&gt;또한 I/O 중심 작업이라고 해서 무조건 가상 스레드의 이점을 얻는 것은 아니다. 스케줄링에 사용되는 플랫폼 스레드 개수보다 가상 스레드의 개수가 많아야 효과를 기대할 수 있다. 예를 들어 다음과 같은 상황을 가정해보자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장비 CPU 코어는 16개다.&lt;/li&gt;
&lt;li&gt;서버의 평소 TPS는 500이다.&lt;/li&gt;
&lt;li&gt;1개 요청을 처리하는데 소요되는 시간은 20밀리초이다.&lt;/li&gt;
&lt;li&gt;모든 요청은 I/O 중심 작업이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;단순 계산하면 1개의 스레드는 1초 동안 약 50개의 요청을 처리할 수 있으므로 1초에 500개 요청을 처리하려면 10개의 스레드가 필요하다. 즉, 동시에 10개 요청을 처리할 수 있으면 된다.&lt;/p&gt;
&lt;p&gt;이 서버에 가상 스레드를 사용하면 다음과 같이 오히려 플랫폼 스레드가 더 많이 생기는 상황이 벌어진다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;플랫폼 스레드는 기본으로 16개가 생긴다(CPU 코어 개수가 16개).&lt;/li&gt;
&lt;li&gt;동시 요청은 10개이므로 동시에 생성되는 가상 스레드는 10개다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;동시에 10개의 가상 스레드가 실행되지만 I/O 중심 작업이기 때문에 대부분 시간이 I/O 대기 상태에 있다. 플랫폼 스레드는 실행 중인 가상 스레드가 I/O 대기로 블로킹되면 실행할 수 있는 다른 가상 스레드를 찾는다. 그런데 대부분의 가상 스레드가 I/O 대기 중이라 실행할 수 있는 가상 스레드가 많지 않다. 결과적으로 플랫폼 스레드 16개 중 실제로 사용되는 스레드는 10개도 안 된다. 이렇게 되면 가상 스레드의 이점을 얻을 수 없다. 가상 스레드는 플랫폼 스레드보다 개수가 많을 때 효과가 있기 때문이다.&lt;/p&gt;
&lt;p&gt;가상 스레드의 이점을 얻으려면 CPU 코어 수를 줄이거나 트래픽이 더 많아져야 한다. 클라우드 환경을 사용한다면 CPU 코어를 16개에서 4개로 줄이고 메모리도 줄여서 더 적은 비용으로 같은 트래픽을 처리할 수 있다. 동시에 필요한 스레드가 100개에서 1000개 이상이 될 정도로 트래픽이 증가해도 가상 스레드의 이점을 얻을 수 있다. 같은 CPU와 메모리로 처리량을 10배 늘릴 수 있는 것이다.&lt;/p&gt;
&lt;p&gt;가상 스레드를 사용해서 높일 수 있는 것은 처리량이다. 가상 스레드를 사용한다고 해서 실행 속도가 플랫폼 스레드보다 더 빨라지지는 않는다. 이는 당연한 일이다. 플랫폼 스레드나 가상 스레드나 결국 실행하는 것은 같은 CPU이기 때문이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;알아두기 가상 스레드와 스레드 풀&lt;/strong&gt;&lt;br&gt;
요청별 스레드 방식을 사용하는 서버는 스레드 풀을 사용할 때가 많다. 미리 스레드를 생성해서 요청이 들어왔을 때 스레드 생성 부하를 줄이기 위함이다. 또한 스레드 풀 크기에 최대치를 설정해서 요청이 급격히 늘어나도 스레드가 무한정 생성되는 것을 막는다. CPU와 메모리 같은 자원을 일정 수준으로 제한해서 서버 자원이 포화되는 것을 방지하려는 목적이다.&lt;/p&gt;
&lt;p&gt;가상 스레드는 플랫폼 스레드보다 생성 비용이 적기 때문에 스레드 풀을 미리 구성할 필요가 없다. 필요한 시점에 가상 스레드를 생성하고 필요 없으면 제거하면 된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;가상 스레드의 중요한 장점&lt;/h3&gt;
&lt;p&gt;가상 스레드의 중요한 장점은 기존 코드를 크게 수정할 필요가 없다는 것이다. 스프링 프레임워크나 MySQL JDBC 드라이버 같은 많이 사용하는 프레임워크와 라이브러리도 이미 가상 스레드를 지원하고 있다. 따라서 조금만 신경쓰면 기존 코드를 그대로 유지하면서도 가상 스레드를 이용해서 버의 성능을 높일 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;날로 먹지 못한 아쉬움&lt;/strong&gt;&lt;br&gt;
예전에 서버의 성능을 높이기 위해 구현 방식을 완전히 바꾼 적이 있다. 이 서버는 클라이언트별 스레드 방식으로 구현된 간단한 소켓 서버였다. 이 소켓 서버는 클라이언트에 푸시를 보내기 위해 연결을 유지했다. 사용자가 적을 때는 문제가 안 됐는데 연결된 클라이언트가 증가하면서 일부 클라이언트와의 연결이 비정상으로 동작하는 문제가 발생했다.&lt;/p&gt;
&lt;p&gt;문제를 해결하기 위해 논블로킹 I/O를 사용해서 다시 구현했다. 성능이 수십 배 좋아졌고 문제가 해결됐다. 하지만 좋아진 성능을 제대로 쓰지는 못했다. 왜냐면 조금만 성능을 높이면 됐기 때문이다. 만약 이때 가상 스레드가 있었다면 재구현할 생각은 하지 않았을 것이다. 플랫폼 스레드를 생성하는 대신 가상 스레드를 생성하도록 기존 코드를 변경만 하면 성능 문제를 해결할 수 있었기 때문이다. 지금 생각해도 이점이 많이 아쉽다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;논블로킹 I/O로 성능 더 높이기&lt;/h2&gt;
&lt;p&gt;가상 스레드와 고루틴과 같은 경량 스레드를 사용하면 I/O 중심 작업을 하는 서버의 처리량을 높일 수 있다고 설명했다. 하지만 경량 스레드 자체도 메모리를 사용하고 스케줄링이 필요하다. 경량 스레드가 많아질수록 더 많은 메모리를 사용하고 스케줄링에 더 많은 시간을 사용하게 된다.&lt;/p&gt;
&lt;p&gt;사용자가 폭발적으로 증가하면 어느 순간 경량 스레드로도 한계가 온다. 이때는 서버의 I/O 구현 방식을 구조적으로 변경해야 한다. 바로 논블로킹 I/O를 사용해야 하는 것이다.&lt;/p&gt;
&lt;p&gt;논블로킹 I/O는 새로운 것이 아니다. 오래전부터 네트워크 서버의 성능을 높이기 위해 사용한 방식이다. 여기에 비동기 API를 곁들이면 덜 복잡한 코드로 높은 성능을 낼 수 있다. 실제로 Nginx, Netty, Node.js 등 서버에서 많이 사용하는 기술은 성능을 위해 논블로킹 I/O를 사용한다.&lt;/p&gt;
&lt;h3&gt;논블로킹 I/O 동작 개요&lt;/h3&gt;
&lt;p&gt;논블로킹 I/O는 입출력이 끝날 때까지 스레드가 대기하지 않는다. 예를 들어 다음 코드에서 &lt;code class=&quot;language-text&quot;&gt;channel.read()&lt;/code&gt; 코드는 데이터를 읽을 때까지 대기하지 않는다. &lt;code class=&quot;language-text&quot;&gt;channel.read()&lt;/code&gt; 코드는 읽을 데이터가 없으면 바로 0을 리턴한다. 이는 데이터를 읽을 때까지 대기하는 블로킹 I/O와는 동작 방식이 다르다.&lt;/p&gt;
&lt;p&gt;// channel: SocketChannel, buffer: ByteBuffer
int byteReads = channel.read(buffer); // 데이터를 읽을 때까지 대기하지 않음
// 읽은 데이터가 없어도 다음 코드 계속 실행&lt;/p&gt;
&lt;p&gt;text&lt;/p&gt;
&lt;p&gt;데이터를 조회했는지 여부에 상관없이 대기하지 않고 바로 다음 코드를 실행하므로 블로킹 I/O처럼 데이터를 조회했다는 가정 하에 코드를 작성할 수 없다. 대신 루프 안에서 조회를 반복해서 호출한 뒤 데이터를 읽었을 때만 처리하는 방식으로 구현할 수 있다.&lt;/p&gt;
&lt;p&gt;// CPU 낭비가 심한 방식
while (true) {
int byteReads = channel.read(buffer);
if (byteReads &gt; 0) {
handleData(channel, buffer);
}
}&lt;/p&gt;
&lt;p&gt;text&lt;/p&gt;
&lt;p&gt;하지만 위 코드처럼 작성하면 CPU 낭비가 심하다. 읽은 데이터가 없어도 while 루프가 무한히 실행되기 때문이다. 실제로 논블로킹 I/O를 사용할 때는 데이터 읽기를 바로 시도하기보다는 어떤 연산을 수행할 수 있는지 확인하고 해당 연산을 실행하는 방식으로 구현한다. 실행 흐름은 대략 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;실행 가능한 I/O 연산 목록을 구한다(실행 가능한 연산을 구할 때까지 대기).&lt;/li&gt;
&lt;li&gt;1에서 구한 I/O 연산 목록을 차례대로 순회한다.
A. 각 I/O 연산을 처리한다.&lt;/li&gt;
&lt;li&gt;이 과정을 반복한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;다음은 이 방식으로 구현한 간단한 예제 코드다.&lt;/p&gt;
&lt;p&gt;Selector selector = Selector.open();
ServerSocketChannel serverSocket = ServerSocketChannel.open();
serverSocket.bind(new InetSocketAddress(7031));
serverSocket.configureBlocking(false); // 서버 소켓 비동기 설정
serverSocket.register(selector, SelectionKey.OP_ACCEPT); // 연결 연산 등록&lt;/p&gt;
&lt;p&gt;while (true) {
selector.select(); // 가능한 I/O 연산이 있을 때까지 대기
Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();
Iterator&lt;SelectionKey&gt; iterator = selectedKeys.iterator();&lt;/p&gt;
&lt;p&gt;text
while (iterator.hasNext()) { // I/O 연산 순회
SelectionKey key = iterator.next();
iterator.remove();&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;if (key.isAcceptable()) { // 클라이언트 연결 처리 가능하면
    SocketChannel client = serverSocket.accept(); // 클라이언트 연결 처리
    client.configureBlocking(false); // 소켓 비동기 설정
    client.register(selector, SelectionKey.OP_READ); // 읽기 연산 등록
} else if (key.isReadable()) { // 읽기 연산 가능하면
    SocketChannel channel = (SocketChannel) key.channel(); // 채널 구함
    int readBytes = channel.read(inBuffer); // 채널에 읽기 연산 실행
    
    if (readBytes == -1) {
        channel.close();
    } else {
        inBuffer.flip();
        outBuffer.put(inBuffer); // 출력 버퍼에 복사
        inBuffer.clear();
        outBuffer.flip();
        channel.write(outBuffer); // 채널에 쓰기 연산 실행
        outBuffer.clear();
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;}
}&lt;/p&gt;
&lt;p&gt;text&lt;/p&gt;
&lt;p&gt;이 코드에서 핵심은 Selector다. &lt;code class=&quot;language-text&quot;&gt;Selector#select()&lt;/code&gt; 메서드는 I/O 처리가 가능한 연산이 존재할 때까지 대기한다. 이 메서드가 리턴하면 수행할 수 있는 연산이 존재하는 것이다. 실행 가능한 연산 목록은 &lt;code class=&quot;language-text&quot;&gt;Selector#selectedKeys()&lt;/code&gt;로 조회하는데 이렇게 구한 SelectionKey를 이용해서 어떤 연산이 가능한지 확인하고 해당 연산을 수행한다.&lt;/p&gt;
&lt;p&gt;![그림 7.5 자바 논블로킹 I/O의 동작 방식](논블로킹 I/O 동작 다이어그램)&lt;/p&gt;
&lt;p&gt;논블로킹 I/O를 이용해서 구현한 서버는 블로킹 I/O를 이용한 구현과 차이가 난다. 일반적으로 블로킹 I/O로 구현한 서버는 커넥션별로(또는 요청별로) 스레드를 할당한다. 동시 연결 클라이언트가 1,000개면 클라이언트를 처리할 스레드를 1,000개 생성한다. 반면에 논블로킹 I/O는 클라이언트 수에 상관없이 소수의 스레드를 사용한다. 위 예제 코드에서는 스레드 1개를 이용해서 여러 클라이언트의 요청을 처리한다. 논블로킹 I/O는 동시 접속하는 클라이언트가 증가해도 스레드 개수는 일정하게 유지되므로 같은 메모리로 더 많은 클라이언트 연결을 처리할 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;I/O 멀티플렉싱(multiplexing)&lt;/strong&gt;&lt;br&gt;
I/O 멀티플렉싱, 우리말로 I/O 다중화는 단일 이벤트 루프에서 여러 I/O 작업을 처리하는 개념을 표현할 때 사용한다. 앞서 살펴본 논블로킹 I/O와 Selector를 이용한 입출력 처리가 I/O 멀티플렉싱에 해당한다. OS에 따라 epoll(리눅스), IOCP(윈도우) 등을 사용해서 구현한다. I/O 멀티플렉싱을 사용함으로써 더 적은 자원(메모리와 CPU)으로 더 많은 클라이언트를 처리할 수 있어 대규모 트래픽을 처리해야 하는 서버를 구현할 때 I/O 멀티플렉싱을 사용한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;논블로킹 I/O를 1개 스레드로 구현하면 동시성이 떨어진다. 앞서 예제 코드를 기준으로 설명하면 1개 채널에 대한 읽기 처리가 끝나야 다음 채널에 대한 읽기 처리를 실행한다. 즉 두 채널에 대한 읽기 연산이 가능해도 한 번에 1개 채널에 대해서만 처리가 가능하다.&lt;/p&gt;
&lt;p&gt;논블로킹 I/O에서 동시성을 높이기 위해서 사용하는 방법은 채널들을 N개 그룹으로 나누고, 각 그룹마다 스레드를 생성하는 것이다. 보통 CPU 개수만큼 그룹을 나누고 각 그룹마다 입출력을 처리할 스레드를 할당한다. 이를 통해 I/O 처리에 대한 동시성을 높일 수 있다.&lt;/p&gt;
&lt;p&gt;![그림 7.6 논블로킹 I/O에서 동시성을 높이기 위해 N개의 스레드를 사용할 수 있다](멀티 스레드 논블로킹 I/O 다이어그램)&lt;/p&gt;
&lt;h3&gt;리액터 패턴&lt;/h3&gt;
&lt;p&gt;리액터(reactor) 패턴은 논블로킹 I/O를 이용해서 구현할 때 사용하는 패턴 중 하나이다. 논블로킹 I/O로 구현된 네트워크 프레임워크의 문서를 읽다 보면 보이는 &apos;리액터&apos;라는 단어가 이 패턴에서 말하는 리액터에 해당한다.&lt;/p&gt;
&lt;p&gt;리액터 패턴은 동시에 들어오는 여러 이벤트를 처리하기 위한 이벤트 처리 방법이다. 리액터 패턴은 크게 리액터와 핸들러 두 요소로 구성된다. 먼저 리액터는 이벤트가 발생할 때까지 대기하다가 이벤트가 발생하면 알맞은 핸들러에 이벤트를 전달한다. 이벤트를 받은 핸들러는 필요한 로직을 수행한다.&lt;/p&gt;
&lt;p&gt;리액터는 다음과 유사한 형태를 갖는다.&lt;/p&gt;
&lt;p&gt;while (isRunning) {
List&lt;Event&gt; events = getEvents(); // 이벤트가 발생할 때까지 대기
for (Event event : events) {
Handler handler = getHandler(event); // 이벤트를 처리할 핸들러 구함
handler.handle(event); // 이벤트를 처리함
}
}&lt;/p&gt;
&lt;p&gt;text&lt;/p&gt;
&lt;p&gt;이 코드를 보면 리액터는 이벤트를 대기하고 핸들러에 전달하는 과정을 반복하는데, 그래서 리액터를 이벤트 루프(event loop)라고도 한다.&lt;/p&gt;
&lt;p&gt;앞서 봤던 논블로킹 I/O 예제 코드의 구조만 다시 보자.&lt;/p&gt;
&lt;p&gt;Selector selector = Selector.open();
// ... 생략&lt;/p&gt;
&lt;p&gt;while (true) {
selector.select(); // 가능한 I/O 연산이 있을 때까지 대기
Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();
Iterator&lt;SelectionKey&gt; iterator = selectedKeys.iterator();&lt;/p&gt;
&lt;p&gt;text
while (iterator.hasNext()) {
SelectionKey key = iterator.next();
// ... key 타입에 따라 알맞은 처리
}
}&lt;/p&gt;
&lt;p&gt;text&lt;/p&gt;
&lt;p&gt;이 코드에서 SelectionKey를 이벤트에 대응하면 리액터 패턴과 완전히 처리 방식이 동일한 것을 알 수 있다. 실제로 논블로킹 I/O에 기반한 Netty, Nginx, Node.js 등의 프레임워크나 서버는 리액터 패턴을 적용하고 있다.&lt;/p&gt;
&lt;p&gt;리액터 패턴에서 이벤트 루프는 단일 스레드로 실행된다. 멀티코어를 가진 서버에서 단일 스레드만 사용하면 처리량을 최대한 낼 수 없다. 또 핸들러에서 CPU 연산이나 블로킹을 유발하는 연산을 수행하면 그 시간만큼 전체 이벤트 처리 시간이 지연된다. 이런 한계를 보완하기 위해 핸들러나 블로킹 연산을 별도 스레드 풀에서 실행하기도 한다. 예를 들어 Netty는 여러 개의 이벤트 루프를 생성해서 멀티코어를 활용한다. Node.js는 이벤트 루프 외에 별도의 스레드 풀을 사용해서 CPU 중심 작업이나 블로킹 연산을 동시에 처리한다.&lt;/p&gt;
&lt;h3&gt;프레임워크 사용하기&lt;/h3&gt;
&lt;p&gt;줄 단위로 데이터를 수신하는 서버를 구현해야 한다고 생각해보자. 블로킹 I/O일 경우 BufferedReader를 사용해서 쉽게 줄 단위로 데이터를 읽을 수 있다.&lt;/p&gt;
&lt;p&gt;BufferedReader br = new BufferedReader(
new InputStreamReader(socket.getInputStream(), &quot;UTF-8&quot;)
);
String line;
while ((line = br.readLine()) != null) { // 줄 단위로 쉽게 읽을 수 있음
// line 처리
}&lt;/p&gt;
&lt;p&gt;text&lt;/p&gt;
&lt;p&gt;논블로킹 I/O를 사용하면 처리가 복잡해진다. 데이터를 읽은 뒤 \n 문자가 있는지 확인하는 코드를 구현해야 한다. \n 문자가 없는 경우 읽은 데이터를 별도 버퍼에 계속 누적하는 처리도 해야 한다. 또한 \n 문자가 여러 개 존재하는 경우도 처리해야 한다. 채널마다 누적 처리를 위한 버퍼도 관리해야 한다.&lt;/p&gt;
&lt;p&gt;이런 로직을 직접 구현하면 재미야 있겠지만 주고받는 데이터 형식이 조금만 바뀌어도 저수준의 I/O 처리 코드를 변경해야 한다. 필자는 이런 데이터 처리 로직을 직접 구현하는 것보다는 더 상위 수준의 로직을 처리하길 원한다. 그래서 논블로킹 I/O API를 직접 사용하기보다는 논블로킹 I/O를 보다 쉽게 구현할 수 있도록 도와주는 프레임워크를 사용하는 것을 선호한다.&lt;/p&gt;
&lt;p&gt;예를 들어 리액터 네티를 사용하면 아래 코드를 이용해서 줄 단위로 데이터를 주고받는 에코 서버를 구현할 수 있다.&lt;/p&gt;
&lt;p&gt;DisposableServer server = TcpServer.create()
.port(7031)
.doOnConnection(conn -&gt;
conn.addHandlerFirst(new LineBasedFrameDecoder(1024)) // 줄 단위 읽기 처리
)
.handle((in, out) -&gt; {
return in.receive()
.asString() // byte를 문자열로 변환
.doOnNext(line -&gt; {
log.info(&quot;received: {}&quot;, line);
})
.flatMap(line -&gt;
out.sendString(Mono.just(line + &quot;\n&quot;)) // 문자열 쓰기
);
})
.bindNow();&lt;/p&gt;
&lt;p&gt;text&lt;/p&gt;
&lt;p&gt;리액터 네티가 줄 단위 읽기와 문자열 변환 처리 기능을 제공하므로, 저수준의 I/O 처리를 직접 구현하지 않아도 된다. 개발자는 처리할 로직에 집중할 수 있다. 물론 리액터 네티가 기반으로 하는 리액티브 API(스프링 리액터)를 익혀야 하지만, 일단 익숙해지면 논블로킹 I/O API를 직접 사용하는 것보다 간단한 코드로 논블로킹/비동기 I/O 방식으로 구현할 수 있게 된다.&lt;/p&gt;
&lt;h3&gt;논블로킹/비동기 I/O와 성능&lt;/h3&gt;
&lt;p&gt;실제로 논블로킹 I/O를 사용하면 성능이 좋아질까? 검색해보면 성능이 더 잘 나온다는 글을 다수 찾을 수 있을 것이다. 필자도 몇 해 전에 자바로 구현된 간단한 푸시 서버를 블로킹 I/O 방식에서 논블로킹 I/O 방식으로 변경한 적이 있다. 그때 측정한 결과는 [그림 7.7]과 같다.&lt;/p&gt;
&lt;p&gt;![그림 7.7 블로킹 I/O와 논블로킹 I/O로 구현한 서버의 최대 동접수 차이](성능 비교 그래프)&lt;/p&gt;
&lt;p&gt;[그림 7.7]의 수치는 JVM에 힙 메모리를 1.5G 할당했을 때 측정한 것으로 블로킹 I/O 방식으로 구현된 서버의 최대 동접수는 6천 정도가 나왔다. 반면 논블로킹 I/O 방식으로 구현한 서버는 동일한 조건에서 12만 정도가 나왔다. 약 20배 정도 성능이 향상된 것을 확인할 수 있었다.&lt;/p&gt;
&lt;p&gt;유사한 성능 테스트를 Go 언어로도 해봤다. 고루틴을 사용해서 구현한 서버와 gnet 프레임워크(논블로킹/비동기 I/O)를 이용한 서버의 최대 동접수를 비교했다. 결과는 [그림 7.8]과 같다.&lt;/p&gt;
&lt;p&gt;![그림 7.8 클라이언트별 고루틴 방식 서버와 gnet(논블로킹 I/O)으로 구현한 서버의 성능 차이](Go 성능 비교 그래프)&lt;/p&gt;
&lt;p&gt;[그림 7.8]은 메모리 사용량이 500MB일 때 최대 동접수를 비교한 것이다. 고루틴 버전은 최대 동접수가 2만이었고 gnet 버전은 18만이었다. 대략 9배 정도의 성능 차이를 보였다.&lt;/p&gt;
&lt;h2&gt;언제 어떤 방법을 택할까&lt;/h2&gt;
&lt;p&gt;성능만큼 개발자를 자극하는 단어도 없는 것 같다. 특정 기술을 사용했더니 성능이 좋아졌다는 글이나 영상을 보면 눈길이 간다. 하지만 논블로킹 I/O나 가상 스레드를 더 높은 성능을 낼 수 있다는 기술을 사용해보고 싶기도 하다.&lt;/p&gt;
&lt;p&gt;적용할 때는 먼저 다음을 검토해야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;문제가 있는가?&lt;/li&gt;
&lt;li&gt;문제가 있다면 네트워크 I/O 관련 성능 문제인가?&lt;/li&gt;
&lt;li&gt;구현 변경이 가능한가?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;가장 먼저 검토해야 할 점은 성능 문제가 있는지 여부다. 성능 문제가 없다면 또는 당분간 트래픽 증가 가능성이 없다면 논블로킹 I/O나 가상 스레드를 검토할 필요가 없다. 문제가 없는데 구현을 변경하는 것은 시간을 낭비하는 것에 불과하다.&lt;/p&gt;
&lt;p&gt;게다가 논블로킹/비동기 I/O 방식으로 구현하면 코드가 복잡해지고 유지보수 난이도도 올라간다. 그러니 단순한 호기심으로 안 해도 되는 구현 변경을 시도하지는 말자. 다시 한 번 강조하지만 성능 문제가 전혀 없는데 성능을 높이겠다며 복잡하게 구현하지 말자.&lt;/p&gt;
&lt;p&gt;성능 문제가 있다면 그 문제가 네트워크 I/O와 관련된 자원 문제인지 확인해야 한다. 예를 들어 트래픽은 그대로인데 DB 쿼리 시간이 느려지면서 서버 응답 시간이 길어지는 문제가 발생했다면 가상 스레드나 논블로킹 I/O를 적용해도 응답 시간을 줄일 수는 없다. 이 경우에는 DB 쿼리를 최적화하거나 캐시를 사용하는 것이 응답 시간을 줄이는 방법이다. 썸네일 생성처럼 CPU 중심 작업도 마찬가지다. 이미지를 처리하는 과정에는 블로킹 I/O가 없으므로 가상 스레드나 논블로킹 I/O를 적용해도 처리 시간이 줄어들지 않는다.&lt;/p&gt;
&lt;p&gt;문제가 I/O 관련이라면 그때는 구현 변경이 가능한지를 따져봐야 한다. 예를 들어 동시에 요청하는 클라이언트 수가 늘어나면서 실행되는 스레드 수도 많아졌고, 그 결과 메모리 사용률이 98%까지 올라갔다고 하자. 이 상황이 지속되면서 서비스에 장애가 발생할 수 있다. 가상 스레드를 적용할 수 있다면 이를 사용하는 것만으로 메모리 사용률을 줄일 수 있다. 만약 가상 스레드를 적용할 수 없다면 일단 메모리를 늘리거나 서버를 수평 확장해서 문제를 완화하는 수밖에 없다.&lt;/p&gt;
&lt;p&gt;우선순위에 밀려 구현 변경이 불가능한 상황도 있다. 신기능 개발에 많은 인력이 투입된 상황이라면 성능 개선에 쓸 인력이 없을 수도 있다. 이럴 때는 구현 방식을 바꾸는 대신 서버 확장을 통해 문제를 해결해야 한다. 이후 여유가 생기면 성능 개선 작업을 진행하면 된다.&lt;/p&gt;
&lt;p&gt;우선순위뿐만 아니라 기술에 대한 익숙함도 구현 변경 여부에 영향을 준다. 예를 들어 웹소켓 서버의 동시 접속자가 증가해서 성능 문제가 발생했다고 하자. 이때 논블로킹 I/O를 적용하면 효과를 볼 수 있지만, 개발자가 관련 기술을 모르면 성능 개선은 어렵다.&lt;/p&gt;
&lt;p&gt;정리하자면 문제가 있고, 그 문제가 네트워크 I/O와 관련되어 있으며, 구현 변경이 가능한 상황이라면 변경을 시도하자. 그렇게 하면 성능 개선이라는 결과와 새로운 기술을 적용하는 재미를 모두 얻을 수 있을 것이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;기술 탐구 시간 갖기&lt;/strong&gt;&lt;br&gt;
이상적인 이야기일 수 있지만, 팀이나 개인이 문제가 생기기 전에 기술을 도입할 수 있는 여유가 생긴다. 사전에 문제 해결에 도움이 될 기술을 여유 있게 학습해두자. 그런 준비가 중요한 순간에 큰 힘이 된다. 발생한 뒤에 신속하게 대응하고 기술을 적용할 수 있다. 미리 비동기 I/O 관련 기술을 익혀두지 않았다면 빠르게 문제를 해결하지 못했을 것이다. 예전에 소켓 서버를 재구현한 사례도 비슷하다. 만약 팀이 문제를 완전히 예방하지 못하더라도, 문제가 발생 예측할 수 방하지만 기 때는 필요한 역량을 미리 익혀두면 좋다. 그래야 문제가&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[JVM과 JIT 컴파일러: 자바 성능 최적화의 핵심]]></title><description><![CDATA[JVM 자바를 공부하시는 분들은 JVM을 들어보셨을 겁니다. JVM은 어느 OS에서 실행해도 자바로 작성된 파일을 잘 실행시켜줍니다. 그렇기 때문에 이식성이 높다는 말을 듣죠. JVM은 JIT 컴파일러를 가지고 있습니다. 이 글에서 JIT…]]></description><link>https://gotobill.github.io/jvm-jit-compiler/</link><guid isPermaLink="false">https://gotobill.github.io/jvm-jit-compiler/</guid><pubDate>Fri, 12 Sep 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;JVM&lt;/h2&gt;
&lt;p&gt;자바를 공부하시는 분들은 JVM을 들어보셨을 겁니다.&lt;/p&gt;
&lt;p&gt;JVM은 어느 OS에서 실행해도 자바로 작성된 파일을 잘 실행시켜줍니다. 그렇기 때문에 이식성이 높다는 말을 듣죠.&lt;/p&gt;
&lt;p&gt;JVM은 JIT 컴파일러를 가지고 있습니다. 이 글에서 JIT 컴파일러에 대해서 말씀드리겠습니다.&lt;/p&gt;
&lt;h3&gt;컴파일과 인터프리터의 차이&lt;/h3&gt;
&lt;p&gt;프로그래밍 언어를 실행하는 방식에는 크게 &lt;strong&gt;컴파일 방식&lt;/strong&gt;과 &lt;strong&gt;인터프리터 방식&lt;/strong&gt;이 있습니다.&lt;/p&gt;
&lt;h4&gt;컴파일 방식&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;전체 코드를 한 번에 기계어(네이티브 코드)로 변환하여 실행하는 방식입니다.&lt;/li&gt;
&lt;li&gt;실행 속도가 빠르지만, 실행 전에 &lt;strong&gt;컴파일 과정&lt;/strong&gt;이 필요하므로 초기 실행 시간이 오래 걸립니다.&lt;/li&gt;
&lt;li&gt;대표적인 컴파일 언어: &lt;strong&gt;C, C++&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token macro property&quot;&gt;&lt;span class=&quot;token directive-hash&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;token directive keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&amp;lt;stdio.h&gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Hello, World!\n&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 실행 방식:&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 1. 컴파일: gcc main.c -o main&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 2. 실행: ./main&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;인터프리터 방식&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;코드를 한 줄씩 읽어가며 즉시 실행하는 방식입니다.&lt;/li&gt;
&lt;li&gt;실행 준비가 필요 없지만 실행 속도가 느립니다.&lt;/li&gt;
&lt;li&gt;대표적인 인터프리터 언어: &lt;strong&gt;Python, JavaScript&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;python&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;# Python 예제 (인터프리터 방식)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Hello, World!&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;어셈블리 명령어와 성능 차이&lt;/h4&gt;
&lt;p&gt;CPU는 &lt;strong&gt;기계어(바이너리 코드,네이티브 코드) 또는 어셈블리 언어 명령어&lt;/strong&gt;만 실행할 수 있습니다.&lt;br&gt;
컴파일러는 이 명령어들의 실행 순서를 최적화하여 성능을 높입니다.&lt;/p&gt;
&lt;p&gt;예를 들어, 두 개의 숫자를 더하는 프로그램을 생각해봅시다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;컴파일 방식:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;미리 데이터를 메모리에서 가져와 &lt;strong&gt;레지스터&lt;/strong&gt;에 저장한 후 덧셈 연산을 실행&lt;/li&gt;
&lt;li&gt;덧셈에 필요한 데이터가 미리 준비되어 있어 빠르게 실행됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;인터프리터 방식 (Java는 Stack 방식):&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;실행할 때마다 메모리에서 데이터를 가져온 후 덧셈을 수행&lt;/li&gt;
&lt;li&gt;매번 메모리 접근을 해야 하므로 속도가 느려짐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;컴파일된 코드는 미리 &lt;strong&gt;최적화된 실행 순서를 적용할 수 있지만&lt;/strong&gt;,&lt;br&gt;
인터프리터 방식은 실행 중에 코드 변환을 수행해야 하므로 속도가 느릴 수밖에 없습니다.&lt;/p&gt;
&lt;p&gt;이처럼 &lt;strong&gt;컴파일 방식은 빠른 실행 속도를 보장하지만, 실행 전에 컴파일 과정이 필요하고, 인터프리터 방식은 빠르게 실행되지만 속도가 느리다는 단점이 있습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;JVM과 바이트코드&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Java는 위 두 가지 방식(컴파일, 인터프리터)을 적절히 결합한 방식&lt;/strong&gt;을 사용합니다. Java 프로그램이 실행되기 전에는 &lt;strong&gt;소스 코드(.java)를 바이트코드(.class)로 변환&lt;/strong&gt;하는 과정이 필요합니다.&lt;/p&gt;
&lt;h4&gt;바이트코드란?&lt;/h4&gt;
&lt;p&gt;바이트코드는 JVM이 이해할 수 있는 중간 코드입니다. 실행하기 위해서는 JVM이 바이트코드를 기계어로 변환해야 합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;HelloWorld&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Hello, World!&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 실행 과정:&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 1. 컴파일: javac HelloWorld.java  (바이트코드 생성)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 2. 실행: java HelloWorld  (JVM이 바이트코드를 해석하여 실행)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Java의 실행 방식은 &lt;strong&gt;&quot;컴파일 후 인터프리터 실행&quot;&lt;/strong&gt; 방식입니다. 즉, 처음에는 바이트코드를 인터프리터 방식으로 실행하며, 이후 JIT 컴파일러가 최적화를 수행합니다.&lt;/p&gt;
&lt;h3&gt;JIT 컴파일러의 동작 원리&lt;/h3&gt;
&lt;p&gt;JIT 컴파일러는 Java 프로그램 실행 중 &lt;strong&gt;자주 실행되는 코드(핫스팟, Hotspot)를 찾아 네이티브 코드로 변환하여 실행 속도를 높이는 역할&lt;/strong&gt;을 합니다.&lt;/p&gt;
&lt;h4&gt;JIT 컴파일러의 실행 과정&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;처음 실행&lt;/strong&gt;: JVM은 바이트코드를 인터프리터 방식으로 실행합니다.&lt;br&gt;
-&gt; &lt;strong&gt;모든 코드를 컴파일 하지 않는다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;핫스팟 감지&lt;/strong&gt;: JVM은 실행 중 특정 메서드나 루프가 자주 실행되는지 분석합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JIT 컴파일 수행&lt;/strong&gt;: 자주 실행되는 코드**(핫스팟)**를 **네이티브 코드(기계어)**로 변환하여 실행 속도를 높입니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;최적화 지속 수행&lt;/strong&gt;: JIT 컴파일러는 실행 도중에도 지속적으로 코드 실행 패턴을 분석하여 최적화를 적용합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;JITExample&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; startTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;nanoTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10_000_000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token function&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; endTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;nanoTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;실행 시간: &quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;endTime &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; startTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1_000_000&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot; ms&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; sum &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            sum &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; sum&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드에서 &lt;strong&gt;compute() 메서드는 매우 자주 실행되므로 JVM&lt;/strong&gt;은 &lt;strong&gt;핫스팟으로 감지하여 JIT 컴파일을 수행&lt;/strong&gt;합니다.&lt;/p&gt;
&lt;h3&gt;JIT 컴파일러의 종류&lt;/h3&gt;
&lt;p&gt;JIT 컴파일러는 두 가지 형태로 나뉩니다. 애플리케이션이 실행되는 동안 어떤 방식으로 컴파일할지를 결정하는 것이 중요한데, 이에 따라 적절한 컴파일러를 선택해야 합니다.&lt;/p&gt;
&lt;p&gt;JVM에서 사용하는 두 가지 JIT 컴파일러는 &lt;strong&gt;클라이언트 컴파일러(Client Compiler, C1)&lt;/strong&gt; 와 &lt;strong&gt;서버 컴파일러(Server Compiler, C2)&lt;/strong&gt; 입니다. JVM 개발자들은 각각 &lt;strong&gt;C1(컴파일러 1), C2(컴파일러 2)&lt;/strong&gt; 라고 부르기도 합니다.&lt;/p&gt;
&lt;p&gt;두 컴파일러의 가장 큰 차이점은 &lt;strong&gt;컴파일 방식의 적극성&lt;/strong&gt;에 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;클라이언트 컴파일러&lt;/strong&gt;는 실행 초기에 빠르게 코드를 컴파일하여 즉시 실행 속도를 높이는 데 초점을 맞추고 있습니다. 반면, &lt;strong&gt;서버 컴파일러&lt;/strong&gt;는 &lt;strong&gt;더 많은 실행 정보를 수집한 후(초기에는 인터프리터 방식으로)에 보다 강력한 최적화를 적용&lt;/strong&gt;하여 장기적으로 높은 성능을 제공합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;클라이언트 컴파일러는 빠르게 동작하는 대신, 깊이 있는 최적화가 부족하고, 서버 컴파일러는 초기에는 느리지만 시간이 지나면 훨씬 더 효율적인 실행 속도를 제공합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;이러한 차이점 때문에 &lt;strong&gt;애플리케이션의 특성에 따라 적절한 컴파일러를 선택하는 것이 중요&lt;/strong&gt;합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;짧은 시간 동안 실행되는 프로그램&lt;/strong&gt;이라면 &lt;strong&gt;클라이언트 컴파일러&lt;/strong&gt;가 더 적합합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;장기간 실행되는 서버 애플리케이션&lt;/strong&gt;이라면 &lt;strong&gt;서버 컴파일러&lt;/strong&gt;를 선택하는 것이 바람직합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;티어드 컴파일(Tiered Compilation)&lt;/h4&gt;
&lt;p&gt;여기서 한 가지 궁금한 게 생길 수 있습니다. 그냥 두개를 섞어서 쓰면 되는 거 아닌가?&lt;br&gt;
&quot;JVM이 처음에는 클라이언트 컴파일러를 사용하다가, 코드가 많이 실행되면 서버 컴파일러로 전환할 수는 없을까?&quot;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;이러한 개념이 바로 티어드 컴파일(Tiered Compilation) 입니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;티어드 컴파일을 사용하면 코드가 처음에는 클라이언트 컴파일러(C1)에서 빠르게 컴파일되고, 이후 실행 횟수가 많아지면 서버 컴파일러(C2)로 다시 컴파일됩니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;이 과정에서 역최적화(밑에서 설명)&lt;/strong&gt; 가 발생하지만, 재컴파일 시간은 성능에 영향을 줄 정도로 크지 않기 때문에 장기적으로는 훨씬 효율적인 실행이 가능합니다.&lt;/p&gt;
&lt;p&gt;티어드 컴파일은 &lt;strong&gt;자바 7부터 도입되었으며, 자바 8에서는 기본적으로 활성화&lt;/strong&gt;되어 있습니다.&lt;br&gt;
즉, 별도로 설정하지 않아도 JVM은 클라이언트 컴파일러와 서버 컴파일러를 적절히 조합하여 사용하게 됩니다.&lt;/p&gt;
&lt;p&gt;결국, 티어드 컴파일을 활용하면 &lt;strong&gt;빠른 실행 속도와 최적화된 성능을 모두 얻을 수 있어, 대부분의 애플리케이션에서 가장 좋은 선택&lt;/strong&gt;이 될 수 있습니다.&lt;/p&gt;
&lt;p&gt;티어드 컴파일이 기본적으로 동작하는 방식을 이해했다면, 이제 실제로 이 방식을 적용할 때 어떤 튜닝이 필요한지 살펴보겠습니다.&lt;/p&gt;
&lt;p&gt;티어드 컴파일이 효과적으로 작동하려면, JVM이 &lt;strong&gt;클라이언트 컴파일러(C1)&lt;/strong&gt; 와 &lt;strong&gt;서버 컴파일러(C2)&lt;/strong&gt; 간의 전환을 원활하게 수행할 수 있도록 &lt;strong&gt;적절한 설정과 최적화가 필요합니다&lt;/strong&gt;.&lt;/p&gt;
&lt;h3&gt;티어드 컴파일의 최적화를 위한 주요 고려사항&lt;/h3&gt;
&lt;h4&gt;코드 캐시 최적화&lt;/h4&gt;
&lt;p&gt;티어드 컴파일러는 &lt;strong&gt;초기에 C1(클라이언트 컴파일러)에서 실행된 코드를 C2(서버 컴파일러)로 재컴파일&lt;/strong&gt;하며, 이 과정에서 많은 코드가 생성됩니다.&lt;/p&gt;
&lt;p&gt;JVM은 &lt;strong&gt;컴파일된 기계어 코드를 &quot;코드 캐시&quot;에 저장&lt;/strong&gt;하는데, &lt;strong&gt;이 캐시가 가득 차면 추가적인 코드 컴파일이 불가능해질 수 있습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;문제점&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;코드 캐시가 가득 차면 JVM이 더 이상 새로운 코드를 컴파일할 수 없고, &lt;strong&gt;일부 코드가 인터프리터로 실행될 수 있음&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서버 컴파일러(C2)가 작동하지 않게 되면 성능이 저하될 가능성이 높음&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;해결 방법&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JVM 실행 시 &lt;strong&gt;-XX:ReservedCodeCacheSize=N&lt;/strong&gt; 옵션을 활용하여 코드 캐시 크기를 늘릴 수 있습니다.&lt;br&gt;
일반적으로 기본값보다 &lt;strong&gt;2배~4배 정도 증가시키는 것이 성능 향상에 도움&lt;/strong&gt;이 됩니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;java&lt;/span&gt; &lt;span class=&quot;token parameter variable&quot;&gt;-XX:ReservedCodeCacheSize&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;512m &lt;span class=&quot;token parameter variable&quot;&gt;-XX:+TieredCompilation&lt;/span&gt; MyApplication&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;컴파일 임계치(Compile Threshold) 조정&lt;/h4&gt;
&lt;p&gt;티어드 컴파일에서 코드가 C1 → C2로 넘어가기까지 얼마나 많은 실행 횟수가 필요한지를 조절하는 설정입니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;문제점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기본적으로 C1에서 C2로 전환하는 기준(임계치)이 높게 설정되어 있어, &lt;strong&gt;실행 초기에 최적화가 늦어질 수 있음&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;빠르게 최적화된 코드가 필요하다면, 이 임계치를 낮추는 것이 유리할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;해결 방법&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-XX:CompileThreshold=N&lt;/strong&gt; 플래그를 사용하여 &lt;strong&gt;C2로 컴파일되는 임계값을 조정&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;기본적으로 &lt;strong&gt;클라이언트 컴파일러(C1)에서 1,500번&lt;/strong&gt;, &lt;strong&gt;서버 컴파일러(C2)에서 10,000번&lt;/strong&gt; 실행되면 컴파일됨&lt;/li&gt;
&lt;li&gt;이 값을 낮추면 &lt;strong&gt;C2로의 전환이 빨라짐&lt;/strong&gt;, 그러나 &lt;strong&gt;너무 낮추면 불필요한 컴파일이 많아져 오히려 성능이 저하될 수 있음&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;java&lt;/span&gt; &lt;span class=&quot;token parameter variable&quot;&gt;-XX:CompileThreshold&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;5000&lt;/span&gt; &lt;span class=&quot;token parameter variable&quot;&gt;-XX:+TieredCompilation&lt;/span&gt; MyApplication&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게 하면, 기존 10,000번 실행 후 C2로 넘어가는 것보다 &lt;strong&gt;더 빠르게 최적화된 코드를 사용할 수 있습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;OSR(On-Stack Replacement) 활용&lt;/h4&gt;
&lt;p&gt;OSR은 &lt;strong&gt;긴 루프가 인터프리터 모드에서 실행되더라도, 루프 도중에 JIT 컴파일된 코드로 교체하는 기법&lt;/strong&gt;입니다.&lt;br&gt;
즉, 루프를 빠져나올 때까지 기다릴 필요 없이, &lt;strong&gt;즉시 컴파일된 코드로 전환 가능&lt;/strong&gt;합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;문제점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기본적으로 JVM은 &lt;strong&gt;루프가 끝날 때까지 컴파일된 코드로 전환하지 않음&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;긴 루프가 인터프리터 모드에서 계속 실행될 경우 성능 저하 발생&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;해결 방법&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-XX:+TieredCompilation 플래그를 활성화하면 OSR이 자동으로 적용됨&lt;/li&gt;
&lt;li&gt;별도로 -XX:LoopUnrollLimit을 설정하면 &lt;strong&gt;OSR이 더 적극적으로 실행됨&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;java&lt;/span&gt; &lt;span class=&quot;token parameter variable&quot;&gt;-XX:+TieredCompilation&lt;/span&gt; &lt;span class=&quot;token parameter variable&quot;&gt;-XX:LoopUnrollLimit&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;50&lt;/span&gt; MyApplication&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게 하면 &lt;strong&gt;루프 실행 중에도 인터프리터를 사용하지 않고 빠르게 C1 → C2 전환 가능&lt;/strong&gt;.&lt;/p&gt;
&lt;h4&gt;컴파일 스레드 최적화&lt;/h4&gt;
&lt;p&gt;JVM은 &lt;strong&gt;컴파일 큐&lt;/strong&gt;를 활용하여 메서드가 컴파일될 때까지 대기시킵니다.&lt;br&gt;
컴파일 큐는 &lt;strong&gt;FIFO(선입선출)&lt;/strong&gt; 방식이 아니며, &lt;strong&gt;호출 빈도가 높은 메서드가 우선적으로 컴파일&lt;/strong&gt;됩니다.&lt;/p&gt;
&lt;p&gt;기본적으로 &lt;strong&gt;클라이언트 컴파일러(C1)는 1개, 서버 컴파일러(C2)는 2개의 컴파일 스레드&lt;/strong&gt;로 시작합니다.&lt;br&gt;
&lt;strong&gt;티어드 컴파일을 사용하는 경우, CPU 개수에 따라 적절한 개수의 컴파일 스레드를 자동으로 할당&lt;/strong&gt;합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;컴파일 스레드 개수 조정 방법&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-XX:CICompilerCount=N&lt;/strong&gt; 옵션을 사용하면 &lt;strong&gt;컴파일 스레드 개수를 직접 설정&lt;/strong&gt;할 수 있습니다.&lt;/li&gt;
&lt;li&gt;단일 CPU 환경에서는 1개로 제한하는 것이 좋습니다.&lt;/li&gt;
&lt;li&gt;다중 코어 환경에서는 컴파일 스레드 개수를 늘려 &lt;strong&gt;JVM이 빠르게 JIT 컴파일을 수행하도록 조정할 수 있습니다&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;java&lt;/span&gt; &lt;span class=&quot;token parameter variable&quot;&gt;-XX:CICompilerCount&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;token parameter variable&quot;&gt;-XX:+TieredCompilation&lt;/span&gt; MyApplication&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;주의할 점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU 개수가 적다면 너무 많은 컴파일 스레드를 할당하면 오히려 경쟁이 발생하여 성능이 저하될 수 있습니다.&lt;/li&gt;
&lt;li&gt;초반 &lt;strong&gt;스타트업 속도는 증가할 수 있지만, 장기적으로 CPU 리소스를 과도하게 사용하게 될 수도 있습니다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;인라이닝(Inlining) 최적화&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;인라이닝&lt;/strong&gt;은 JVM이 &lt;strong&gt;자주 호출되는 메서드를 직접 호출하는 방식으로 변경하여 메서드 호출 오버헤드를 줄이는 최적화 기법&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;인라이닝의 효과&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;메서드 호출 시 발생하는 스택 프레임 생성 비용을 제거&lt;/li&gt;
&lt;li&gt;루프 내에서 반복적으로 호출되는 메서드를 직접 코드에 삽입하여 실행 속도 향상&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;인라이닝 설정 방법&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-XX:MaxInlineSize=N&lt;/strong&gt; → &lt;strong&gt;바이트 코드 크기가 N 바이트 이하인 메서드는 인라이닝됨&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-XX:MaxFreqInlineSize=N&lt;/strong&gt; → &lt;strong&gt;자주 호출되는 메서드는 더 큰 크기라도 인라이닝&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;java&lt;/span&gt; &lt;span class=&quot;token parameter variable&quot;&gt;-XX:MaxInlineSize&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;50&lt;/span&gt; &lt;span class=&quot;token parameter variable&quot;&gt;-XX:MaxFreqInlineSize&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;400&lt;/span&gt; MyApplication&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;주의할 점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;인라이닝을 과도하게 하면 &lt;strong&gt;JVM의 코드 캐시를 빠르게 소모할 수 있음&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;너무 많은 메서드가 인라이닝되면 오히려 성능이 저하될 가능성이 있음.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;탈출 분석(Escape Analysis) 최적화&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;탈출 분석&lt;/strong&gt;은 &lt;strong&gt;객체가 특정 스코프를 벗어나지 않는 경우, JVM이 해당 객체를 최적화하는 기법&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;탈출 분석의 효과&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;스레드 동기화 제거:&lt;/strong&gt; &lt;strong&gt;동기화(lock)를 사용할 필요가 없는 객체는 자동으로 제거&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;스택 할당(Stack Allocation):&lt;/strong&gt; &lt;strong&gt;객체를 힙이 아닌 스택에 할당&lt;/strong&gt;하여 &lt;strong&gt;GC(가비지 컬렉션) 부담 감소&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;레지스터 최적화:&lt;/strong&gt; 객체의 값을 &lt;strong&gt;메모리가 아닌 CPU 레지스터에서 관리&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;탈출 분석 활성화 방법&lt;/strong&gt; 기본적으로 탈출 분석은 활성화되어 있으며, &lt;strong&gt;-XX:+DoEscapeAnalysis&lt;/strong&gt; 옵션을 사용하여 명시적으로 활성화할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;java&lt;/span&gt; &lt;span class=&quot;token parameter variable&quot;&gt;-XX:+DoEscapeAnalysis&lt;/span&gt; MyApplication&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Factorial&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; n&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Factorial&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; n&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;n &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; n&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getFactorial&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; n&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Main&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token class-name&quot;&gt;Factorial&lt;/span&gt; f &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Factorial&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 루프 내에서만 사용됨&lt;/span&gt;
            &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;f&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getFactorial&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 코드에서 Factorial 객체는 &lt;strong&gt;루프 내에서만 사용&lt;/strong&gt;되므로, 탈출 분석을 통해 &lt;strong&gt;힙이 아닌 스택에서 할당&lt;/strong&gt;될 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;주의할 점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;탈출 분석이 항상 최적의 성능을 보장하는 것은 아니며, 특정 환경에서는 성능이 저하될 수도 있음.&lt;/li&gt;
&lt;li&gt;객체가 예상보다 더 큰 범위에서 사용되면, JVM이 탈출 분석을 제대로 수행하지 못할 가능성이 있음.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;역최적화&lt;/h4&gt;
&lt;p&gt;JVM이 &lt;strong&gt;기존에 컴파일한 코드를 다시 인터프리터 모드로 되돌리는 과정&lt;/strong&gt;을 &lt;strong&gt;역최적화&lt;/strong&gt;라고 합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;역최적화가 발생하는 주요 원인&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 다형성의 변화&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; member&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; memberId&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;MemberRepositoryImpl&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; member&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Saving member: &quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; member&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; memberId&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Member-&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; memberId&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;LoggingMemberRepository&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;MemberRepository&lt;/span&gt; delegate&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;LoggingMemberRepository&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;MemberRepository&lt;/span&gt; delegate&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;delegate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; delegate&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; member&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;[LOG] Saving member: &quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; member&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        delegate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;member&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; memberId&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;[LOG] Finding member: &quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; memberId&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; delegate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;memberId&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Main&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;MemberRepository&lt;/span&gt; repository &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;MemberRepositoryImpl&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 초기엔 이 클래스로 최적화됨&lt;/span&gt;

        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1_000_000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            repository&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;User-&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
            repository&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;valueOf&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;token comment&quot;&gt;// 로그 기능이 추가되면서 기존의 최적화된 코드가 역최적화될 가능성이 높아짐&lt;/span&gt;
        repository &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;LoggingMemberRepository&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;MemberRepositoryImpl&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1_000_000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            repository&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;User-&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
            repository&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;valueOf&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;초기에는 MemberRepositoryImpl만 사용&lt;/strong&gt;되어, &lt;strong&gt;JVM은 이 클래스를 최적화하여 실행 속도를 높임.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;하지만 &lt;strong&gt;새로운 구현체 LoggingMemberRepository가 추가되면서 다형성이 바뀜&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;기존의 &lt;strong&gt;최적화된 코드가 더 이상 유효하지 않게 되면서 JVM은 역최적화를 수행&lt;/strong&gt;함.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JVM은&lt;/strong&gt; 기존의 &lt;strong&gt;최적화된 코드를 폐기하고, 새로운 다형성을 반영한 코드로 다시 컴파일&lt;/strong&gt;함.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. 티어드 컴파일의 전환 과정&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;클라이언트 컴파일러(C1)&lt;/strong&gt; 에서 &lt;strong&gt;컴파일된 코드가 서버 컴파일러(C2)&lt;/strong&gt; 에서 다시 최적화될 때, 기존 코드는 더 이상 사용되지 않음.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;역최적화의 처리 방식&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기존 컴파일된 코드는 &lt;strong&gt;&quot;진입 불가&quot;&lt;/strong&gt; 상태가 되며, 이후 새로운 최적화 코드가 생성됨.&lt;/li&gt;
&lt;li&gt;일정 시간이 지나면 **&quot;좀비 코드&quot;**로 변환되어 코드 캐시에서 제거됨.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;주의할 점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;역최적화가 자주 발생하면 오히려 &lt;strong&gt;JVM 성능이 불안정해질 수 있음&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;특정 코드를 너무 자주 최적화하고 폐기하는 경우 &lt;strong&gt;불필요한 오버헤드 발생&lt;/strong&gt; 가능.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;JVM 튜닝 옵션&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;튜닝 옵션&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;th&gt;추천 값&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;-XX:CICompilerCount=N&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;컴파일 스레드 개수 조정&lt;/td&gt;
&lt;td&gt;CPU 개수에 맞춰 설정&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;-XX:MaxInlineSize=N&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;기본 인라이닝 크기 조정&lt;/td&gt;
&lt;td&gt;35~50&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;-XX:MaxFreqInlineSize=N&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;자주 호출되는 메서드 인라이닝 크기 조정&lt;/td&gt;
&lt;td&gt;325~400&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;-XX:+DoEscapeAnalysis&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;탈출 분석 활성화&lt;/td&gt;
&lt;td&gt;기본 활성화&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;-XX:ReservedCodeCacheSize=N&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;코드 캐시 크기 조정&lt;/td&gt;
&lt;td&gt;기본값의 2~4배 (예: 512MB)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;-XX:CompileThreshold=N&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;C2로 전환하는 실행 횟수 조정&lt;/td&gt;
&lt;td&gt;기본값(10,000) → 5,000~7,000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;-XX:+TieredCompilation&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;티어드 컴파일 활성화&lt;/td&gt;
&lt;td&gt;기본 활성화 (JVM 8 이상)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;-XX:LoopUnrollLimit&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;OSR 최적화&lt;/td&gt;
&lt;td&gt;50~100&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;웜업(Warm-up) 과정&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;자바 프로그램이 실행되면 처음에는 인터프리터 방식으로 실행되다가, 일정 시간이 지나야 JIT 컴파일러가 동작하면서 성능이 최적화 된다는 것을 위에서 배웠습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;이 과정에서 발생하는 초기 성능 저하를 &lt;strong&gt;웜업(Warm-up)&lt;/strong&gt; 과정이라고 합니다.&lt;/p&gt;
&lt;h4&gt;웜업이 필요한 이유&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;처음에는 &lt;strong&gt;인터프리터 방식으로 실행&lt;/strong&gt;하여 빠르게 시작합니다.&lt;/li&gt;
&lt;li&gt;JVM이 &lt;strong&gt;자주 실행되는 메서드를 감지(프로파일링)&lt;/strong&gt; 합니다.&lt;/li&gt;
&lt;li&gt;JIT 컴파일러가 &lt;strong&gt;핫스팟 코드&lt;/strong&gt;를 찾아 네이티브 코드로 변환합니다.&lt;/li&gt;
&lt;li&gt;실행 속도가 점점 향상됩니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;WarmUpTest&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; startTime&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; endTime&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;token comment&quot;&gt;// 초기 실행 시간 측정&lt;/span&gt;
        startTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;nanoTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;100_000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token function&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        endTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;nanoTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;초기 실행 시간: &quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;endTime &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; startTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1_000_000.0&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot; ms&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;token comment&quot;&gt;// 웜업 진행 (JIT 컴파일러가 최적화할 기회를 줌)&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1_000_000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token function&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;token comment&quot;&gt;// 최적화 후 실행 속도 측정&lt;/span&gt;
        startTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;nanoTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;100_000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token function&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        endTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;nanoTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;최적화 후 실행 시간: &quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;endTime &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; startTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1_000_000.0&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot; ms&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; sum &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            sum &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; sum&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;실행 결과 예시&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;초기 실행 시간: 50.2 ms
최적화 후 실행 시간: 12.8 ms&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;처음 실행할 때는 인터프리터 방식으로 실행되므로 실행 속도가 느립니다.&lt;/li&gt;
&lt;li&gt;일정 시간이 지나면서 JIT 컴파일러가 최적화를 수행하여 실행 속도가 크게 향상됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;웜업 시간을 줄이는 방법&lt;/h3&gt;
&lt;p&gt;JIT 컴파일러는 실행 중 성능 최적화를 수행하지만, 초기 웜업 시간이 길어질 경우 성능 저하가 발생할 수 있습니다. 이를 해결하는 방법은 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;티어드 컴파일(Tiered Compilation) 사용&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-XX:+TieredCompilation 옵션&lt;/strong&gt;을 사용하면 인터프리터와 JIT 컴파일을 동시에 활용하여 웜업 시간을 줄일 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;java&lt;/span&gt; &lt;span class=&quot;token parameter variable&quot;&gt;-XX:+TieredCompilation&lt;/span&gt; WarmUpTest&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;AOT 컴파일 활용&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;jaotc(Java Ahead-Of-Time Compiler)&lt;/strong&gt; 를 사용하여 실행 전에 미리 네이티브 코드로 변환할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;AOT(Ahead-of-Time) 컴파일&lt;/strong&gt;은 &lt;strong&gt;자바 프로그램을 실행하기 전에 미리 기계어 코드로 변환하는 방식의 컴파일 기법&lt;/strong&gt;입니다.&lt;br&gt;
즉, &lt;strong&gt;JIT(Just-In-Time) 컴파일처럼 런타임에서 코드가 컴파일되는 것이 아니라, 애플리케이션 실행 전에 미리 컴파일&lt;/strong&gt;하여 성능을 향상시키는 방법입니다.&lt;/p&gt;
&lt;h2&gt;마무리&lt;/h2&gt;
&lt;p&gt;JVM의 JIT 컴파일러는 Java의 성능을 크게 향상시키는 핵심 기술입니다. 특히 티어드 컴파일을 통해 빠른 시작 속도와 높은 최적화 성능을 모두 얻을 수 있습니다.&lt;/p&gt;
&lt;p&gt;효과적인 JVM 튜닝을 위해서는:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;애플리케이션의 특성을 파악하고&lt;/li&gt;
&lt;li&gt;적절한 JIT 컴파일러를 선택하며&lt;/li&gt;
&lt;li&gt;필요한 경우 JVM 옵션을 조정하여 최적화하는 것이 중요합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이러한 이해를 바탕으로 Java 애플리케이션의 성능을 한 단계 더 향상시킬 수 있을 것입니다.&lt;/p&gt;</content:encoded></item></channel></rss>